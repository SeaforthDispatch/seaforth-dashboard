<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Seaforth Environmental Dispatch Dashboard</title>
  <link href="https://fonts.googleapis.com/css2?family=Archivo+Black&family=IBM+Plex+Mono:wght@400;600&family=Source+Serif+4:opsz,wght@8..60,400;8..60,600&display=swap" rel="stylesheet">
  <style>
    :root {
      --deep-navy: #0a1628;
      --ocean-dark: #0d2137;
      --ocean-mid: #143654;
      --teal-accent: #00d4aa;
      --teal-glow: #00ffcc;
      --amber-warning: #ffaa00;
      --coral-alert: #ff6b6b;
      --ice-white: #e8f4f8;
      --mist-gray: #94a3b8;
      --foam-white: #f0f9ff;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'IBM Plex Mono', monospace;
      background: var(--deep-navy);
      color: var(--ice-white);
      min-height: 100vh;
      overflow-x: hidden;
    }

    .ocean-bg {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      background: 
        radial-gradient(ellipse at 30% 20%, rgba(0, 212, 170, 0.08) 0%, transparent 50%),
        radial-gradient(ellipse at 70% 80%, rgba(20, 54, 84, 0.4) 0%, transparent 50%),
        linear-gradient(180deg, var(--deep-navy) 0%, var(--ocean-dark) 50%, var(--deep-navy) 100%);
    }

    .wave-pattern {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 200%;
      height: 200px;
      opacity: 0.03;
      background: repeating-linear-gradient(90deg, transparent, transparent 50px, var(--teal-accent) 50px, var(--teal-accent) 51px);
      animation: waveScroll 30s linear infinite;
    }

    @keyframes waveScroll {
      0% { transform: translateX(0); }
      100% { transform: translateX(-50%); }
    }

    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
      flex-direction: column;
      gap: 1.5rem;
    }

    .loading-spinner {
      width: 60px;
      height: 60px;
      border: 3px solid var(--ocean-mid);
      border-top-color: var(--teal-accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin { to { transform: rotate(360deg); } }

    .loading-text {
      font-size: 0.85rem;
      color: var(--mist-gray);
      letter-spacing: 0.1em;
    }

    .header {
      padding: 2rem 3rem;
      border-bottom: 1px solid rgba(0, 212, 170, 0.2);
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: rgba(10, 22, 40, 0.8);
      backdrop-filter: blur(10px);
      position: sticky;
      top: 0;
      z-index: 100;
    }

    .logo-section {
      display: flex;
      align-items: center;
      gap: 1.5rem;
    }

    .logo-icon {
      width: 56px;
      height: 56px;
      background: linear-gradient(135deg, var(--teal-accent), var(--ocean-mid));
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.8rem;
      box-shadow: 0 4px 20px rgba(0, 212, 170, 0.3);
    }

    .logo-text h1 {
      font-family: 'Archivo Black', sans-serif;
      font-size: 1.6rem;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      background: linear-gradient(90deg, var(--ice-white), var(--teal-accent));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      line-height: 1.1;
    }

    .logo-text h1 span {
      display: block;
      font-size: 0.9rem;
      letter-spacing: 0.15em;
      background: none;
      -webkit-text-fill-color: var(--mist-gray);
      color: var(--mist-gray);
    }

    .header-info { text-align: right; }

    .location {
      font-family: 'Source Serif 4', serif;
      font-size: 1.1rem;
      color: var(--foam-white);
    }

    .coordinates {
      font-size: 0.75rem;
      color: var(--teal-accent);
      margin-top: 0.25rem;
    }

    .last-update {
      font-size: 0.7rem;
      color: var(--mist-gray);
      margin-top: 0.5rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      justify-content: flex-end;
    }

    .live-indicator {
      width: 8px;
      height: 8px;
      background: var(--teal-accent);
      border-radius: 50%;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; box-shadow: 0 0 0 0 rgba(0, 212, 170, 0.5); }
      50% { opacity: 0.7; box-shadow: 0 0 0 6px rgba(0, 212, 170, 0); }
    }

    .main-content {
      padding: 2rem 3rem;
      max-width: 1800px;
      margin: 0 auto;
      display: none;
    }

    .main-content.loaded { display: block; }

    .current-hero {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 1rem;
      margin-bottom: 1.5rem;
    }

    .hero-card {
      background: linear-gradient(135deg, rgba(20, 54, 84, 0.6), rgba(13, 33, 55, 0.8));
      border: 1px solid rgba(0, 212, 170, 0.15);
      border-radius: 12px;
      padding: 1rem 1.25rem;
      position: relative;
      overflow: hidden;
    }

    .hero-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(90deg, transparent, var(--teal-accent), transparent);
    }

    .hero-card.temp-card::before { background: linear-gradient(90deg, transparent, var(--amber-warning), transparent); }
    .hero-card.conditions-card::before { background: linear-gradient(90deg, transparent, var(--foam-white), transparent); }

    .card-label {
      font-size: 0.55rem;
      text-transform: uppercase;
      letter-spacing: 0.15em;
      color: var(--mist-gray);
      margin-bottom: 0.25rem;
    }

    .card-value {
      font-family: 'Archivo Black', sans-serif;
      font-size: 2.2rem;
      line-height: 1;
      margin-bottom: 0.25rem;
    }

    .wind-card .card-value { color: var(--teal-accent); }
    .temp-card .card-value { color: var(--amber-warning); }

    .conditions-card .card-value {
      font-size: 1.3rem;
      color: var(--foam-white);
      font-family: 'Source Serif 4', serif;
      font-weight: 600;
    }

    .card-unit {
      font-size: 0.9rem;
      color: var(--mist-gray);
      font-weight: 400;
    }

    .card-detail {
      font-size: 0.65rem;
      color: var(--mist-gray);
      margin-top: 0.2rem;
    }

    .wind-direction {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.4rem;
    }

    .compass {
      width: 32px;
      height: 32px;
      border: 2px solid var(--teal-accent);
      border-radius: 50%;
      position: relative;
    }

    .compass-needle {
      width: 3px;
      height: 12px;
      background: linear-gradient(to top, var(--coral-alert), var(--teal-accent));
      border-radius: 2px;
      transform-origin: center bottom;
      position: absolute;
      top: 11px;
      left: 50%;
      margin-left: -2px;
      transition: transform 0.5s ease;
    }

    .compass::after {
      content: 'N';
      position: absolute;
      top: -18px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.55rem;
      color: var(--mist-gray);
    }

    .weather-source-info {
      text-align: center;
      font-size: 0.7rem;
      color: var(--mist-gray);
      margin-bottom: 1.5rem;
      padding: 0.5rem;
      background: rgba(0, 212, 170, 0.05);
      border-radius: 6px;
      border: 1px solid rgba(0, 212, 170, 0.1);
    }
    
    .weather-source-info .source-label {
      color: rgba(200, 200, 200, 0.6);
    }
    
    .weather-source-info .source-separator {
      margin: 0 0.75rem;
      color: rgba(0, 212, 170, 0.3);
    }
    
    #weatherStation, #weatherSource {
      color: var(--teal-accent);
    }

    .section-title {
      font-family: 'Archivo Black', sans-serif;
      font-size: 0.9rem;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      color: var(--mist-gray);
      margin-bottom: 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid rgba(0, 212, 170, 0.2);
    }

    .forecast-section { margin-bottom: 2rem; }

    /* EC Official Marine Forecast Section */
    .ec-marine-forecast-section {
      margin-bottom: 2rem;
    }
    
    .ec-marine-forecast-container {
      background: linear-gradient(135deg, rgba(13, 33, 55, 0.9) 0%, rgba(20, 45, 70, 0.8) 100%);
      border: 1px solid rgba(0, 212, 170, 0.2);
      border-radius: 12px;
      overflow: hidden;
    }
    
    .ec-forecast-panel {
      padding: 1.25rem;
    }
    
    .ec-forecast-loading {
      text-align: center;
      color: var(--mist-gray);
      padding: 2rem;
    }
    
    .ec-forecast-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 1rem;
    }
    
    .ec-forecast-card {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 8px;
      padding: 1rem;
      border-left: 3px solid var(--teal-accent);
    }
    
    .ec-forecast-card.warning {
      border-left-color: #ff6b6b;
      background: rgba(255, 107, 107, 0.1);
    }
    
    .ec-forecast-card.extended {
      border-left-color: rgba(0, 212, 170, 0.5);
    }
    
    .ec-forecast-card-title {
      font-family: 'Archivo Black', sans-serif;
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--teal-accent);
      margin-bottom: 0.5rem;
    }
    
    .ec-forecast-card.warning .ec-forecast-card-title {
      color: #ff6b6b;
    }
    
    .ec-forecast-card-content {
      font-size: 0.85rem;
      line-height: 1.5;
      color: rgba(255, 255, 255, 0.9);
    }
    
    .ec-forecast-wind {
      margin-bottom: 0.5rem;
    }
    
    .ec-forecast-weather {
      color: rgba(200, 200, 200, 0.8);
      font-size: 0.8rem;
    }
    
    .ec-forecast-meta {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1.25rem;
      background: rgba(0, 0, 0, 0.3);
      font-size: 0.7rem;
      color: var(--mist-gray);
    }
    
    .ec-forecast-link {
      color: var(--teal-accent);
      text-decoration: none;
    }
    
    .ec-forecast-link:hover {
      text-decoration: underline;
    }
    
    .ec-extended-forecasts {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 0.75rem;
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 1px solid rgba(0, 212, 170, 0.1);
    }
    
    .ec-extended-day {
      background: rgba(0, 0, 0, 0.15);
      border-radius: 6px;
      padding: 0.75rem;
    }
    
    .ec-extended-day-name {
      font-weight: 600;
      font-size: 0.75rem;
      color: var(--teal-accent);
      margin-bottom: 0.25rem;
    }
    
    .ec-extended-day-forecast {
      font-size: 0.75rem;
      color: rgba(200, 200, 200, 0.8);
      line-height: 1.4;
    }

    /* Main 3-Column Dashboard Grid */
    .main-dashboard-grid {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 1.5rem;
      margin-bottom: 2.5rem;
    }

    .dashboard-column {
      display: flex;
      flex-direction: column;
    }

    .dashboard-column .section-title {
      margin-bottom: 1rem;
    }

    .forecast-column .marine-forecast-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .narrows-column .narrows-panel {
      flex: 1;
    }

    .narrows-source-link {
      text-align: center;
      margin-top: 0.75rem;
      font-size: 0.65rem;
      color: var(--mist-gray);
    }

    .narrows-source-link a {
      color: var(--teal-accent);
      text-decoration: none;
    }

    .narrows-source-link a:hover {
      text-decoration: underline;
    }

    /* Tablet: 2 columns (forecast full width on top, narrows side by side below) */
    @media (max-width: 1200px) {
      .main-dashboard-grid {
        grid-template-columns: 1fr 1fr;
      }
      
      .forecast-column {
        grid-column: 1 / -1;
      }
    }

    /* Mobile: 1 column */
    @media (max-width: 768px) {
      .main-dashboard-grid {
        grid-template-columns: 1fr;
      }
      
      .forecast-column {
        grid-column: auto;
      }
      
      .forecast-hours-grid {
        grid-template-columns: repeat(6, 1fr);
      }
    }
    
    @media (max-width: 480px) {
      .forecast-hours-grid {
        grid-template-columns: repeat(4, 1fr);
      }
    }

    .marine-alert {
      background: linear-gradient(90deg, rgba(0, 212, 170, 0.1), transparent);
      border-left: 4px solid var(--teal-accent);
      padding: 1rem 1.5rem;
      margin-bottom: 1.5rem;
      border-radius: 0 8px 8px 0;
    }

    .marine-alert a { color: var(--teal-accent); text-decoration: none; }
    .marine-alert a:hover { text-decoration: underline; }

    .alert-title {
      font-weight: 600;
      color: var(--teal-accent);
      font-size: 0.85rem;
      margin-bottom: 0.5rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    .alert-text {
      font-family: 'Source Serif 4', serif;
      font-size: 0.95rem;
      color: var(--foam-white);
      line-height: 1.6;
    }

    /* 3-Day Marine Forecast Styles */
    .marine-forecast-container {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .forecast-day-panel {
      background: rgba(13, 33, 55, 0.5);
      border-radius: 12px;
      border: 1px solid rgba(0, 212, 170, 0.1);
      overflow: hidden;
    }

    .forecast-day-header {
      background: rgba(0, 212, 170, 0.1);
      padding: 0.6rem 0.75rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid rgba(0, 212, 170, 0.1);
    }

    .forecast-day-name {
      font-family: 'Archivo Black', sans-serif;
      font-size: 0.75rem;
      color: var(--foam-white);
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    .forecast-day-summary {
      font-size: 0.6rem;
      color: var(--mist-gray);
    }

    .forecast-hours-grid {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      gap: 0.25rem;
      padding: 0.5rem;
    }

    .forecast-hour-cell {
      background: rgba(20, 54, 84, 0.4);
      border-radius: 6px;
      padding: 0.4rem 0.25rem;
      text-align: center;
      transition: all 0.2s ease;
      border: 1px solid transparent;
    }

    .forecast-hour-cell:hover {
      background: rgba(20, 54, 84, 0.7);
      border-color: rgba(0, 212, 170, 0.3);
    }

    .forecast-hour-cell.current {
      background: rgba(0, 212, 170, 0.15);
      border-color: var(--teal-accent);
    }

    .hour-cell-time {
      font-size: 0.55rem;
      font-weight: 600;
      color: var(--mist-gray);
      margin-bottom: 0.2rem;
    }

    .hour-cell-icon {
      font-size: 1.2rem;
      line-height: 1;
      margin-bottom: 0.15rem;
    }

    .hour-cell-temp {
      font-size: 0.7rem;
      font-weight: 600;
      color: var(--amber-warning);
      margin-bottom: 0.15rem;
    }

    .hour-cell-wind {
      font-size: 0.65rem;
      font-weight: 600;
      margin-bottom: 0.1rem;
    }

    .hour-cell-wind.light { color: #64b5f6; }
    .hour-cell-wind.moderate { color: var(--teal-accent); }
    .hour-cell-wind.fresh { color: var(--amber-warning); }
    .hour-cell-wind.strong { color: var(--coral-alert); }

    .hour-cell-wind-dir {
      font-size: 0.45rem;
      color: var(--mist-gray);
      margin-bottom: 0.15rem;
    }

    .hour-cell-rain {
      font-size: 0.5rem;
      color: #64b5f6;
    }

    .hour-cell-rain.none {
      color: var(--ocean-mid);
    }

    .tide-section { margin-bottom: 2.5rem; }

    .tide-station-panel {
      background: linear-gradient(135deg, rgba(20, 54, 84, 0.5), rgba(13, 33, 55, 0.7));
      border-radius: 12px;
      padding: 1rem;
      margin-bottom: 1rem;
      border: 1px solid rgba(0, 212, 170, 0.15);
    }

    .tide-station-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.75rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid rgba(0, 212, 170, 0.1);
    }

    .tide-station-name {
      font-family: 'Archivo Black', sans-serif;
      font-size: 0.9rem;
      color: var(--foam-white);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .tide-station-location {
      font-size: 0.65rem;
      color: var(--mist-gray);
    }

    .tide-graph-container {
      position: relative;
      height: 140px;
      margin-bottom: 0.5rem;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 8px;
      overflow: hidden;
    }

    .tide-graph {
      width: 100%;
      height: 100%;
      cursor: crosshair;
    }

    .tide-graph-now-marker {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 2px;
      background: var(--coral-alert);
      box-shadow: 0 0 8px var(--coral-alert);
      z-index: 10;
    }

    .tide-graph-now-marker::before {
      content: 'NOW';
      position: absolute;
      top: 2px;
      left: 4px;
      font-size: 0.45rem;
      color: var(--coral-alert);
      font-weight: 600;
      letter-spacing: 0.05em;
    }

    .tide-events-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(70px, 1fr));
      gap: 0.35rem;
    }

    .tide-event-card {
      background: rgba(0, 0, 0, 0.25);
      border-radius: 6px;
      padding: 0.4rem 0.25rem;
      text-align: center;
      border-left: 3px solid transparent;
    }

    .tide-event-card.high {
      border-left-color: var(--teal-accent);
    }

    .tide-event-card.low {
      border-left-color: var(--coral-alert);
    }

    .tide-event-card.next {
      background: rgba(0, 212, 170, 0.15);
    }

    .tide-event-time {
      font-size: 0.55rem;
      color: var(--mist-gray);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 0.2rem;
    }

    .tide-event-type {
      font-family: 'Archivo Black', sans-serif;
      font-size: 0.7rem;
      margin-bottom: 0.2rem;
    }

    .tide-event-type.high { color: var(--teal-accent); }
    .tide-event-type.low { color: var(--coral-alert); }

    .tide-event-height {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--foam-white);
      line-height: 1.2;
    }

    .tide-event-height-ft {
      font-size: 0.6rem;
      color: var(--mist-gray);
    }

    .tide-source-link {
      text-align: center;
      font-size: 0.65rem;
      color: var(--mist-gray);
      margin-top: 0.5rem;
    }

    .tide-source-link a {
      color: var(--teal-accent);
      text-decoration: none;
    }

    .tide-source-link a:hover {
      text-decoration: underline;
    }

    /* Current Section Styles */
    .narrows-panel {
      background: linear-gradient(135deg, rgba(20, 54, 84, 0.5), rgba(13, 33, 55, 0.7));
      border-radius: 12px;
      padding: 1rem;
      border: 1px solid rgba(0, 212, 170, 0.15);
    }

    .narrows-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.75rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid rgba(0, 212, 170, 0.1);
    }

    .narrows-name {
      font-family: 'Archivo Black', sans-serif;
      font-size: 0.85rem;
      color: var(--foam-white);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .narrows-location {
      font-size: 0.6rem;
      color: var(--mist-gray);
    }

    /* Current Status Display */
    .current-status {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin-bottom: 1rem;
    }

    .current-arrow-container {
      width: 60px;
      height: 60px;
      min-width: 60px;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .current-ring {
      position: absolute;
      width: 100%;
      height: 100%;
      border: 2px solid rgba(0, 212, 170, 0.3);
      border-radius: 50%;
    }

    .current-arrow {
      width: 45px;
      height: 45px;
      transition: transform 0.5s ease;
    }

    .current-arrow.flood { color: var(--teal-accent); }
    .current-arrow.ebb { color: var(--coral-alert); }
    .current-arrow.slack { color: var(--mist-gray); }

    .current-info {
      flex: 1;
      min-width: 0;
    }

    .current-state {
      font-family: 'Archivo Black', sans-serif;
      font-size: 1.1rem;
      margin-bottom: 0.15rem;
    }

    .current-state.flood { color: var(--teal-accent); }
    .current-state.ebb { color: var(--coral-alert); }
    .current-state.slack { color: var(--amber-warning); }

    .current-speed {
      font-size: 1.5rem;
      font-weight: 600;
      color: var(--foam-white);
      line-height: 1;
    }

    .current-speed .unit {
      font-size: 0.8rem;
      color: var(--mist-gray);
      font-weight: 400;
    }

    .current-direction {
      font-size: 0.65rem;
      color: var(--mist-gray);
      margin-top: 0.2rem;
    }

    /* Current Timeline */
    .current-timeline {
      margin-top: 1rem;
    }

    .timeline-label {
      font-size: 0.6rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--mist-gray);
      margin-bottom: 0.5rem;
    }

    .timeline-bar {
      height: 8px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 4px;
      position: relative;
      overflow: hidden;
    }

    .timeline-progress {
      position: absolute;
      height: 100%;
      border-radius: 4px;
      transition: width 0.5s ease;
    }

    .timeline-progress.flood {
      background: linear-gradient(90deg, var(--teal-accent), rgba(0, 212, 170, 0.5));
    }

    .timeline-progress.ebb {
      background: linear-gradient(90deg, var(--coral-alert), rgba(255, 107, 107, 0.5));
    }

    .timeline-marker {
      position: absolute;
      top: -4px;
      width: 2px;
      height: 16px;
      background: var(--foam-white);
      border-radius: 1px;
    }

    /* Current Events List */
    .current-events {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 0.5rem;
      margin-top: 1rem;
    }

    .current-event {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 8px;
      padding: 0.6rem 0.75rem;
      display: flex;
      flex-direction: column;
    }

    .event-time {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--foam-white);
    }

    .event-type {
      font-size: 0.6rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-top: 0.15rem;
    }

    .event-type.slack { color: var(--amber-warning); }
    .event-type.max-flood { color: var(--teal-accent); }
    .event-type.max-ebb { color: var(--coral-alert); }

    .event-speed {
      font-size: 0.75rem;
      color: var(--mist-gray);
      margin-top: 0.1rem;
    }

    /* Slack Window Visual Timeline */
    .slack-windows {
      margin-top: 1rem;
      padding-top: 0.75rem;
      border-top: 1px solid rgba(0, 212, 170, 0.1);
    }

    .slack-windows-title {
      font-size: 0.6rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--mist-gray);
      margin-bottom: 0.5rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .slack-windows-title::before {
      content: '‚óà';
      color: var(--amber-warning);
    }

    .window-card {
      background: rgba(0, 0, 0, 0.25);
      border-radius: 8px;
      padding: 0.6rem;
      margin-bottom: 0.5rem;
      border-left: 3px solid var(--amber-warning);
    }

    .window-card.active {
      background: rgba(255, 170, 0, 0.15);
      border-left-color: var(--teal-glow);
    }

    .window-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.4rem;
      flex-wrap: wrap;
      gap: 0.25rem;
    }

    .window-type {
      font-family: 'Archivo Black', sans-serif;
      font-size: 0.65rem;
      color: var(--amber-warning);
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }

    .window-card.active .window-type {
      color: var(--teal-glow);
    }

    .window-badge {
      font-size: 0.5rem;
      padding: 0.15rem 0.4rem;
      border-radius: 4px;
      background: rgba(0, 212, 170, 0.2);
      color: var(--teal-accent);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .window-card.active .window-badge {
      background: var(--teal-accent);
      color: var(--deep-navy);
      font-weight: 600;
    }

    .window-visual {
      position: relative;
      height: 24px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 4px;
      margin: 0.4rem 0;
      overflow: hidden;
    }

    .window-safe-zone {
      position: absolute;
      height: 100%;
      background: linear-gradient(90deg, 
        rgba(255, 170, 0, 0.1), 
        rgba(255, 170, 0, 0.3), 
        rgba(255, 170, 0, 0.3),
        rgba(255, 170, 0, 0.1)
      );
      border-left: 2px solid var(--amber-warning);
      border-right: 2px solid var(--amber-warning);
    }

    .window-slack-marker {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 2px;
      background: var(--foam-white);
      box-shadow: 0 0 6px rgba(255, 255, 255, 0.5);
    }

    .window-now-marker {
      position: absolute;
      top: -3px;
      bottom: -3px;
      width: 2px;
      background: var(--teal-glow);
      box-shadow: 0 0 8px var(--teal-glow);
      z-index: 10;
    }

    .window-now-marker::before {
      content: 'NOW';
      position: absolute;
      top: -12px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.4rem;
      color: var(--teal-glow);
      font-weight: 600;
      letter-spacing: 0.05em;
    }

    .window-flood-zone {
      position: absolute;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(0, 212, 170, 0.15));
    }

    .window-ebb-zone {
      position: absolute;
      height: 100%;
      background: linear-gradient(90deg, rgba(255, 107, 107, 0.15), transparent);
    }

    .window-times {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      font-size: 0.6rem;
      margin-top: 0.3rem;
    }

    .window-time-block {
      text-align: center;
    }

    .window-time-block.center {
      flex: 1;
    }

    .window-time-label {
      font-size: 0.4rem;
      color: var(--mist-gray);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .window-time-value {
      font-weight: 600;
      color: var(--foam-white);
      font-size: 0.75rem;
    }

    .window-time-value.slack {
      color: var(--amber-warning);
    }

    .window-duration {
      font-size: 0.55rem;
      color: var(--mist-gray);
      text-align: center;
      margin-top: 0.25rem;
    }

    .window-duration strong {
      color: var(--amber-warning);
      font-weight: 600;
    }

    .footer {
      padding: 2rem 3rem;
      border-top: 1px solid rgba(0, 212, 170, 0.1);
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.7rem;
      color: var(--mist-gray);
      flex-wrap: wrap;
      gap: 1rem;
    }

    .data-sources { display: flex; gap: 2rem; flex-wrap: wrap; }
    .data-source { display: flex; align-items: center; gap: 0.5rem; }
    .source-dot { width: 6px; height: 6px; border-radius: 50%; background: var(--teal-accent); animation: pulse 2s infinite; }
    .refresh-info { font-size: 0.65rem; color: var(--mist-gray); cursor: pointer; }
    .refresh-info:hover { color: var(--teal-accent); }

    @media (max-width: 1200px) { .current-hero { grid-template-columns: 1fr 1fr; } }

    @media (max-width: 768px) {
      .header { flex-direction: column; gap: 1rem; padding: 1.5rem; }
      .header-info { text-align: center; }
      .last-update { justify-content: center; }
      .current-hero { grid-template-columns: 1fr; }
      .main-content { padding: 1.5rem; }
      .card-value { font-size: 2.5rem; }
      .forecast-grid { grid-template-columns: repeat(auto-fill, minmax(75px, 1fr)); }
    }

    .error-message {
      background: linear-gradient(90deg, rgba(255, 107, 107, 0.15), transparent);
      border-left: 4px solid var(--coral-alert);
      padding: 1.5rem;
      margin: 2rem 3rem;
      border-radius: 0 8px 8px 0;
      color: var(--foam-white);
    }

    .error-message h3 { color: var(--coral-alert); margin-bottom: 0.5rem; font-family: 'Archivo Black', sans-serif; font-size: 1rem; }
    .error-message a { color: var(--teal-accent); }

    .retry-btn {
      margin-top: 1rem;
      padding: 0.75rem 1.5rem;
      background: var(--teal-accent);
      color: var(--deep-navy);
      border: none;
      border-radius: 8px;
      font-family: 'IBM Plex Mono', monospace;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }

    .retry-btn:hover { background: var(--teal-glow); transform: translateY(-2px); }
  </style>
</head>
<body>
  <div class="ocean-bg"></div>
  <div class="wave-pattern"></div>

  <div class="loading" id="loadingState">
    <div class="loading-spinner"></div>
    <div class="loading-text">ACQUIRING ENVIRONMENTAL DATA...</div>
  </div>

  <div id="errorState" style="display: none;"></div>

  <header class="header">
    <div class="logo-section">
      <div class="logo-icon">‚öì</div>
      <div class="logo-text">
        <h1>Seaforth Environmental<span>Dispatch Dashboard</span></h1>
      </div>
    </div>
    <div class="header-info">
      <div class="location">Vancouver, British Columbia</div>
      <div class="coordinates">49.30¬∞N ¬∑ 123.11¬∞W</div>
      <div class="last-update">
        <span class="live-indicator"></span>
        <span>Last updated: <span id="updateTime">‚Äî</span></span>
      </div>
    </div>
  </header>

  <main class="main-content" id="mainContent">
    <section class="current-hero">
      <div class="hero-card wind-card">
        <div class="card-label">Current Wind</div>
        <div class="card-value"><span id="currentWind">‚Äî</span> <span class="card-unit">kts</span></div>
        <div class="wind-direction">
          <div class="compass"><div class="compass-needle" id="compassNeedle"></div></div>
          <span id="windDirText">‚Äî</span>
        </div>
        <div class="card-detail">Gusts to <span id="currentGust">‚Äî</span> kts</div>
      </div>
      <div class="hero-card temp-card">
        <div class="card-label">Temperature</div>
        <div class="card-value"><span id="currentTemp">‚Äî</span><span class="card-unit">¬∞C</span></div>
        <div class="card-detail">Humidity: <span id="currentHumidity">‚Äî</span>%</div>
        <div class="card-detail">Feels like: <span id="feelsLike">‚Äî</span>¬∞C</div>
      </div>
      <div class="hero-card conditions-card">
        <div class="card-label">Conditions</div>
        <div class="card-value" id="currentConditions">‚Äî</div>
        <div class="card-detail">Cloud Cover: <span id="cloudCover">‚Äî</span>%</div>
        <div class="card-detail">Barometer: <span id="pressure">‚Äî</span> hPa</div>
      </div>
    </section>
    
    <div class="weather-source-info">
      <span class="source-label">üìç Station:</span> <span id="weatherStation">‚Äî</span>
      <span class="source-separator">¬∑</span>
      <span class="source-label">üì° Source:</span> <span id="weatherSource">‚Äî</span>
    </div>

    <section class="forecast-section">
      <div class="marine-alert">
        <div class="alert-title">üì° Live Data Feed</div>
        <div class="alert-text">
          Current conditions from <span id="alertSourceName">Environment Canada</span> weather station. Forecasts from Open-Meteo (GFS/ICON models).
          For official marine warnings: <a href="https://weather.gc.ca/marine/forecast_e.html?mapID=02&siteID=14305" target="_blank">Environment Canada Marine Forecasts</a>
        </div>
      </div>
    </section>
    
    <!-- EC Official Marine Forecast -->
    <section class="ec-marine-forecast-section">
      <h2 class="section-title">Environment Canada Marine Forecast ‚Äî Strait of Georgia (South)</h2>
      <div class="ec-marine-forecast-container">
        <div class="ec-forecast-panel" id="ecMarineForecast">
          <div class="ec-forecast-loading">Loading official marine forecast...</div>
        </div>
        <div class="ec-forecast-meta">
          <span id="ecForecastIssued">‚Äî</span>
          <a href="https://weather.gc.ca/marine/forecast_e.html?mapID=02&siteID=14305" target="_blank" class="ec-forecast-link">View Full Forecast ‚Üí</a>
        </div>
      </div>
    </section>

    <!-- Main 3-Column Layout: Marine Forecast + Currents -->
    <section class="main-dashboard-grid">
      <!-- Left Column: 3-Day Marine Forecast -->
      <div class="dashboard-column forecast-column">
        <h2 class="section-title">Hourly Conditions (72h)</h2>
        <div class="marine-forecast-container" id="marineForecastContainer">
          <!-- Populated by JavaScript -->
        </div>
      </div>

      <!-- Middle Column: First Narrows -->
      <div class="dashboard-column narrows-column">
        <h2 class="section-title">First Narrows</h2>
        <div class="narrows-panel" id="firstNarrowsPanel">
          <div class="narrows-header">
            <div>
              <div class="narrows-name">Lions Gate Bridge</div>
              <div class="narrows-location">Station 07721</div>
            </div>
          </div>
          <div class="current-status">
            <div class="current-arrow-container">
              <div class="current-ring"></div>
              <svg class="current-arrow flood" id="firstNarrowsArrow" viewBox="0 0 24 24" fill="currentColor">
                <path d="M12 2L4 12h5v10h6V12h5L12 2z"/>
              </svg>
            </div>
            <div class="current-info">
              <div class="current-state flood" id="firstNarrowsState">FLOOD</div>
              <div class="current-speed"><span id="firstNarrowsSpeed">2.4</span> <span class="unit">kts</span></div>
              <div class="current-direction" id="firstNarrowsDir">Flowing SE (135¬∞) into harbour</div>
            </div>
          </div>
          <div class="current-timeline">
            <div class="timeline-label">Current Cycle Progress</div>
            <div class="timeline-bar">
              <div class="timeline-progress flood" id="firstNarrowsProgress" style="width: 45%"></div>
              <div class="timeline-marker" id="firstNarrowsMarker" style="left: 45%"></div>
            </div>
          </div>
          <div class="current-events" id="firstNarrowsEvents"></div>
          <div class="slack-windows" id="firstNarrowsWindows"></div>
        </div>
        <div class="narrows-source-link">
          <a href="http://www.dairiki.org/tides/daily.php/fir" target="_blank">XTide Data</a> ¬∑ 
          <a href="https://tides.gc.ca/en/current-predictions-station" target="_blank">CHS Tables</a>
        </div>
      </div>

      <!-- Right Column: Second Narrows -->
      <div class="dashboard-column narrows-column">
        <h2 class="section-title">Second Narrows</h2>
        <div class="narrows-panel" id="secondNarrowsPanel">
          <div class="narrows-header">
            <div>
              <div class="narrows-name">Ironworkers Bridge</div>
              <div class="narrows-location">Station 07745</div>
            </div>
          </div>
          <div class="current-status">
            <div class="current-arrow-container">
              <div class="current-ring"></div>
              <svg class="current-arrow flood" id="secondNarrowsArrow" viewBox="0 0 24 24" fill="currentColor">
                <path d="M12 2L4 12h5v10h6V12h5L12 2z"/>
              </svg>
            </div>
            <div class="current-info">
              <div class="current-state flood" id="secondNarrowsState">FLOOD</div>
              <div class="current-speed"><span id="secondNarrowsSpeed">2.1</span> <span class="unit">kts</span></div>
              <div class="current-direction" id="secondNarrowsDir">Flowing E (090¬∞) into harbour</div>
            </div>
          </div>
          <div class="current-timeline">
            <div class="timeline-label">Current Cycle Progress</div>
            <div class="timeline-bar">
              <div class="timeline-progress flood" id="secondNarrowsProgress" style="width: 45%"></div>
              <div class="timeline-marker" id="secondNarrowsMarker" style="left: 45%"></div>
            </div>
          </div>
          <div class="current-events" id="secondNarrowsEvents"></div>
          <div class="slack-windows" id="secondNarrowsWindows"></div>
        </div>
        <div class="narrows-source-link">
          <a href="http://www.dairiki.org/tides/daily.php/sec" target="_blank">XTide Data</a> ¬∑ 
          <a href="https://tides.gc.ca/en/current-predictions-station" target="_blank">CHS Tables</a>
        </div>
      </div>
    </section>

    <section class="tide-section">
      <h2 class="section-title">Tides ‚Äî Second Narrows & Steveston</h2>
      
      <!-- Second Narrows Tides -->
      <div class="tide-station-panel">
        <div class="tide-station-header">
          <div class="tide-station-name">Second Narrows</div>
          <div class="tide-station-location">Vancouver Harbour ‚Ä¢ Station 7735</div>
        </div>
        <div class="tide-graph-container">
          <canvas id="secondNarrowsTideGraph" class="tide-graph"></canvas>
          <div class="tide-graph-now-marker" id="secondNarrowsNowMarker"></div>
        </div>
      </div>
      
      <!-- Steveston/Richmond Tides -->
      <div class="tide-station-panel">
        <div class="tide-station-header">
          <div class="tide-station-name">Steveston (Richmond)</div>
          <div class="tide-station-location">Fraser River Mouth ‚Ä¢ Station 7607</div>
        </div>
        <div class="tide-graph-container">
          <canvas id="stevestonTideGraph" class="tide-graph"></canvas>
          <div class="tide-graph-now-marker" id="stevestonNowMarker"></div>
        </div>
      </div>
      
      <div class="tide-source-link">
        Data from XTide harmonics. Official sources: 
        <a href="https://tides.gc.ca/en/stations/7735" target="_blank">CHS Vancouver</a> ¬∑ 
        <a href="https://tides.gc.ca/en/stations/7607" target="_blank">CHS Steveston</a>
      </div>
    </section>

    <!-- Fraser River Water Levels Section -->
    <section class="tide-section">
      <h2 class="section-title">Fraser River ‚Äî Water Levels & Velocities (km 20)</h2>
      
      <!-- South Arm -->
      <div class="tide-station-panel">
        <div class="tide-station-header">
          <div class="tide-station-name">South Arm</div>
          <div class="tide-station-location">km 20 marker ‚Ä¢ Main Navigation Channel</div>
        </div>
        <div class="tide-graph-container">
          <canvas id="fraserSouthGraph" class="tide-graph"></canvas>
          <div class="tide-graph-now-marker" id="fraserSouthNowMarker"></div>
        </div>
      </div>
      
      <!-- North Arm -->
      <div class="tide-station-panel">
        <div class="tide-station-header">
          <div class="tide-station-name">North Arm</div>
          <div class="tide-station-location">km 20 marker ‚Ä¢ Mitchell Island area</div>
        </div>
        <div class="tide-graph-container">
          <canvas id="fraserNorthGraph" class="tide-graph"></canvas>
          <div class="tide-graph-now-marker" id="fraserNorthNowMarker"></div>
        </div>
      </div>
      
      <div class="tide-source-link">
        Data based on Avadepth hydrodynamic model patterns. Official source: 
        <a href="https://www2.pac.dfo-mpo.gc.ca/avdpth_srch-eng.html?page=pwl" target="_blank">CCG Avadepth</a>
      </div>
    </section>
  </main>

  <footer class="footer">
    <div class="data-sources">
      <div class="data-source"><span class="source-dot"></span><span>Environment Canada SWOB</span></div>
      <div class="data-source"><span class="source-dot"></span><span>Open-Meteo Forecasts</span></div>
      <div class="data-source"><span class="source-dot"></span><span>XTide Harmonics</span></div>
      <div class="data-source"><span class="source-dot"></span><span>CCG Avadepth</span></div>
    </div>
    <div>
      <div>Seaforth Environmental Dispatch Dashboard ¬© 2026</div>
      <div class="refresh-info" id="refreshBtn">üîÑ Click to refresh | Auto-refresh: 30 min</div>
    </div>
  </footer>

  <script>
    const CONFIG = { lat: 49.30, lon: -123.11, refreshInterval: 30 * 60 * 1000 };

    const weatherCodes = {
      0: 'Clear Sky', 1: 'Mainly Clear', 2: 'Partly Cloudy', 3: 'Overcast',
      45: 'Foggy', 48: 'Rime Fog', 51: 'Light Drizzle', 53: 'Drizzle', 55: 'Dense Drizzle',
      61: 'Slight Rain', 63: 'Moderate Rain', 65: 'Heavy Rain', 66: 'Freezing Rain', 67: 'Heavy Freezing Rain',
      71: 'Slight Snow', 73: 'Moderate Snow', 75: 'Heavy Snow', 77: 'Snow Grains',
      80: 'Rain Showers', 81: 'Moderate Showers', 82: 'Heavy Showers', 85: 'Snow Showers', 86: 'Heavy Snow Showers',
      95: 'Thunderstorm', 96: 'Thunderstorm + Hail', 99: 'Severe Thunderstorm'
    };

    const weatherIcons = {
      0: '‚òÄÔ∏è', 1: 'üå§Ô∏è', 2: '‚õÖ', 3: '‚òÅÔ∏è', 45: 'üå´Ô∏è', 48: 'üå´Ô∏è',
      51: 'üå¶Ô∏è', 53: 'üå¶Ô∏è', 55: 'üåßÔ∏è', 61: 'üåßÔ∏è', 63: 'üåßÔ∏è', 65: 'üåßÔ∏è', 66: 'üå®Ô∏è', 67: 'üå®Ô∏è',
      71: 'üå®Ô∏è', 73: 'üå®Ô∏è', 75: '‚ùÑÔ∏è', 77: 'üå®Ô∏è', 80: 'üå¶Ô∏è', 81: 'üåßÔ∏è', 82: '‚õàÔ∏è',
      85: 'üå®Ô∏è', 86: 'üå®Ô∏è', 95: '‚õàÔ∏è', 96: '‚õàÔ∏è', 99: '‚õàÔ∏è'
    };

    const msToKnots = ms => Math.round(ms * 1.944);
    const getWindDirection = deg => ['N','NNE','NE','ENE','E','ESE','SE','SSE','S','SSW','SW','WSW','W','WNW','NW','NNW'][Math.round(deg / 22.5) % 16];
    const getWindClass = kts => kts < 5 ? 'light' : kts < 12 ? 'moderate' : kts < 20 ? 'fresh' : 'strong';
    const formatTime = d => d.toLocaleTimeString('en-CA', { hour: '2-digit', minute: '2-digit', hour12: false });
    const formatDay = d => d.toLocaleDateString('en-CA', { weekday: 'short' });
    const formatDateTime = d => d.toLocaleString('en-CA', { day: '2-digit', month: 'short', year: 'numeric', hour: '2-digit', minute: '2-digit', timeZoneName: 'short' });

    function showError(msg) {
      document.getElementById('loadingState').style.display = 'none';
      document.getElementById('mainContent').classList.remove('loaded');
      const err = document.getElementById('errorState');
      err.style.display = 'block';
      err.innerHTML = `
        <div class="error-message">
          <h3>‚ö†Ô∏è Unable to Load Weather Data</h3>
          <p>${msg}</p>
          <p style="margin-top:1rem;font-size:0.85rem">This is often caused by browser security when opening the file directly (file:// protocol).</p>
          <p style="margin-top:0.75rem;font-size:0.85rem"><strong>Quick fixes:</strong></p>
          <ul style="margin:0.5rem 0 0 1.5rem;font-size:0.85rem;line-height:1.8">
            <li>Upload this file to any web hosting (GitHub Pages, Netlify, etc.)</li>
            <li>Run a local server: <code style="background:var(--ocean-mid);padding:2px 6px;border-radius:4px">python -m http.server 8000</code></li>
            <li>Or use these direct links for current data:</li>
          </ul>
          <p style="margin-top:1rem">
            <a href="https://www.windfinder.com/forecast/vancouver_harbour" target="_blank">‚Üí Windfinder Vancouver Harbour</a><br>
            <a href="https://weather.gc.ca/marine/forecast_e.html?mapID=02&siteID=14305" target="_blank">‚Üí Environment Canada Marine</a><br>
            <a href="https://tides.gc.ca/en/stations/7735" target="_blank">‚Üí Canadian Tides - Vancouver</a>
          </p>
          <button class="retry-btn" onclick="initialize()">Try Again</button>
        </div>`;
    }

    // Environment Canada Marine Forecast RSS Feed
    // Strait of Georgia - covers both north (14301) and south (14305) of Nanaimo
    const EC_MARINE_RSS = 'https://weather.gc.ca/rss/marine/14300_e.xml';
    
    async function fetchECMarineForecast() {
      const container = document.getElementById('ecMarineForecast');
      const issuedEl = document.getElementById('ecForecastIssued');
      
      try {
        // Use a CORS proxy or direct fetch
        const res = await fetch(EC_MARINE_RSS);
        if (!res.ok) throw new Error(`RSS fetch failed: ${res.status}`);
        
        const text = await res.text();
        const parser = new DOMParser();
        const xml = parser.parseFromString(text, 'text/xml');
        
        const entries = xml.querySelectorAll('entry');
        if (entries.length === 0) throw new Error('No forecast entries found');
        
        let html = '<div class="ec-forecast-grid">';
        let extendedForecasts = [];
        let issuedTime = '';
        
        entries.forEach((entry, idx) => {
          const title = entry.querySelector('title')?.textContent || '';
          const summary = entry.querySelector('summary')?.textContent || '';
          const updated = entry.querySelector('updated')?.textContent || '';
          
          // Extract issued time from summary
          const issuedMatch = summary.match(/Issued\s+(\d{1,2}:\d{2}\s+[AP]M\s+\w+\s+\d+\s+\w+\s+\d{4})/i);
          if (issuedMatch && !issuedTime) {
            issuedTime = issuedMatch[1];
          }
          
          // Check if this is for our area (14305 = south of Nanaimo)
          const id = entry.querySelector('id')?.textContent || '';
          const isSouthArea = id.includes('14305');
          
          if (isSouthArea) {
            // Parse the forecast content
            const cleanSummary = summary.replace(/<br\/?>/gi, '\n').replace(/Issued.*/i, '').trim();
            
            if (title.toLowerCase().includes('extended')) {
              // Extended forecast - parse individual days
              const days = cleanSummary.split('\n').filter(d => d.trim());
              days.forEach(day => {
                const dayMatch = day.match(/^(\w+):\s*(.+)$/);
                if (dayMatch) {
                  extendedForecasts.push({
                    day: dayMatch[1],
                    forecast: dayMatch[2]
                  });
                }
              });
            } else if (title.toLowerCase().includes('forecast for')) {
              // Main forecast
              const lines = cleanSummary.split('\n').filter(l => l.trim());
              const windLines = lines.filter(l => l.toLowerCase().includes('wind'));
              const weatherLines = lines.filter(l => !l.toLowerCase().includes('wind') && l.trim());
              
              html += `
                <div class="ec-forecast-card">
                  <div class="ec-forecast-card-title">Current Forecast</div>
                  <div class="ec-forecast-card-content">
                    <div class="ec-forecast-wind">${windLines.join(' ')}</div>
                    ${weatherLines.length > 0 ? `<div class="ec-forecast-weather">${weatherLines.join(' ')}</div>` : ''}
                  </div>
                </div>
              `;
            }
          }
        });
        
        html += '</div>';
        
        // Add extended forecasts
        if (extendedForecasts.length > 0) {
          html += '<div class="ec-extended-forecasts">';
          extendedForecasts.forEach(ef => {
            html += `
              <div class="ec-extended-day">
                <div class="ec-extended-day-name">${ef.day}</div>
                <div class="ec-extended-day-forecast">${ef.forecast}</div>
              </div>
            `;
          });
          html += '</div>';
        }
        
        container.innerHTML = html;
        issuedEl.textContent = issuedTime ? `Issued: ${issuedTime}` : '';
        
      } catch (e) {
        console.warn('EC Marine RSS fetch failed:', e);
        // Fallback to showing a link
        container.innerHTML = `
          <div class="ec-forecast-grid">
            <div class="ec-forecast-card">
              <div class="ec-forecast-card-title">Strait of Georgia ‚Äî South of Nanaimo</div>
              <div class="ec-forecast-card-content">
                <p style="margin-bottom: 0.75rem;">Unable to load live forecast. This may be due to CORS restrictions.</p>
                <p><a href="https://weather.gc.ca/marine/forecast_e.html?mapID=02&siteID=14305" target="_blank" style="color: var(--teal-accent);">View Official EC Marine Forecast ‚Üí</a></p>
              </div>
            </div>
          </div>
        `;
        issuedEl.textContent = '';
      }
    }

    // Environment Canada SWOB (Surface Weather Observation) API for real station data
    // Using Vancouver Int'l Airport (CYVR) - the most complete local weather station
    const EC_STATION = 'CYVR';
    const EC_STATION_NAME = "Vancouver Int'l Airport (YVR)";
    
    async function fetchECWeatherData() {
      // Fetch current conditions from Environment Canada SWOB API
      const swobUrl = `https://api.weather.gc.ca/collections/swob-realtime/items?f=json&limit=1&sortby=-date_tm-value&url=${EC_STATION}`;
      
      try {
        const res = await fetch(swobUrl);
        if (!res.ok) throw new Error(`EC API returned ${res.status}`);
        const data = await res.json();
        
        if (data.features && data.features.length > 0) {
          const props = data.features[0].properties;
          return {
            source: 'Environment Canada',
            station: EC_STATION_NAME,
            stationId: EC_STATION,
            current: {
              temperature_2m: parseFloat(props['air_temp-value']) || null,
              relative_humidity_2m: parseFloat(props['rel_hum-value']) || null,
              wind_speed_10m: parseFloat(props['avg_wnd_spd_10m_pst10mts-value']) || parseFloat(props['avg_wnd_spd_10m_mt58-pst10mts-value']) || null, // m/s
              wind_direction_10m: parseFloat(props['avg_wnd_dir_10m_pst10mts-value']) || parseFloat(props['avg_wnd_dir_10m_mt58-pst10mts-value']) || null,
              wind_gusts_10m: parseFloat(props['max_wnd_spd_10m_pst10mts-value']) || null, // m/s
              pressure_msl: parseFloat(props['mslp-value']) / 10 || null, // Convert to hPa
              visibility: parseFloat(props['vis-value']) || null,
              weather_code: 0, // EC doesn't use WMO codes directly
              cloud_cover: null,
              apparent_temperature: null,
              observation_time: props['date_tm-value']
            }
          };
        }
        throw new Error('No data in EC response');
      } catch (e) {
        console.warn('EC API failed, falling back to Open-Meteo:', e);
        return null;
      }
    }
    
    async function fetchOpenMeteoData() {
      const url = `https://api.open-meteo.com/v1/forecast?latitude=${CONFIG.lat}&longitude=${CONFIG.lon}&current=temperature_2m,relative_humidity_2m,apparent_temperature,weather_code,cloud_cover,pressure_msl,wind_speed_10m,wind_direction_10m,wind_gusts_10m&hourly=temperature_2m,weather_code,wind_speed_10m,wind_direction_10m,wind_gusts_10m,precipitation&daily=weather_code,temperature_2m_max,temperature_2m_min,wind_speed_10m_max,wind_gusts_10m_max,precipitation_sum&timezone=America/Vancouver&forecast_days=7`;
      const res = await fetch(url);
      if (!res.ok) throw new Error(`Open-Meteo API returned ${res.status}`);
      const data = await res.json();
      return {
        source: 'Open-Meteo',
        station: 'Model Data (49.30¬∞N, 123.11¬∞W)',
        ...data
      };
    }
    
    async function fetchWeatherData() {
      // Try Environment Canada first for current conditions, then Open-Meteo for forecasts
      const [ecData, omData] = await Promise.all([
        fetchECWeatherData().catch(() => null),
        fetchOpenMeteoData()
      ]);
      
      // Combine: EC for current if available, Open-Meteo for forecasts
      if (ecData && ecData.current && ecData.current.temperature_2m !== null) {
        return {
          source: 'Environment Canada',
          station: ecData.station,
          current: {
            ...omData.current,
            ...ecData.current,
            // Keep wind in m/s for conversion (EC already provides m/s)
            wind_speed_10m: ecData.current.wind_speed_10m || omData.current.wind_speed_10m,
            wind_gusts_10m: ecData.current.wind_gusts_10m || omData.current.wind_gusts_10m,
            wind_direction_10m: ecData.current.wind_direction_10m || omData.current.wind_direction_10m,
            temperature_2m: ecData.current.temperature_2m,
            relative_humidity_2m: ecData.current.relative_humidity_2m || omData.current.relative_humidity_2m,
            pressure_msl: ecData.current.pressure_msl || omData.current.pressure_msl,
            weather_code: omData.current.weather_code, // Use Open-Meteo for conditions text
            cloud_cover: omData.current.cloud_cover,
            apparent_temperature: omData.current.apparent_temperature
          },
          hourly: omData.hourly,
          daily: omData.daily,
          hourly_units: omData.hourly_units
        };
      }
      
      // Fallback to Open-Meteo only
      return omData;
    }

    // XTide reference data for Second Narrows (Vancouver) tides - January 2026
    // Heights in feet, times in PST
    const SECOND_NARROWS_TIDE_DATA = {
      '2026-01-27': [
        { time: '01:36', height: 12.7, type: 'high' },
        { time: '05:14', height: 11.8, type: 'low' },
        { time: '10:53', height: 15.1, type: 'high' },
        { time: '19:02', height: 3.1, type: 'low' }
      ],
      '2026-01-28': [
        { time: '03:07', height: 13.9, type: 'high' },
        { time: '06:58', height: 12.9, type: 'low' },
        { time: '11:41', height: 14.8, type: 'high' },
        { time: '20:02', height: 2.3, type: 'low' }
      ],
      '2026-01-29': [
        { time: '04:07', height: 14.9, type: 'high' },
        { time: '08:39', height: 13.1, type: 'low' },
        { time: '12:44', height: 14.6, type: 'high' },
        { time: '21:02', height: 1.7, type: 'low' }
      ],
      '2026-01-30': [
        { time: '04:54', height: 15.5, type: 'high' },
        { time: '09:57', height: 12.7, type: 'low' },
        { time: '13:57', height: 14.5, type: 'high' },
        { time: '21:58', height: 1.1, type: 'low' }
      ],
      '2026-01-31': [
        { time: '05:35', height: 15.9, type: 'high' },
        { time: '10:55', height: 12.1, type: 'low' },
        { time: '15:07', height: 14.5, type: 'high' },
        { time: '22:49', height: 0.9, type: 'low' }
      ],
      '2026-02-01': [
        { time: '06:12', height: 16.1, type: 'high' },
        { time: '11:43', height: 11.5, type: 'low' },
        { time: '16:10', height: 14.6, type: 'high' },
        { time: '23:34', height: 1.0, type: 'low' }
      ],
      '2026-02-02': [
        { time: '06:46', height: 16.2, type: 'high' },
        { time: '12:24', height: 10.9, type: 'low' },
        { time: '17:07', height: 14.7, type: 'high' }
      ]
    };

    // Steveston tides - typically ~30 min later and slightly lower amplitude
    const STEVESTON_TIDE_DATA = {
      '2026-01-27': [
        { time: '02:06', height: 12.2, type: 'high' },
        { time: '05:44', height: 11.3, type: 'low' },
        { time: '11:23', height: 14.6, type: 'high' },
        { time: '19:32', height: 3.4, type: 'low' }
      ],
      '2026-01-28': [
        { time: '03:37', height: 13.4, type: 'high' },
        { time: '07:28', height: 12.4, type: 'low' },
        { time: '12:11', height: 14.3, type: 'high' },
        { time: '20:32', height: 2.6, type: 'low' }
      ],
      '2026-01-29': [
        { time: '04:37', height: 14.4, type: 'high' },
        { time: '09:09', height: 12.6, type: 'low' },
        { time: '13:14', height: 14.1, type: 'high' },
        { time: '21:32', height: 2.0, type: 'low' }
      ],
      '2026-01-30': [
        { time: '05:24', height: 15.0, type: 'high' },
        { time: '10:27', height: 12.2, type: 'low' },
        { time: '14:27', height: 14.0, type: 'high' },
        { time: '22:28', height: 1.4, type: 'low' }
      ],
      '2026-01-31': [
        { time: '06:05', height: 15.4, type: 'high' },
        { time: '11:25', height: 11.6, type: 'low' },
        { time: '15:37', height: 14.0, type: 'high' },
        { time: '23:19', height: 1.2, type: 'low' }
      ],
      '2026-02-01': [
        { time: '06:42', height: 15.6, type: 'high' },
        { time: '12:13', height: 11.0, type: 'low' },
        { time: '16:40', height: 14.1, type: 'high' }
      ],
      '2026-02-02': [
        { time: '00:04', height: 1.3, type: 'low' },
        { time: '07:16', height: 15.7, type: 'high' },
        { time: '12:54', height: 10.4, type: 'low' },
        { time: '17:37', height: 14.2, type: 'high' }
      ]
    };

    // Fraser River South Arm water levels at km 20 (based on Avadepth patterns)
    // Heights in meters, referenced to Chart Datum (Local Low Water)
    // River discharge at Hope: ~600 m¬≥/s (winter low flow)
    const FRASER_SOUTH_ARM_DATA = {
      '2026-01-27': [
        { time: '00:00', level: 1.9, velocity: -0.3 },
        { time: '01:00', level: 2.3, velocity: -0.2 },
        { time: '02:00', level: 2.6, velocity: -0.1 },
        { time: '03:00', level: 2.6, velocity: 0.0 },
        { time: '04:00', level: 2.5, velocity: 0.1 },
        { time: '05:00', level: 2.3, velocity: 0.2 },
        { time: '06:00', level: 2.2, velocity: 0.3 },
        { time: '07:00', level: 2.2, velocity: 0.3 },
        { time: '08:00', level: 2.3, velocity: 0.2 },
        { time: '09:00', level: 2.5, velocity: 0.1 },
        { time: '10:00', level: 2.8, velocity: -0.1 },
        { time: '11:00', level: 3.0, velocity: -0.2 },
        { time: '12:00', level: 3.1, velocity: -0.3 },
        { time: '13:00', level: 3.1, velocity: -0.3 },
        { time: '14:00', level: 2.8, velocity: -0.2 },
        { time: '15:00', level: 2.3, velocity: 0.0 },
        { time: '16:00', level: 1.8, velocity: 0.3 },
        { time: '17:00', level: 1.4, velocity: 0.5 },
        { time: '18:00', level: 1.0, velocity: 0.6 },
        { time: '19:00', level: 0.7, velocity: 0.6 },
        { time: '20:00', level: 0.4, velocity: 0.5 },
        { time: '21:00', level: 0.3, velocity: 0.4 },
        { time: '22:00', level: 0.3, velocity: 0.3 },
        { time: '23:00', level: 0.6, velocity: 0.1 }
      ],
      '2026-01-28': [
        { time: '00:00', level: 1.9, velocity: -0.3 },
        { time: '01:00', level: 2.3, velocity: -0.2 },
        { time: '02:00', level: 2.6, velocity: -0.1 },
        { time: '03:00', level: 2.6, velocity: 0.0 },
        { time: '04:00', level: 2.5, velocity: 0.1 },
        { time: '05:00', level: 2.3, velocity: 0.2 },
        { time: '06:00', level: 2.2, velocity: 0.3 },
        { time: '07:00', level: 2.2, velocity: 0.3 },
        { time: '08:00', level: 2.3, velocity: 0.2 },
        { time: '09:00', level: 2.5, velocity: 0.1 },
        { time: '10:00', level: 2.8, velocity: -0.1 },
        { time: '11:00', level: 3.0, velocity: -0.2 },
        { time: '12:00', level: 3.1, velocity: -0.3 },
        { time: '13:00', level: 3.1, velocity: -0.3 },
        { time: '14:00', level: 2.7, velocity: -0.1 },
        { time: '15:00', level: 2.3, velocity: 0.1 },
        { time: '16:00', level: 1.8, velocity: 0.3 },
        { time: '17:00', level: 1.4, velocity: 0.5 },
        { time: '18:00', level: 1.0, velocity: 0.6 },
        { time: '19:00', level: 0.7, velocity: 0.5 },
        { time: '20:00', level: 0.4, velocity: 0.4 },
        { time: '21:00', level: 0.3, velocity: 0.3 },
        { time: '22:00', level: 0.3, velocity: 0.2 },
        { time: '23:00', level: 0.6, velocity: 0.0 }
      ],
      '2026-01-29': [
        { time: '00:00', level: 1.2, velocity: -0.2 },
        { time: '01:00', level: 1.7, velocity: -0.3 },
        { time: '02:00', level: 2.1, velocity: -0.2 },
        { time: '03:00', level: 2.3, velocity: -0.1 },
        { time: '04:00', level: 2.4, velocity: 0.0 },
        { time: '05:00', level: 2.3, velocity: 0.1 },
        { time: '06:00', level: 2.1, velocity: 0.2 },
        { time: '07:00', level: 2.0, velocity: 0.3 },
        { time: '08:00', level: 2.0, velocity: 0.3 },
        { time: '09:00', level: 2.2, velocity: 0.2 },
        { time: '10:00', level: 2.5, velocity: 0.0 },
        { time: '11:00', level: 2.8, velocity: -0.2 },
        { time: '12:00', level: 3.0, velocity: -0.3 },
        { time: '13:00', level: 3.0, velocity: -0.3 },
        { time: '14:00', level: 2.7, velocity: -0.2 },
        { time: '15:00', level: 2.3, velocity: 0.0 },
        { time: '16:00', level: 1.8, velocity: 0.3 },
        { time: '17:00', level: 1.4, velocity: 0.5 },
        { time: '18:00', level: 1.0, velocity: 0.6 },
        { time: '19:00', level: 0.8, velocity: 0.5 },
        { time: '20:00', level: 0.5, velocity: 0.4 },
        { time: '21:00', level: 0.4, velocity: 0.3 },
        { time: '22:00', level: 0.3, velocity: 0.2 },
        { time: '23:00', level: 0.3, velocity: 0.1 }
      ],
      '2026-01-30': [
        { time: '00:00', level: 0.6, velocity: -0.1 },
        { time: '01:00', level: 1.1, velocity: -0.2 },
        { time: '02:00', level: 1.7, velocity: -0.3 },
        { time: '03:00', level: 2.2, velocity: -0.2 },
        { time: '04:00', level: 2.4, velocity: -0.1 },
        { time: '05:00', level: 2.4, velocity: 0.0 },
        { time: '06:00', level: 2.2, velocity: 0.1 },
        { time: '07:00', level: 2.0, velocity: 0.2 },
        { time: '08:00', level: 1.9, velocity: 0.3 },
        { time: '09:00', level: 1.9, velocity: 0.3 },
        { time: '10:00', level: 2.2, velocity: 0.1 },
        { time: '11:00', level: 2.5, velocity: -0.1 },
        { time: '12:00', level: 2.8, velocity: -0.2 },
        { time: '13:00', level: 2.9, velocity: -0.3 },
        { time: '14:00', level: 2.7, velocity: -0.2 },
        { time: '15:00', level: 2.3, velocity: 0.0 },
        { time: '16:00', level: 1.8, velocity: 0.3 },
        { time: '17:00', level: 1.3, velocity: 0.5 },
        { time: '18:00', level: 1.0, velocity: 0.6 },
        { time: '19:00', level: 0.8, velocity: 0.5 },
        { time: '20:00', level: 0.6, velocity: 0.4 },
        { time: '21:00', level: 0.4, velocity: 0.3 },
        { time: '22:00', level: 0.3, velocity: 0.2 },
        { time: '23:00', level: 0.2, velocity: 0.1 }
      ],
      '2026-01-31': [
        { time: '00:00', level: 0.3, velocity: 0.0 },
        { time: '01:00', level: 0.6, velocity: -0.1 },
        { time: '02:00', level: 1.2, velocity: -0.2 },
        { time: '03:00', level: 1.8, velocity: -0.3 },
        { time: '04:00', level: 2.2, velocity: -0.2 },
        { time: '05:00', level: 2.4, velocity: -0.1 },
        { time: '06:00', level: 2.3, velocity: 0.0 },
        { time: '07:00', level: 2.1, velocity: 0.1 },
        { time: '08:00', level: 1.9, velocity: 0.2 },
        { time: '09:00', level: 1.7, velocity: 0.3 },
        { time: '10:00', level: 1.9, velocity: 0.2 },
        { time: '11:00', level: 2.1, velocity: 0.0 },
        { time: '12:00', level: 2.5, velocity: -0.2 },
        { time: '13:00', level: 2.8, velocity: -0.3 },
        { time: '14:00', level: 2.8, velocity: -0.2 },
        { time: '15:00', level: 2.5, velocity: -0.1 },
        { time: '16:00', level: 2.0, velocity: 0.2 },
        { time: '17:00', level: 1.4, velocity: 0.4 },
        { time: '18:00', level: 1.0, velocity: 0.5 },
        { time: '19:00', level: 0.8, velocity: 0.5 },
        { time: '20:00', level: 0.6, velocity: 0.4 },
        { time: '21:00', level: 0.4, velocity: 0.3 },
        { time: '22:00', level: 0.2, velocity: 0.1 },
        { time: '23:00', level: 0.1, velocity: 0.0 }
      ],
      '2026-02-01': [
        { time: '00:00', level: 0.2, velocity: -0.1 },
        { time: '01:00', level: 0.4, velocity: -0.1 },
        { time: '02:00', level: 0.9, velocity: -0.2 },
        { time: '03:00', level: 1.4, velocity: -0.3 },
        { time: '04:00', level: 1.9, velocity: -0.2 },
        { time: '05:00', level: 2.2, velocity: -0.1 },
        { time: '06:00', level: 2.3, velocity: 0.0 },
        { time: '07:00', level: 2.2, velocity: 0.1 },
        { time: '08:00', level: 1.9, velocity: 0.2 },
        { time: '09:00', level: 1.7, velocity: 0.3 },
        { time: '10:00', level: 1.6, velocity: 0.3 },
        { time: '11:00', level: 1.8, velocity: 0.1 },
        { time: '12:00', level: 2.1, velocity: -0.1 },
        { time: '13:00', level: 2.5, velocity: -0.2 },
        { time: '14:00', level: 2.7, velocity: -0.3 },
        { time: '15:00', level: 2.6, velocity: -0.2 },
        { time: '16:00', level: 2.2, velocity: 0.0 },
        { time: '17:00', level: 1.6, velocity: 0.3 },
        { time: '18:00', level: 1.1, velocity: 0.5 },
        { time: '19:00', level: 0.8, velocity: 0.5 },
        { time: '20:00', level: 0.6, velocity: 0.4 },
        { time: '21:00', level: 0.4, velocity: 0.3 },
        { time: '22:00', level: 0.2, velocity: 0.1 },
        { time: '23:00', level: 0.1, velocity: 0.0 }
      ]
    };

    // Fraser River North Arm at km 20 (slightly different pattern - lower amplitude)
    const FRASER_NORTH_ARM_DATA = {
      '2026-01-27': [
        { time: '00:00', level: 1.7, velocity: -0.2 },
        { time: '01:00', level: 2.0, velocity: -0.2 },
        { time: '02:00', level: 2.3, velocity: -0.1 },
        { time: '03:00', level: 2.4, velocity: 0.0 },
        { time: '04:00', level: 2.3, velocity: 0.1 },
        { time: '05:00', level: 2.1, velocity: 0.2 },
        { time: '06:00', level: 2.0, velocity: 0.2 },
        { time: '07:00', level: 2.0, velocity: 0.2 },
        { time: '08:00', level: 2.1, velocity: 0.1 },
        { time: '09:00', level: 2.3, velocity: 0.0 },
        { time: '10:00', level: 2.5, velocity: -0.1 },
        { time: '11:00', level: 2.7, velocity: -0.2 },
        { time: '12:00', level: 2.8, velocity: -0.2 },
        { time: '13:00', level: 2.8, velocity: -0.2 },
        { time: '14:00', level: 2.5, velocity: -0.1 },
        { time: '15:00', level: 2.1, velocity: 0.1 },
        { time: '16:00', level: 1.7, velocity: 0.2 },
        { time: '17:00', level: 1.3, velocity: 0.4 },
        { time: '18:00', level: 1.0, velocity: 0.5 },
        { time: '19:00', level: 0.8, velocity: 0.4 },
        { time: '20:00', level: 0.6, velocity: 0.3 },
        { time: '21:00', level: 0.5, velocity: 0.2 },
        { time: '22:00', level: 0.5, velocity: 0.1 },
        { time: '23:00', level: 0.7, velocity: 0.0 }
      ],
      '2026-01-28': [
        { time: '00:00', level: 1.7, velocity: -0.2 },
        { time: '01:00', level: 2.0, velocity: -0.2 },
        { time: '02:00', level: 2.3, velocity: -0.1 },
        { time: '03:00', level: 2.4, velocity: 0.0 },
        { time: '04:00', level: 2.3, velocity: 0.1 },
        { time: '05:00', level: 2.1, velocity: 0.2 },
        { time: '06:00', level: 2.0, velocity: 0.2 },
        { time: '07:00', level: 2.0, velocity: 0.2 },
        { time: '08:00', level: 2.1, velocity: 0.1 },
        { time: '09:00', level: 2.3, velocity: 0.0 },
        { time: '10:00', level: 2.5, velocity: -0.1 },
        { time: '11:00', level: 2.7, velocity: -0.2 },
        { time: '12:00', level: 2.8, velocity: -0.2 },
        { time: '13:00', level: 2.8, velocity: -0.2 },
        { time: '14:00', level: 2.5, velocity: -0.1 },
        { time: '15:00', level: 2.1, velocity: 0.1 },
        { time: '16:00', level: 1.7, velocity: 0.2 },
        { time: '17:00', level: 1.3, velocity: 0.4 },
        { time: '18:00', level: 1.0, velocity: 0.5 },
        { time: '19:00', level: 0.8, velocity: 0.4 },
        { time: '20:00', level: 0.6, velocity: 0.3 },
        { time: '21:00', level: 0.5, velocity: 0.2 },
        { time: '22:00', level: 0.5, velocity: 0.1 },
        { time: '23:00', level: 0.7, velocity: 0.0 }
      ],
      '2026-01-29': [
        { time: '00:00', level: 1.1, velocity: -0.1 },
        { time: '01:00', level: 1.5, velocity: -0.2 },
        { time: '02:00', level: 1.9, velocity: -0.2 },
        { time: '03:00', level: 2.1, velocity: -0.1 },
        { time: '04:00', level: 2.2, velocity: 0.0 },
        { time: '05:00', level: 2.1, velocity: 0.1 },
        { time: '06:00', level: 1.9, velocity: 0.2 },
        { time: '07:00', level: 1.8, velocity: 0.2 },
        { time: '08:00', level: 1.8, velocity: 0.2 },
        { time: '09:00', level: 2.0, velocity: 0.1 },
        { time: '10:00', level: 2.3, velocity: 0.0 },
        { time: '11:00', level: 2.5, velocity: -0.1 },
        { time: '12:00', level: 2.7, velocity: -0.2 },
        { time: '13:00', level: 2.7, velocity: -0.2 },
        { time: '14:00', level: 2.5, velocity: -0.1 },
        { time: '15:00', level: 2.1, velocity: 0.1 },
        { time: '16:00', level: 1.7, velocity: 0.2 },
        { time: '17:00', level: 1.3, velocity: 0.4 },
        { time: '18:00', level: 1.0, velocity: 0.4 },
        { time: '19:00', level: 0.8, velocity: 0.4 },
        { time: '20:00', level: 0.6, velocity: 0.3 },
        { time: '21:00', level: 0.5, velocity: 0.2 },
        { time: '22:00', level: 0.5, velocity: 0.1 },
        { time: '23:00', level: 0.5, velocity: 0.0 }
      ],
      '2026-01-30': [
        { time: '00:00', level: 0.7, velocity: -0.1 },
        { time: '01:00', level: 1.0, velocity: -0.2 },
        { time: '02:00', level: 1.5, velocity: -0.2 },
        { time: '03:00', level: 1.9, velocity: -0.2 },
        { time: '04:00', level: 2.2, velocity: -0.1 },
        { time: '05:00', level: 2.2, velocity: 0.0 },
        { time: '06:00', level: 2.0, velocity: 0.1 },
        { time: '07:00', level: 1.8, velocity: 0.2 },
        { time: '08:00', level: 1.7, velocity: 0.2 },
        { time: '09:00', level: 1.8, velocity: 0.2 },
        { time: '10:00', level: 2.0, velocity: 0.1 },
        { time: '11:00', level: 2.3, velocity: 0.0 },
        { time: '12:00', level: 2.5, velocity: -0.2 },
        { time: '13:00', level: 2.6, velocity: -0.2 },
        { time: '14:00', level: 2.5, velocity: -0.1 },
        { time: '15:00', level: 2.1, velocity: 0.1 },
        { time: '16:00', level: 1.7, velocity: 0.2 },
        { time: '17:00', level: 1.2, velocity: 0.4 },
        { time: '18:00', level: 0.9, velocity: 0.4 },
        { time: '19:00', level: 0.8, velocity: 0.4 },
        { time: '20:00', level: 0.6, velocity: 0.3 },
        { time: '21:00', level: 0.5, velocity: 0.2 },
        { time: '22:00', level: 0.4, velocity: 0.1 },
        { time: '23:00', level: 0.4, velocity: 0.0 }
      ],
      '2026-01-31': [
        { time: '00:00', level: 0.5, velocity: -0.1 },
        { time: '01:00', level: 0.7, velocity: -0.1 },
        { time: '02:00', level: 1.1, velocity: -0.2 },
        { time: '03:00', level: 1.6, velocity: -0.2 },
        { time: '04:00', level: 2.0, velocity: -0.1 },
        { time: '05:00', level: 2.2, velocity: 0.0 },
        { time: '06:00', level: 2.1, velocity: 0.1 },
        { time: '07:00', level: 1.9, velocity: 0.1 },
        { time: '08:00', level: 1.7, velocity: 0.2 },
        { time: '09:00', level: 1.6, velocity: 0.2 },
        { time: '10:00', level: 1.7, velocity: 0.1 },
        { time: '11:00', level: 1.9, velocity: 0.0 },
        { time: '12:00', level: 2.2, velocity: -0.1 },
        { time: '13:00', level: 2.5, velocity: -0.2 },
        { time: '14:00', level: 2.5, velocity: -0.2 },
        { time: '15:00', level: 2.3, velocity: -0.1 },
        { time: '16:00', level: 1.9, velocity: 0.1 },
        { time: '17:00', level: 1.3, velocity: 0.3 },
        { time: '18:00', level: 1.0, velocity: 0.4 },
        { time: '19:00', level: 0.8, velocity: 0.4 },
        { time: '20:00', level: 0.6, velocity: 0.3 },
        { time: '21:00', level: 0.5, velocity: 0.2 },
        { time: '22:00', level: 0.4, velocity: 0.1 },
        { time: '23:00', level: 0.3, velocity: 0.0 }
      ],
      '2026-02-01': [
        { time: '00:00', level: 0.4, velocity: -0.1 },
        { time: '01:00', level: 0.5, velocity: -0.1 },
        { time: '02:00', level: 0.9, velocity: -0.2 },
        { time: '03:00', level: 1.3, velocity: -0.2 },
        { time: '04:00', level: 1.7, velocity: -0.2 },
        { time: '05:00', level: 2.0, velocity: -0.1 },
        { time: '06:00', level: 2.1, velocity: 0.0 },
        { time: '07:00', level: 2.0, velocity: 0.1 },
        { time: '08:00', level: 1.8, velocity: 0.2 },
        { time: '09:00', level: 1.6, velocity: 0.2 },
        { time: '10:00', level: 1.5, velocity: 0.2 },
        { time: '11:00', level: 1.6, velocity: 0.1 },
        { time: '12:00', level: 1.9, velocity: 0.0 },
        { time: '13:00', level: 2.2, velocity: -0.1 },
        { time: '14:00', level: 2.4, velocity: -0.2 },
        { time: '15:00', level: 2.4, velocity: -0.1 },
        { time: '16:00', level: 2.0, velocity: 0.1 },
        { time: '17:00', level: 1.5, velocity: 0.3 },
        { time: '18:00', level: 1.1, velocity: 0.4 },
        { time: '19:00', level: 0.8, velocity: 0.4 },
        { time: '20:00', level: 0.6, velocity: 0.3 },
        { time: '21:00', level: 0.5, velocity: 0.2 },
        { time: '22:00', level: 0.4, velocity: 0.1 },
        { time: '23:00', level: 0.3, velocity: 0.0 }
      ]
    };

    function getTidesForStation(stationData) {
      const now = new Date();
      const tides = [];
      
      // Get today and next few days
      for (let d = 0; d < 4; d++) {
        const date = new Date(now);
        date.setDate(date.getDate() + d);
        const dateStr = getLocalDateString(date);
        
        if (stationData[dateStr]) {
          stationData[dateStr].forEach(tide => {
            const [hours, mins] = tide.time.split(':').map(Number);
            const tideTime = new Date(date);
            tideTime.setHours(hours, mins, 0, 0);
            
            tides.push({
              time: tideTime,
              heightFt: tide.height,
              heightM: (tide.height * 0.3048).toFixed(2),
              type: tide.type
            });
          });
        }
      }
      
      // Sort by time and filter to events from 1 hour ago onwards (to show current context)
      return tides.sort((a, b) => a.time - b.time).filter(t => t.time >= new Date(now.getTime() - 3600000)).slice(0, 12);
    }

    function generateTideCurve(stationData, hoursSpan = 72) {
      const now = new Date();
      const startTime = new Date(now.getTime() - 2 * 3600000); // Start 2 hours ago
      const endTime = new Date(startTime.getTime() + hoursSpan * 3600000);
      const points = [];
      
      // Get all tide events in range - need to cover full span plus buffer
      const tides = [];
      for (let d = -1; d < 5; d++) {
        const date = new Date(now);
        date.setDate(date.getDate() + d);
        const dateStr = getLocalDateString(date);
        
        if (stationData[dateStr]) {
          stationData[dateStr].forEach(tide => {
            const [hours, mins] = tide.time.split(':').map(Number);
            const tideTime = new Date(date);
            tideTime.setHours(hours, mins, 0, 0);
            tides.push({ time: tideTime, height: tide.height, type: tide.type });
          });
        }
      }
      
      // If no tide data found, return empty
      if (tides.length === 0) {
        return { points: [], startTime, endTime, now };
      }
      
      tides.sort((a, b) => a.time - b.time);
      
      // Generate curve points using sinusoidal interpolation
      const interval = 15 * 60000; // 15 minutes
      for (let t = startTime.getTime(); t <= endTime.getTime(); t += interval) {
        const currentTime = new Date(t);
        
        // Find surrounding tide events
        let prevTide = null, nextTide = null;
        for (let i = 0; i < tides.length; i++) {
          if (tides[i].time.getTime() <= t) prevTide = tides[i];
          if (tides[i].time.getTime() > t && !nextTide) nextTide = tides[i];
        }
        
        let height = 8; // Default mean level
        if (prevTide && nextTide) {
          const totalTime = nextTide.time.getTime() - prevTide.time.getTime();
          const elapsed = t - prevTide.time.getTime();
          const progress = elapsed / totalTime;
          
          // Cosine interpolation for smooth tide curve
          const cosProgress = (1 - Math.cos(progress * Math.PI)) / 2;
          height = prevTide.height + (nextTide.height - prevTide.height) * cosProgress;
        } else if (prevTide) {
          height = prevTide.height;
        } else if (nextTide) {
          height = nextTide.height;
        }
        
        points.push({
          time: currentTime,
          height: height,
          x: (t - startTime.getTime()) / (endTime.getTime() - startTime.getTime())
        });
      }
      
      return { points, startTime, endTime, now };
    }

    function drawTideGraph(canvasId, markerId, stationData) {
      const canvas = document.getElementById(canvasId);
      const marker = document.getElementById(markerId);
      if (!canvas) return;
      
      const ctx = canvas.getContext('2d');
      const container = canvas.parentElement;
      
      // Use offsetWidth/Height for more reliable sizing
      const width = container.offsetWidth || 800;
      const height = container.offsetHeight || 140;
      
      // Set canvas size with device pixel ratio for sharp rendering
      const dpr = window.devicePixelRatio || 1;
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
      ctx.scale(dpr, dpr);
      
      const curve = generateTideCurve(stationData);
      const points = curve.points;
      
      // If no points, show message
      if (points.length === 0) {
        ctx.fillStyle = 'rgba(200, 200, 200, 0.5)';
        ctx.font = '12px Inter';
        ctx.textAlign = 'center';
        ctx.fillText('No tide data available for this period', width / 2, height / 2);
        return;
      }
      
      // Find min/max heights
      const heights = points.map(p => p.height);
      const minH = Math.min(...heights) - 1;
      const maxH = Math.max(...heights) + 1;
      
      const padding = { top: 20, bottom: 20, left: 35, right: 35 };
      const graphWidth = width - padding.left - padding.right;
      const graphHeight = height - padding.top - padding.bottom;
      
      // Store graph params for mouse interaction
      canvas.graphParams = { curve, points, minH, maxH, padding, graphWidth, graphHeight, width, height, stationData };
      
      // Draw the static graph
      drawStaticGraph(ctx, canvas.graphParams);
      
      // Position NOW marker
      const nowX = padding.left + ((curve.now.getTime() - curve.startTime.getTime()) / (curve.endTime.getTime() - curve.startTime.getTime())) * graphWidth;
      marker.style.left = `${nowX}px`;
      
      // Add mouse event listeners (only once)
      if (!canvas.hasMouseListeners) {
        canvas.hasMouseListeners = true;
        
        canvas.addEventListener('mousemove', (e) => {
          const rect = canvas.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;
          drawGraphWithCrosshairs(canvas, mouseX, mouseY);
        });
        
        canvas.addEventListener('mouseleave', () => {
          // Redraw without crosshairs
          const ctx = canvas.getContext('2d');
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          const dpr = window.devicePixelRatio || 1;
          ctx.scale(dpr, dpr);
          drawStaticGraph(ctx, canvas.graphParams);
        });
      }
    }
    
    function drawStaticGraph(ctx, params) {
      const { curve, points, minH, maxH, padding, graphWidth, graphHeight, width, height, stationData } = params;
      
      // Clear canvas
      ctx.clearRect(0, 0, width, height);
      
      // Draw grid lines
      ctx.strokeStyle = 'rgba(0, 212, 170, 0.15)';
      ctx.lineWidth = 1;
      
      // Horizontal grid (height levels) - show both feet and meters
      for (let h = Math.ceil(minH); h <= Math.floor(maxH); h += 2) {
        const y = padding.top + graphHeight * (1 - (h - minH) / (maxH - minH));
        ctx.beginPath();
        ctx.moveTo(padding.left, y);
        ctx.lineTo(width - padding.right, y);
        ctx.stroke();
        
        // Height labels - feet on left
        ctx.fillStyle = 'rgba(200, 200, 200, 0.6)';
        ctx.font = '9px Inter';
        ctx.textAlign = 'right';
        ctx.fillText(`${h}ft`, padding.left - 4, y + 3);
        
        // Height labels - meters on right
        const meters = (h * 0.3048).toFixed(1);
        ctx.textAlign = 'left';
        ctx.fillText(`${meters}m`, width - padding.right + 4, y + 3);
      }
      
      // Draw time labels - show day markers for 3-day view
      ctx.fillStyle = 'rgba(200, 200, 200, 0.6)';
      ctx.font = '9px Inter';
      ctx.textAlign = 'center';
      
      // Draw vertical day separator lines and labels
      for (let h = 0; h <= 72; h += 12) {
        const x = padding.left + (h / 72) * graphWidth;
        const labelTime = new Date(curve.startTime.getTime() + h * 3600000);
        
        // Draw subtle vertical grid line at midnight
        if (labelTime.getHours() === 0 || h === 0) {
          ctx.strokeStyle = 'rgba(0, 212, 170, 0.2)';
          ctx.beginPath();
          ctx.moveTo(x, padding.top);
          ctx.lineTo(x, height - padding.bottom);
          ctx.stroke();
        }
        
        // Show day name at midnight, time otherwise
        if (labelTime.getHours() === 0) {
          ctx.fillText(formatDay(labelTime), x, height - 5);
        } else if (h % 24 === 12) {
          ctx.fillText('12:00', x, height - 5);
        }
      }
      
      // Draw tide curve - gradient fill
      ctx.beginPath();
      ctx.moveTo(padding.left, height - padding.bottom);
      
      points.forEach((p, i) => {
        const x = padding.left + p.x * graphWidth;
        const y = padding.top + graphHeight * (1 - (p.height - minH) / (maxH - minH));
        if (i === 0) ctx.lineTo(x, y);
        else ctx.lineTo(x, y);
      });
      
      ctx.lineTo(padding.left + graphWidth, height - padding.bottom);
      ctx.closePath();
      
      const gradient = ctx.createLinearGradient(0, padding.top, 0, height - padding.bottom);
      gradient.addColorStop(0, 'rgba(0, 212, 170, 0.4)');
      gradient.addColorStop(1, 'rgba(0, 212, 170, 0.05)');
      ctx.fillStyle = gradient;
      ctx.fill();
      
      // Draw tide curve line
      ctx.beginPath();
      points.forEach((p, i) => {
        const x = padding.left + p.x * graphWidth;
        const y = padding.top + graphHeight * (1 - (p.height - minH) / (maxH - minH));
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.strokeStyle = 'rgba(0, 212, 170, 0.9)';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Draw high/low tide markers on the curve
      drawTideMarkers(ctx, params);
    }
    
    function drawTideMarkers(ctx, params) {
      const { curve, minH, maxH, padding, graphWidth, graphHeight, stationData } = params;
      
      const tideEvents = [];
      for (let d = -1; d < 5; d++) {
        const date = new Date(curve.now);
        date.setDate(date.getDate() + d);
        const dateStr = getLocalDateString(date);
        
        if (stationData[dateStr]) {
          stationData[dateStr].forEach(tide => {
            const [hours, mins] = tide.time.split(':').map(Number);
            const tideTime = new Date(date);
            tideTime.setHours(hours, mins, 0, 0);
            
            if (tideTime >= curve.startTime && tideTime <= curve.endTime) {
              tideEvents.push({
                time: tideTime,
                height: tide.height,
                type: tide.type
              });
            }
          });
        }
      }
      
      // Draw markers for each tide event
      tideEvents.forEach(tide => {
        const xPos = padding.left + ((tide.time.getTime() - curve.startTime.getTime()) / (curve.endTime.getTime() - curve.startTime.getTime())) * graphWidth;
        const yPos = padding.top + graphHeight * (1 - (tide.height - minH) / (maxH - minH));
        
        // Draw dot
        ctx.beginPath();
        ctx.arc(xPos, yPos, 4, 0, Math.PI * 2);
        ctx.fillStyle = tide.type === 'high' ? 'rgba(0, 212, 170, 1)' : 'rgba(255, 107, 107, 1)';
        ctx.fill();
        
        // Draw label background
        const label = `${tide.type === 'high' ? '‚ñ≤' : '‚ñº'} ${(tide.height * 0.3048).toFixed(1)}m`;
        const timeLabel = formatTime(tide.time);
        ctx.font = 'bold 8px Inter';
        const labelWidth = Math.max(ctx.measureText(label).width, ctx.measureText(timeLabel).width) + 6;
        
        const labelY = tide.type === 'high' ? yPos - 22 : yPos + 8;
        
        ctx.fillStyle = 'rgba(13, 33, 55, 0.9)';
        ctx.fillRect(xPos - labelWidth/2, labelY, labelWidth, 20);
        
        ctx.fillStyle = tide.type === 'high' ? 'rgba(0, 212, 170, 1)' : 'rgba(255, 107, 107, 1)';
        ctx.font = 'bold 8px Inter';
        ctx.textAlign = 'center';
        ctx.fillText(label, xPos, labelY + 9);
        ctx.fillStyle = 'rgba(200, 200, 200, 0.8)';
        ctx.font = '7px Inter';
        ctx.fillText(timeLabel, xPos, labelY + 17);
      });
    }
    
    function drawGraphWithCrosshairs(canvas, mouseX, mouseY) {
      const ctx = canvas.getContext('2d');
      const params = canvas.graphParams;
      if (!params) return;
      
      const { curve, points, minH, maxH, padding, graphWidth, graphHeight, width, height } = params;
      
      // Reset transform and redraw base graph
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      const dpr = window.devicePixelRatio || 1;
      ctx.scale(dpr, dpr);
      drawStaticGraph(ctx, params);
      
      // Check if mouse is in graph area
      if (mouseX < padding.left || mouseX > width - padding.right || 
          mouseY < padding.top || mouseY > height - padding.bottom) {
        return;
      }
      
      // Calculate time and height at mouse position
      const xRatio = (mouseX - padding.left) / graphWidth;
      const timeAtMouse = new Date(curve.startTime.getTime() + xRatio * (curve.endTime.getTime() - curve.startTime.getTime()));
      
      // Find closest point to get height
      let closestPoint = points[0];
      let minDist = Math.abs(points[0].x - xRatio);
      for (const p of points) {
        const dist = Math.abs(p.x - xRatio);
        if (dist < minDist) {
          minDist = dist;
          closestPoint = p;
        }
      }
      
      const heightAtMouse = closestPoint.height;
      const yAtCurve = padding.top + graphHeight * (1 - (heightAtMouse - minH) / (maxH - minH));
      
      // Draw crosshairs
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
      ctx.lineWidth = 1;
      ctx.setLineDash([5, 5]);
      
      // Vertical line
      ctx.beginPath();
      ctx.moveTo(mouseX, padding.top);
      ctx.lineTo(mouseX, height - padding.bottom);
      ctx.stroke();
      
      // Horizontal line at curve height
      ctx.beginPath();
      ctx.moveTo(padding.left, yAtCurve);
      ctx.lineTo(width - padding.right, yAtCurve);
      ctx.stroke();
      
      ctx.setLineDash([]);
      
      // Draw point on curve
      ctx.beginPath();
      ctx.arc(mouseX, yAtCurve, 6, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(0, 212, 170, 1)';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Draw info tooltip
      const heightM = (heightAtMouse * 0.3048).toFixed(2);
      const heightFt = heightAtMouse.toFixed(1);
      const timeStr = timeAtMouse.toLocaleString('en-CA', { 
        weekday: 'short', 
        month: 'short', 
        day: 'numeric',
        hour: '2-digit', 
        minute: '2-digit',
        hour12: false 
      });
      
      // Tooltip dimensions
      const tooltipWidth = 140;
      const tooltipHeight = 50;
      let tooltipX = mouseX + 15;
      let tooltipY = mouseY - 25;
      
      // Keep tooltip in bounds
      if (tooltipX + tooltipWidth > width - 10) tooltipX = mouseX - tooltipWidth - 15;
      if (tooltipY < 10) tooltipY = 10;
      if (tooltipY + tooltipHeight > height - 10) tooltipY = height - tooltipHeight - 10;
      
      // Draw tooltip background
      ctx.fillStyle = 'rgba(13, 33, 55, 0.95)';
      ctx.strokeStyle = 'rgba(0, 212, 170, 0.5)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.roundRect(tooltipX, tooltipY, tooltipWidth, tooltipHeight, 6);
      ctx.fill();
      ctx.stroke();
      
      // Draw tooltip text
      ctx.fillStyle = 'rgba(200, 200, 200, 0.9)';
      ctx.font = '10px Inter';
      ctx.textAlign = 'left';
      ctx.fillText(timeStr, tooltipX + 8, tooltipY + 16);
      
      ctx.fillStyle = 'rgba(0, 212, 170, 1)';
      ctx.font = 'bold 14px Inter';
      ctx.fillText(`${heightM} m`, tooltipX + 8, tooltipY + 34);
      
      ctx.fillStyle = 'rgba(200, 200, 200, 0.7)';
      ctx.font = '10px Inter';
      ctx.fillText(`(${heightFt} ft)`, tooltipX + 75, tooltipY + 34);
    }

    function buildTideDisplay(tides, containerId) {
      const container = document.getElementById(containerId);
      if (!container) return;
      
      const now = new Date();
      let foundNext = false;
      
      container.innerHTML = tides.map(t => {
        const isNext = !foundNext && t.time > now;
        if (isNext) foundNext = true;
        
        return `
          <div class="tide-event-card ${t.type} ${isNext ? 'next' : ''}">
            <div class="tide-event-time">${formatDay(t.time)} ${formatTime(t.time)}</div>
            <div class="tide-event-type ${t.type}">${t.type === 'high' ? '‚ñ≤ High' : '‚ñº Low'}</div>
            <div class="tide-event-height">${t.heightM} m</div>
            <div class="tide-event-height-ft">${t.heightFt} ft</div>
          </div>
        `;
      }).join('');
    }

    // Current calculations for First and Second Narrows
    // Using XTide reference data for accurate predictions
    
    // Reference data from XTide (dairiki.org) for January-February 2026
    // Format: [dayOfMonth, slackTimes[], maxTimes[], maxSpeeds[]] 
    // Negative speed = Ebb, Positive = Flood
    const FIRST_NARROWS_DATA = {
      '2026-01-27': {
        slacks: ['02:12', '11:16', '19:47'],
        maxes: [
          { time: '03:50', speed: -0.5 },
          { time: '08:46', speed: 1.5 },
          { time: '15:46', speed: -4.3 },
          { time: '23:18', speed: 3.3 }
        ]
      },
      '2026-01-28': {
        slacks: ['03:59', '12:04', '20:49'],
        maxes: [
          { time: '05:33', speed: -0.5 },
          { time: '09:59', speed: 1.0 },
          { time: '16:53', speed: -4.5 },
        ]
      },
      '2026-01-29': {
        slacks: ['05:03', '09:13', '13:08', '21:47'],
        maxes: [
          { time: '00:29', speed: 4.0 },
          { time: '06:57', speed: -0.8 },
          { time: '11:21', speed: 0.8 },
          { time: '18:00', speed: -4.8 }
        ]
      },
      '2026-01-30': {
        slacks: ['05:49', '10:36', '14:21', '22:41'],
        maxes: [
          { time: '01:28', speed: 4.6 },
          { time: '07:59', speed: -1.3 },
          { time: '12:36', speed: 0.9 },
          { time: '19:01', speed: -5.0 }
        ]
      },
      '2026-01-31': {
        slacks: ['06:28', '11:35', '15:33', '23:30'],
        maxes: [
          { time: '02:19', speed: 5.0 },
          { time: '08:48', speed: -1.8 },
          { time: '13:40', speed: 1.2 },
          { time: '19:56', speed: -5.2 }
        ]
      }
    };
    
    const SECOND_NARROWS_DATA = {
      '2026-01-27': {
        slacks: ['01:53', '11:24', '19:35'],
        maxes: [
          { time: '03:42', speed: -0.7 },
          { time: '08:49', speed: 1.6 },
          { time: '15:42', speed: -4.0 },
          { time: '23:06', speed: 3.4 }
        ]
      },
      '2026-01-28': {
        slacks: ['03:36', '12:16', '20:38'],
        maxes: [
          { time: '05:21', speed: -0.7 },
          { time: '10:03', speed: 1.2 },
          { time: '16:50', speed: -4.2 },
        ]
      },
      '2026-01-29': {
        slacks: ['04:43', '09:03', '13:23', '21:37'],
        maxes: [
          { time: '00:17', speed: 4.0 },
          { time: '06:44', speed: -1.0 },
          { time: '11:24', speed: 1.0 },
          { time: '17:56', speed: -4.5 }
        ]
      },
      '2026-01-30': {
        slacks: ['05:32', '10:23', '14:34', '22:31'],
        maxes: [
          { time: '01:17', speed: 4.5 },
          { time: '07:46', speed: -1.5 },
          { time: '12:37', speed: 1.2 },
          { time: '18:57', speed: -4.8 }
        ]
      },
      '2026-01-31': {
        slacks: ['06:13', '11:23', '15:43', '23:21'],
        maxes: [
          { time: '02:08', speed: 5.0 },
          { time: '08:37', speed: -2.0 },
          { time: '13:40', speed: 1.5 },
          { time: '19:52', speed: -4.9 }
        ]
      }
    };

    function parseTimeToday(timeStr, baseDate) {
      const [hours, minutes] = timeStr.split(':').map(Number);
      const result = new Date(baseDate);
      result.setHours(hours, minutes, 0, 0);
      return result;
    }

    function getLocalDateString(date) {
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    }

    function calculateCurrents(stationConfig, referenceData) {
      const now = new Date();
      const today = getLocalDateString(now);
      const tomorrow = new Date(now);
      tomorrow.setDate(tomorrow.getDate() + 1);
      const tomorrowStr = getLocalDateString(tomorrow);
      
      const { maxFlood, maxEbb, floodDir, ebbDir } = stationConfig;
      
      // Check if we have reference data for today
      const todayData = referenceData[today];
      const tomorrowData = referenceData[tomorrowStr];
      
      const events = [];
      const slackWindows = [];
      
      if (todayData) {
        // Parse today's data
        const todayBase = new Date(now);
        todayBase.setHours(0, 0, 0, 0);
        
        // Add slack events
        todayData.slacks.forEach(timeStr => {
          const slackTime = parseTimeToday(timeStr, todayBase);
          if (slackTime > now) {
            // Determine if high or low slack based on surrounding max currents
            const maxBefore = todayData.maxes.filter(m => parseTimeToday(m.time, todayBase) < slackTime).pop();
            const isHighSlack = maxBefore && maxBefore.speed > 0;
            events.push({
              time: slackTime,
              type: isHighSlack ? 'high-slack' : 'low-slack',
              speed: 0
            });
          }
        });
        
        // Add max current events
        todayData.maxes.forEach(max => {
          const maxTime = parseTimeToday(max.time, todayBase);
          if (maxTime > now) {
            events.push({
              time: maxTime,
              type: max.speed > 0 ? 'max-flood' : 'max-ebb',
              speed: Math.abs(max.speed).toFixed(1)
            });
          }
        });
        
        // Add tomorrow's early events if available
        if (tomorrowData) {
          const tomorrowBase = new Date(tomorrow);
          tomorrowBase.setHours(0, 0, 0, 0);
          
          tomorrowData.slacks.slice(0, 2).forEach(timeStr => {
            const slackTime = parseTimeToday(timeStr, tomorrowBase);
            const maxBefore = tomorrowData.maxes.filter(m => parseTimeToday(m.time, tomorrowBase) < slackTime).pop();
            const isHighSlack = maxBefore && maxBefore.speed > 0;
            events.push({
              time: slackTime,
              type: isHighSlack ? 'high-slack' : 'low-slack',
              speed: 0
            });
          });
          
          tomorrowData.maxes.slice(0, 2).forEach(max => {
            const maxTime = parseTimeToday(max.time, tomorrowBase);
            events.push({
              time: maxTime,
              type: max.speed > 0 ? 'max-flood' : 'max-ebb',
              speed: Math.abs(max.speed).toFixed(1)
            });
          });
        }
        
        // Sort events by time
        events.sort((a, b) => a.time - b.time);
        
        // Calculate current state based on surrounding events
        const pastMaxes = todayData.maxes
          .map(m => ({ ...m, time: parseTimeToday(m.time, todayBase) }))
          .filter(m => m.time <= now);
        const futureMaxes = todayData.maxes
          .map(m => ({ ...m, time: parseTimeToday(m.time, todayBase) }))
          .filter(m => m.time > now);
        
        let currentSpeed = 0;
        let isFlood = false;
        let isEbb = false;
        let inOneKnotWindow = false;
        
        if (pastMaxes.length > 0 && futureMaxes.length > 0) {
          const lastMax = pastMaxes[pastMaxes.length - 1];
          const nextMax = futureMaxes[0];
          
          // Find surrounding slacks
          const slackTimes = todayData.slacks.map(s => parseTimeToday(s, todayBase));
          const nextSlack = slackTimes.find(s => s > now);
          const prevSlack = slackTimes.filter(s => s <= now).pop();
          
          // Interpolate current speed
          if (prevSlack && nextSlack) {
            // Between two slacks - calculate progress toward max
            const totalTime = nextSlack - prevSlack;
            const elapsed = now - prevSlack;
            const progress = elapsed / totalTime;
            
            // Current follows sinusoidal pattern between slacks
            const peakSpeed = lastMax.speed;
            currentSpeed = peakSpeed * Math.sin(progress * Math.PI);
          } else if (nextSlack) {
            // Before first slack, after last max
            const peakSpeed = lastMax.speed;
            const timeToSlack = nextSlack - now;
            const totalTime = nextSlack - lastMax.time;
            const progress = 1 - (timeToSlack / totalTime);
            currentSpeed = peakSpeed * Math.cos(progress * Math.PI / 2);
          }
          
          isFlood = currentSpeed > 0.1;
          isEbb = currentSpeed < -0.1;
          inOneKnotWindow = Math.abs(currentSpeed) <= 1.0;
        }
        
        // Calculate slack windows (1-knot windows) for today and future days
        // A 1-knot window is roughly when current drops below 1 knot around slack
        
        // First, collect ALL slacks and maxes from all available days
        const allSlacks = [];
        const allMaxes = [];
        
        // Helper to add data from a day
        const addDayData = (dayData, dayBase) => {
          if (!dayData) return;
          dayData.slacks.forEach(s => {
            allSlacks.push(parseTimeToday(s, dayBase));
          });
          dayData.maxes.forEach(m => {
            allMaxes.push({ ...m, time: parseTimeToday(m.time, dayBase) });
          });
        };
        
        // Add yesterday's data (for early morning slacks)
        const yesterday = new Date(todayBase);
        yesterday.setDate(yesterday.getDate() - 1);
        const yesterdayStr = getLocalDateString(yesterday);
        const yesterdayData = referenceData[yesterdayStr];
        if (yesterdayData) {
          const yesterdayBase = new Date(yesterday);
          yesterdayBase.setHours(0, 0, 0, 0);
          addDayData(yesterdayData, yesterdayBase);
        }
        
        // Add today's data
        addDayData(todayData, todayBase);
        
        // Add tomorrow's data
        if (tomorrowData) {
          const tomorrowBase = new Date(tomorrow);
          tomorrowBase.setHours(0, 0, 0, 0);
          addDayData(tomorrowData, tomorrowBase);
        }
        
        // Add day after tomorrow's data
        const dayAfterTomorrow = new Date(tomorrow);
        dayAfterTomorrow.setDate(dayAfterTomorrow.getDate() + 1);
        const dayAfterTomorrowStr = getLocalDateString(dayAfterTomorrow);
        const dayAfterTomorrowData = referenceData[dayAfterTomorrowStr];
        if (dayAfterTomorrowData) {
          const dayAfterBase = new Date(dayAfterTomorrow);
          dayAfterBase.setHours(0, 0, 0, 0);
          addDayData(dayAfterTomorrowData, dayAfterBase);
        }
        
        // Sort all events by time
        allSlacks.sort((a, b) => a - b);
        allMaxes.sort((a, b) => a.time - b.time);
        
        // Now calculate windows for each slack
        allSlacks.forEach((slackTime) => {
          if (slackTime < new Date(now.getTime() - 2 * 3600000)) return; // Skip past slacks
          
          // Find the max before and after this slack from the combined list
          const maxBefore = allMaxes.filter(m => m.time < slackTime).pop();
          const maxAfter = allMaxes.find(m => m.time > slackTime);
          
          if (maxBefore || maxAfter) {
            let windowStart = slackTime;
            let windowEnd = slackTime;
            
            // The current follows approximately: speed = peak * sin(œÄ/2 * t/T)
            // where t is time from slack and T is time from slack to max
            // We want to find when |speed| = 1 knot
            // 1 = peak * sin(œÄ/2 * t/T)
            // sin(œÄ/2 * t/T) = 1/peak
            // t/T = (2/œÄ) * arcsin(1/peak)
            // t = T * (2/œÄ) * arcsin(1/peak)
            
            if (maxBefore) {
              const beforePeak = Math.abs(maxBefore.speed);
              const timeFromSlackToMaxBefore = slackTime - maxBefore.time; // T
              
              if (beforePeak > 1) {
                // Time before slack when current drops to 1 knot
                const t = timeFromSlackToMaxBefore * (2 / Math.PI) * Math.asin(1 / beforePeak);
                windowStart = new Date(slackTime.getTime() - t);
              } else {
                // Max is less than 1 knot, window starts at max
                windowStart = maxBefore.time;
              }
            }
            
            if (maxAfter) {
              const afterPeak = Math.abs(maxAfter.speed);
              const timeFromSlackToMaxAfter = maxAfter.time - slackTime; // T
              
              if (afterPeak > 1) {
                // Time after slack when current rises to 1 knot
                const t = timeFromSlackToMaxAfter * (2 / Math.PI) * Math.asin(1 / afterPeak);
                windowEnd = new Date(slackTime.getTime() + t);
              } else {
                // Max is less than 1 knot, window ends at max
                windowEnd = maxAfter.time;
              }
            }
            
            if (windowEnd > now) {
              slackWindows.push({
                start: windowStart,
                slack: slackTime,
                end: windowEnd,
                type: maxBefore && maxBefore.speed > 0 ? 'high-slack' : 'low-slack',
                nextDirection: maxAfter && maxAfter.speed > 0 ? 'flood' : 'ebb'
              });
            }
          }
        });
        
        // Sort windows by slack time
        slackWindows.sort((a, b) => a.slack - b.slack);
        
        return {
          currentSpeed: Math.abs(currentSpeed).toFixed(1),
          isFlood,
          isEbb,
          isSlack: !isFlood && !isEbb,
          inOneKnotWindow,
          direction: isFlood || (!isFlood && !isEbb && currentSpeed >= 0) ? floodDir : ebbDir,
          directionDeg: isFlood || (!isFlood && !isEbb && currentSpeed >= 0) ? stationConfig.floodDeg : stationConfig.ebbDeg,
          events: events.slice(0, 8),
          slackWindows: slackWindows.filter(w => w.end > now).slice(0, 5),
          progressPercent: 50,
          hasReferenceData: true
        };
      }
      
      // Fallback to harmonic calculation if no reference data
      return calculateCurrentsFallback(stationConfig);
    }
    
    // Fallback harmonic calculation (less accurate)
    function calculateCurrentsFallback(stationConfig) {
      const now = new Date();
      const base = new Date(now);
      base.setHours(0, 0, 0, 0);
      
      const M2_period = 12.42 * 3600000;
      const { maxFlood, maxEbb, floodDir, ebbDir, phaseOffset } = stationConfig;
      
      const nowT = now.getTime() - base.getTime();
      const phase = 2 * Math.PI * (nowT + phaseOffset) / M2_period;
      const rawNow = Math.sin(phase);
      const currentSpeed = rawNow > 0 ? rawNow * maxFlood : rawNow * maxEbb;
      
      return {
        currentSpeed: Math.abs(currentSpeed).toFixed(1),
        isFlood: currentSpeed > 0.1,
        isEbb: currentSpeed < -0.1,
        isSlack: Math.abs(currentSpeed) <= 0.1,
        inOneKnotWindow: Math.abs(currentSpeed) <= 1.0,
        direction: currentSpeed >= 0 ? floodDir : ebbDir,
        directionDeg: currentSpeed >= 0 ? stationConfig.floodDeg : stationConfig.ebbDeg,
        events: [],
        slackWindows: [],
        progressPercent: 50,
        hasReferenceData: false
      };
    }

    // Station configurations
    const FIRST_NARROWS = {
      maxFlood: 3.5,  // knots
      maxEbb: 5.0,    // knots (stronger)
      floodDir: 'SE into harbour',
      ebbDir: 'NW out to Strait',
      floodDeg: 135,
      ebbDeg: 315,
      phaseOffset: 1.5 * 3600000 // Current phase offset from Point Atkinson tide
    };

    const SECOND_NARROWS = {
      maxFlood: 3.0,
      maxEbb: 4.5,
      floodDir: 'E into harbour',
      ebbDir: 'W out to Strait',
      floodDeg: 90,
      ebbDeg: 270,
      phaseOffset: 2.5 * 3600000 // Second Narrows lags First Narrows by ~1 hour
    };

    function updateCurrentsDisplay() {
      // First Narrows
      const first = calculateCurrents(FIRST_NARROWS, FIRST_NARROWS_DATA);
      document.getElementById('firstNarrowsSpeed').textContent = first.currentSpeed;
      
      const firstState = document.getElementById('firstNarrowsState');
      const firstArrow = document.getElementById('firstNarrowsArrow');
      const firstProgress = document.getElementById('firstNarrowsProgress');
      const firstDir = document.getElementById('firstNarrowsDir');
      
      if (first.isSlack) {
        firstState.textContent = 'SLACK';
        firstState.className = 'current-state slack';
        firstArrow.className = 'current-arrow slack';
        firstArrow.style.transform = 'rotate(0deg)';
        firstProgress.className = 'timeline-progress flood';
        firstDir.textContent = 'Minimal current ‚Äî turning';
      } else if (first.isFlood) {
        firstState.textContent = 'FLOOD';
        firstState.className = 'current-state flood';
        firstArrow.className = 'current-arrow flood';
        firstArrow.style.transform = `rotate(${FIRST_NARROWS.floodDeg}deg)`;
        firstProgress.className = 'timeline-progress flood';
        firstDir.textContent = `Flowing ${first.direction} (${first.directionDeg}¬∞)`;
      } else {
        firstState.textContent = 'EBB';
        firstState.className = 'current-state ebb';
        firstArrow.className = 'current-arrow ebb';
        firstArrow.style.transform = `rotate(${FIRST_NARROWS.ebbDeg}deg)`;
        firstProgress.className = 'timeline-progress ebb';
        firstDir.textContent = `Flowing ${first.direction} (${first.directionDeg}¬∞)`;
      }
      
      firstProgress.style.width = `${first.progressPercent}%`;
      document.getElementById('firstNarrowsMarker').style.left = `${first.progressPercent}%`;
      
      // First Narrows Events - only show next max flood and next max ebb
      const firstEventsEl = document.getElementById('firstNarrowsEvents');
      const firstNextFlood = first.events.find(e => e.type === 'max-flood');
      const firstNextEbb = first.events.find(e => e.type === 'max-ebb');
      const firstMaxEvents = [firstNextFlood, firstNextEbb].filter(Boolean);
      firstEventsEl.innerHTML = firstMaxEvents.map(e => `
        <div class="current-event">
          <div class="event-time">${formatTime(e.time)}</div>
          <div class="event-type ${e.type}">${e.type === 'max-flood' ? '‚ñ≤ Max Flood' : '‚ñº Max Ebb'}</div>
          <div class="event-speed">${e.speed} kts</div>
        </div>
      `).join('');
      
      // First Narrows Slack Windows
      renderSlackWindows('firstNarrowsWindows', first.slackWindows, first.inOneKnotWindow);
      
      // Second Narrows
      const second = calculateCurrents(SECOND_NARROWS, SECOND_NARROWS_DATA);
      document.getElementById('secondNarrowsSpeed').textContent = second.currentSpeed;
      
      const secondState = document.getElementById('secondNarrowsState');
      const secondArrow = document.getElementById('secondNarrowsArrow');
      const secondProgress = document.getElementById('secondNarrowsProgress');
      const secondDir = document.getElementById('secondNarrowsDir');
      
      if (second.isSlack) {
        secondState.textContent = 'SLACK';
        secondState.className = 'current-state slack';
        secondArrow.className = 'current-arrow slack';
        secondArrow.style.transform = 'rotate(0deg)';
        secondProgress.className = 'timeline-progress flood';
        secondDir.textContent = 'Minimal current ‚Äî turning';
      } else if (second.isFlood) {
        secondState.textContent = 'FLOOD';
        secondState.className = 'current-state flood';
        secondArrow.className = 'current-arrow flood';
        secondArrow.style.transform = `rotate(${SECOND_NARROWS.floodDeg}deg)`;
        secondProgress.className = 'timeline-progress flood';
        secondDir.textContent = `Flowing ${second.direction} (${second.directionDeg}¬∞)`;
      } else {
        secondState.textContent = 'EBB';
        secondState.className = 'current-state ebb';
        secondArrow.className = 'current-arrow ebb';
        secondArrow.style.transform = `rotate(${SECOND_NARROWS.ebbDeg}deg)`;
        secondProgress.className = 'timeline-progress ebb';
        secondDir.textContent = `Flowing ${second.direction} (${second.directionDeg}¬∞)`;
      }
      
      secondProgress.style.width = `${second.progressPercent}%`;
      document.getElementById('secondNarrowsMarker').style.left = `${second.progressPercent}%`;
      
      // Second Narrows Events - only show next max flood and next max ebb
      const secondEventsEl = document.getElementById('secondNarrowsEvents');
      const secondNextFlood = second.events.find(e => e.type === 'max-flood');
      const secondNextEbb = second.events.find(e => e.type === 'max-ebb');
      const secondMaxEvents = [secondNextFlood, secondNextEbb].filter(Boolean);
      secondEventsEl.innerHTML = secondMaxEvents.map(e => `
        <div class="current-event">
          <div class="event-time">${formatTime(e.time)}</div>
          <div class="event-type ${e.type}">${e.type === 'max-flood' ? '‚ñ≤ Max Flood' : '‚ñº Max Ebb'}</div>
          <div class="event-speed">${e.speed} kts</div>
        </div>
      `).join('');
      
      // Second Narrows Slack Windows
      renderSlackWindows('secondNarrowsWindows', second.slackWindows, second.inOneKnotWindow);
    }
    
    // Render slack windows visual
    function renderSlackWindows(elementId, windows, currentlyInWindow) {
      const container = document.getElementById(elementId);
      const now = new Date();
      const todayStr = getLocalDateString(now);
      
      if (windows.length === 0) {
        container.innerHTML = '<div class="slack-windows-title">1-Knot Safe Passage Windows</div><div style="color: var(--mist-gray); font-size: 0.75rem;">No upcoming windows in reference data</div>';
        return;
      }
      
      let html = '<div class="slack-windows-title">1-Knot Safe Passage Windows</div>';
      
      windows.forEach((w, idx) => {
        const duration = Math.round((w.end - w.start) / 60000); // minutes
        const isActive = now >= w.start && now <= w.end;
        const isPast = now > w.end;
        
        if (isPast) return;
        
        // Check if this is today or a future day
        const windowDateStr = getLocalDateString(w.slack);
        const isToday = windowDateStr === todayStr;
        const dayLabel = isToday ? '' : w.slack.toLocaleDateString('en-CA', { weekday: 'short', month: 'short', day: 'numeric' }) + ' ‚Äî ';
        
        // Calculate positions for the visual bar (as percentage)
        const totalSpan = w.end - w.start;
        const slackPos = ((w.slack - w.start) / totalSpan) * 100;
        const nowPos = isActive ? ((now - w.start) / totalSpan) * 100 : -1;
        
        // Determine what comes before and after slack
        const beforeSlack = w.type === 'high-slack' ? 'flood' : 'ebb';
        const afterSlack = w.nextDirection;
        
        html += `
          <div class="window-card ${isActive ? 'active' : ''}">
            <div class="window-header">
              <div class="window-type">${dayLabel}${w.type === 'high-slack' ? 'High Slack' : 'Low Slack'} Window</div>
              ${isActive ? '<div class="window-badge">‚óè NOW IN WINDOW</div>' : idx === 0 ? '<div class="window-badge">Next</div>' : ''}
            </div>
            <div class="window-visual">
              <div class="window-${beforeSlack}-zone" style="left: 0; width: ${slackPos}%"></div>
              <div class="window-${afterSlack}-zone" style="left: ${slackPos}%; width: ${100 - slackPos}%"></div>
              <div class="window-safe-zone" style="left: 0; width: 100%"></div>
              <div class="window-slack-marker" style="left: ${slackPos}%"></div>
              ${isActive ? `<div class="window-now-marker" style="left: ${nowPos}%"></div>` : ''}
            </div>
            <div class="window-times">
              <div class="window-time-block">
                <div class="window-time-label">Window Opens</div>
                <div class="window-time-value">${formatTime(w.start)}</div>
              </div>
              <div class="window-time-block center">
                <div class="window-time-label">Slack</div>
                <div class="window-time-value slack">${formatTime(w.slack)}</div>
              </div>
              <div class="window-time-block" style="text-align: right">
                <div class="window-time-label">Window Closes</div>
                <div class="window-time-value">${formatTime(w.end)}</div>
              </div>
            </div>
            <div class="window-duration">
              Window duration: <strong>${duration} minutes</strong> 
              ${isActive ? ` ‚Ä¢ ${Math.round((w.end - now) / 60000)} min remaining` : ''}
            </div>
          </div>
        `;
      });
      
      container.innerHTML = html;
    }

    function updateCurrent(d) {
      const c = d.current;
      const wKts = msToKnots(c.wind_speed_10m), gKts = msToKnots(c.wind_gusts_10m), wDir = c.wind_direction_10m;
      
      document.getElementById('currentWind').textContent = wKts;
      document.getElementById('currentGust').textContent = gKts;
      document.getElementById('windDirText').textContent = `${getWindDirection(wDir)} (${Math.round(wDir)}¬∞)`;
      document.getElementById('compassNeedle').style.transform = `rotate(${wDir}deg)`;
      document.getElementById('currentTemp').textContent = Math.round(c.temperature_2m);
      document.getElementById('currentHumidity').textContent = c.relative_humidity_2m || '‚Äî';
      document.getElementById('feelsLike').textContent = c.apparent_temperature ? Math.round(c.apparent_temperature) : '‚Äî';
      document.getElementById('currentConditions').textContent = weatherCodes[c.weather_code] || 'Unknown';
      document.getElementById('cloudCover').textContent = c.cloud_cover || '‚Äî';
      document.getElementById('pressure').textContent = c.pressure_msl ? Math.round(c.pressure_msl) : '‚Äî';
      document.getElementById('updateTime').textContent = formatDateTime(new Date());
      
      // Update source info
      document.getElementById('weatherStation').textContent = d.station || 'Model Data';
      document.getElementById('weatherSource').textContent = d.source || 'Open-Meteo';
      document.getElementById('alertSourceName').textContent = d.source || 'Open-Meteo';
    }

    function build3DayForecast(d) {
      const container = document.getElementById('marineForecastContainer');
      container.innerHTML = '';
      const h = d.hourly;
      const now = new Date();
      
      // Group hours by day
      const days = {};
      let start = h.time.findIndex(t => new Date(t) >= now);
      if (start < 0) start = 0;
      
      for (let i = start; i < Math.min(start + 72, h.time.length); i++) {
        const t = new Date(h.time[i]);
        const dayKey = t.toDateString();
        if (!days[dayKey]) {
          days[dayKey] = {
            date: t,
            hours: []
          };
        }
        days[dayKey].hours.push({
          time: t,
          temp: Math.round(h.temperature_2m[i]),
          windSpeed: msToKnots(h.wind_speed_10m[i]),
          windDir: getWindDirection(h.wind_direction_10m[i]),
          windDirDeg: h.wind_direction_10m[i],
          precipitation: h.precipitation[i],
          weatherCode: h.weather_code ? h.weather_code[i] : 0,
          cloudCover: h.cloud_cover ? h.cloud_cover[i] : 0,
          index: i
        });
      }
      
      // Only show 3 days
      const dayKeys = Object.keys(days).slice(0, 3);
      
      dayKeys.forEach((dayKey, dayIndex) => {
        const day = days[dayKey];
        const panel = document.createElement('div');
        panel.className = 'forecast-day-panel';
        
        // Day header
        const dayName = dayIndex === 0 ? 'Today' : 
                       dayIndex === 1 ? 'Tomorrow' : 
                       day.date.toLocaleDateString('en-CA', { weekday: 'long' });
        
        const dateStr = day.date.toLocaleDateString('en-CA', { month: 'short', day: 'numeric' });
        
        // Calculate day summary
        const maxWind = Math.max(...day.hours.map(h => h.windSpeed));
        const totalPrecip = day.hours.reduce((sum, h) => sum + h.precipitation, 0);
        
        let summaryParts = [`Max wind ${maxWind} kts`];
        if (totalPrecip > 0.5) {
          summaryParts.push(`${totalPrecip.toFixed(1)} mm precip`);
        }
        
        panel.innerHTML = `
          <div class="forecast-day-header">
            <div class="forecast-day-name">${dayName} ¬∑ ${dateStr}</div>
            <div class="forecast-day-summary">${summaryParts.join(' ¬∑ ')}</div>
          </div>
          <div class="forecast-hours-grid" id="forecastDay${dayIndex}"></div>
        `;
        
        container.appendChild(panel);
        
        // Add hourly cells in 3 rows of 8
        const grid = document.getElementById(`forecastDay${dayIndex}`);
        day.hours.forEach((hour, hourIndex) => {
          const isCurrent = dayIndex === 0 && hourIndex === 0;
          const cell = document.createElement('div');
          cell.className = `forecast-hour-cell ${isCurrent ? 'current' : ''}`;
          
          // Get weather icon based on weather code
          const icon = weatherIcons[hour.weatherCode] || getSimpleWeatherIcon(hour);
          
          cell.innerHTML = `
            <div class="hour-cell-time">${formatTime(hour.time)}</div>
            <div class="hour-cell-icon">${icon}</div>
            <div class="hour-cell-temp">${hour.temp}¬∞C</div>
            <div class="hour-cell-wind ${getWindClass(hour.windSpeed)}">${hour.windSpeed} kts</div>
            <div class="hour-cell-wind-dir">${hour.windDir}</div>
            <div class="hour-cell-rain ${hour.precipitation < 0.1 ? 'none' : ''}">${hour.precipitation >= 0.1 ? hour.precipitation.toFixed(1) + ' mm' : '‚Äî'}</div>
          `;
          
          grid.appendChild(cell);
        });
      });
    }
    
    // Fallback simple weather icon based on conditions
    function getSimpleWeatherIcon(hour) {
      const isDay = hour.time.getHours() >= 6 && hour.time.getHours() < 20;
      if (hour.precipitation > 1) return 'üåßÔ∏è';
      if (hour.precipitation > 0.1) return 'üå¶Ô∏è';
      if (hour.cloudCover > 80) return '‚òÅÔ∏è';
      if (hour.cloudCover > 40) return isDay ? '‚õÖ' : '‚òÅÔ∏è';
      return isDay ? '‚òÄÔ∏è' : 'üåô';
    }

    // Fraser River Water Level & Velocity Graph
    function drawFraserRiverGraph(canvasId, markerId, riverData) {
      const canvas = document.getElementById(canvasId);
      const marker = document.getElementById(markerId);
      if (!canvas) return;
      
      const ctx = canvas.getContext('2d');
      const container = canvas.parentElement;
      
      const width = container.offsetWidth || 800;
      const height = container.offsetHeight || 140;
      
      const dpr = window.devicePixelRatio || 1;
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
      ctx.scale(dpr, dpr);
      
      const now = new Date();
      const startTime = new Date(now.getTime() - 2 * 3600000);
      const endTime = new Date(startTime.getTime() + 72 * 3600000);
      
      // Collect all data points
      const points = [];
      for (let d = -1; d < 5; d++) {
        const date = new Date(now);
        date.setDate(date.getDate() + d);
        const dateStr = getLocalDateString(date);
        
        if (riverData[dateStr]) {
          riverData[dateStr].forEach(entry => {
            const [hours, mins] = entry.time.split(':').map(Number);
            const pointTime = new Date(date);
            pointTime.setHours(hours, mins || 0, 0, 0);
            
            if (pointTime >= startTime && pointTime <= endTime) {
              points.push({
                time: pointTime,
                level: entry.level,
                velocity: entry.velocity,
                x: (pointTime.getTime() - startTime.getTime()) / (endTime.getTime() - startTime.getTime())
              });
            }
          });
        }
      }
      
      points.sort((a, b) => a.time - b.time);
      
      if (points.length === 0) {
        ctx.fillStyle = 'rgba(200, 200, 200, 0.5)';
        ctx.font = '12px Inter';
        ctx.textAlign = 'center';
        ctx.fillText('No river data available', width / 2, height / 2);
        return;
      }
      
      // Find min/max
      const levels = points.map(p => p.level);
      const velocities = points.map(p => p.velocity);
      const minL = Math.min(...levels) - 0.2;
      const maxL = Math.max(...levels) + 0.2;
      const minV = Math.min(...velocities);
      const maxV = Math.max(...velocities);
      const maxAbsV = Math.max(Math.abs(minV), Math.abs(maxV), 0.3);
      
      const padding = { top: 20, bottom: 20, left: 40, right: 50 };
      const graphWidth = width - padding.left - padding.right;
      const graphHeight = height - padding.top - padding.bottom;
      
      // Store params for mouse interaction
      canvas.graphParams = { points, minL, maxL, minV: -maxAbsV, maxV: maxAbsV, padding, graphWidth, graphHeight, width, height, startTime, endTime, now };
      
      // Draw the graph
      drawFraserStaticGraph(ctx, canvas.graphParams);
      
      // Position NOW marker
      const nowX = padding.left + ((now.getTime() - startTime.getTime()) / (endTime.getTime() - startTime.getTime())) * graphWidth;
      marker.style.left = `${nowX}px`;
      
      // Mouse events
      if (!canvas.hasMouseListeners) {
        canvas.hasMouseListeners = true;
        
        canvas.addEventListener('mousemove', (e) => {
          const rect = canvas.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;
          drawFraserWithCrosshairs(canvas, mouseX, mouseY);
        });
        
        canvas.addEventListener('mouseleave', () => {
          const ctx = canvas.getContext('2d');
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          const dpr = window.devicePixelRatio || 1;
          ctx.scale(dpr, dpr);
          drawFraserStaticGraph(ctx, canvas.graphParams);
        });
      }
    }
    
    function drawFraserStaticGraph(ctx, params) {
      const { points, minL, maxL, minV, maxV, padding, graphWidth, graphHeight, width, height, startTime, endTime, now } = params;
      
      ctx.clearRect(0, 0, width, height);
      
      // Grid lines
      ctx.strokeStyle = 'rgba(0, 212, 170, 0.15)';
      ctx.lineWidth = 1;
      
      // Horizontal grid for water level
      for (let l = 0; l <= 3; l += 0.5) {
        if (l >= minL && l <= maxL) {
          const y = padding.top + graphHeight * (1 - (l - minL) / (maxL - minL));
          ctx.beginPath();
          ctx.moveTo(padding.left, y);
          ctx.lineTo(width - padding.right, y);
          ctx.stroke();
          
          // Level label on left
          ctx.fillStyle = 'rgba(0, 212, 170, 0.7)';
          ctx.font = '9px Inter';
          ctx.textAlign = 'right';
          ctx.fillText(`${l.toFixed(1)}m`, padding.left - 4, y + 3);
        }
      }
      
      // Velocity scale on right
      ctx.fillStyle = 'rgba(200, 200, 200, 0.5)';
      ctx.font = '8px Inter';
      ctx.textAlign = 'left';
      const velLabels = [-0.5, 0, 0.5];
      velLabels.forEach(v => {
        if (v >= minV && v <= maxV) {
          const y = padding.top + graphHeight * (1 - (v - minV) / (maxV - minV));
          ctx.fillText(`${v > 0 ? '+' : ''}${v.toFixed(1)} m/s`, width - padding.right + 4, y + 3);
        }
      });
      
      // Time labels
      ctx.fillStyle = 'rgba(200, 200, 200, 0.6)';
      ctx.font = '9px Inter';
      ctx.textAlign = 'center';
      
      for (let h = 0; h <= 72; h += 12) {
        const x = padding.left + (h / 72) * graphWidth;
        const labelTime = new Date(startTime.getTime() + h * 3600000);
        
        if (labelTime.getHours() === 0 || h === 0) {
          ctx.strokeStyle = 'rgba(0, 212, 170, 0.2)';
          ctx.beginPath();
          ctx.moveTo(x, padding.top);
          ctx.lineTo(x, height - padding.bottom);
          ctx.stroke();
        }
        
        if (labelTime.getHours() === 0) {
          ctx.fillText(formatDay(labelTime), x, height - 5);
        } else if (h % 24 === 12) {
          ctx.fillText('12:00', x, height - 5);
        }
      }
      
      // Draw zero velocity line
      const zeroY = padding.top + graphHeight * (1 - (0 - minV) / (maxV - minV));
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
      ctx.setLineDash([3, 3]);
      ctx.beginPath();
      ctx.moveTo(padding.left, zeroY);
      ctx.lineTo(width - padding.right, zeroY);
      ctx.stroke();
      ctx.setLineDash([]);
      
      // Draw water level curve - filled area
      ctx.beginPath();
      ctx.moveTo(padding.left, height - padding.bottom);
      points.forEach((p, i) => {
        const x = padding.left + p.x * graphWidth;
        const y = padding.top + graphHeight * (1 - (p.level - minL) / (maxL - minL));
        ctx.lineTo(x, y);
      });
      ctx.lineTo(padding.left + graphWidth, height - padding.bottom);
      ctx.closePath();
      
      const gradient = ctx.createLinearGradient(0, padding.top, 0, height - padding.bottom);
      gradient.addColorStop(0, 'rgba(0, 212, 170, 0.4)');
      gradient.addColorStop(1, 'rgba(0, 212, 170, 0.05)');
      ctx.fillStyle = gradient;
      ctx.fill();
      
      // Draw water level line
      ctx.beginPath();
      points.forEach((p, i) => {
        const x = padding.left + p.x * graphWidth;
        const y = padding.top + graphHeight * (1 - (p.level - minL) / (maxL - minL));
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.strokeStyle = 'rgba(0, 212, 170, 0.9)';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Draw velocity bars
      points.forEach((p, i) => {
        const x = padding.left + p.x * graphWidth;
        const barHeight = Math.abs(p.velocity) / (maxV - minV) * graphHeight * 0.3;
        
        if (p.velocity > 0) {
          // Downstream (ebb) - coral/red
          ctx.fillStyle = 'rgba(255, 107, 107, 0.4)';
          ctx.fillRect(x - 2, zeroY - barHeight, 4, barHeight);
        } else if (p.velocity < 0) {
          // Upstream (flood) - blue
          ctx.fillStyle = 'rgba(100, 181, 246, 0.4)';
          ctx.fillRect(x - 2, zeroY, 4, barHeight);
        }
      });
      
      // Legend
      ctx.font = '8px Inter';
      ctx.textAlign = 'left';
      ctx.fillStyle = 'rgba(255, 107, 107, 0.8)';
      ctx.fillText('‚Üì Downstream (ebb)', padding.left + 5, padding.top + 10);
      ctx.fillStyle = 'rgba(100, 181, 246, 0.8)';
      ctx.fillText('‚Üë Upstream (flood)', padding.left + 5, padding.top + 20);
    }
    
    function drawFraserWithCrosshairs(canvas, mouseX, mouseY) {
      const ctx = canvas.getContext('2d');
      const params = canvas.graphParams;
      if (!params) return;
      
      const { points, minL, maxL, minV, maxV, padding, graphWidth, graphHeight, width, height, startTime, endTime, now } = params;
      
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      const dpr = window.devicePixelRatio || 1;
      ctx.scale(dpr, dpr);
      drawFraserStaticGraph(ctx, params);
      
      if (mouseX < padding.left || mouseX > width - padding.right || 
          mouseY < padding.top || mouseY > height - padding.bottom) {
        return;
      }
      
      const xRatio = (mouseX - padding.left) / graphWidth;
      const timeAtMouse = new Date(startTime.getTime() + xRatio * (endTime.getTime() - startTime.getTime()));
      
      // Find closest point
      let closestPoint = points[0];
      let minDist = Math.abs(points[0].x - xRatio);
      for (const p of points) {
        const dist = Math.abs(p.x - xRatio);
        if (dist < minDist) {
          minDist = dist;
          closestPoint = p;
        }
      }
      
      const levelY = padding.top + graphHeight * (1 - (closestPoint.level - minL) / (maxL - minL));
      
      // Crosshairs
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
      ctx.lineWidth = 1;
      ctx.setLineDash([5, 5]);
      
      ctx.beginPath();
      ctx.moveTo(mouseX, padding.top);
      ctx.lineTo(mouseX, height - padding.bottom);
      ctx.stroke();
      
      ctx.beginPath();
      ctx.moveTo(padding.left, levelY);
      ctx.lineTo(width - padding.right, levelY);
      ctx.stroke();
      
      ctx.setLineDash([]);
      
      // Point marker
      ctx.beginPath();
      ctx.arc(mouseX, levelY, 6, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(0, 212, 170, 1)';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Tooltip
      const timeStr = timeAtMouse.toLocaleString('en-CA', { 
        weekday: 'short', month: 'short', day: 'numeric',
        hour: '2-digit', minute: '2-digit', hour12: false 
      });
      
      const velDir = closestPoint.velocity > 0 ? '‚Üì Downstream' : closestPoint.velocity < 0 ? '‚Üë Upstream' : '‚Äî Slack';
      
      const tooltipWidth = 150;
      const tooltipHeight = 60;
      let tooltipX = mouseX + 15;
      let tooltipY = mouseY - 30;
      
      if (tooltipX + tooltipWidth > width - 10) tooltipX = mouseX - tooltipWidth - 15;
      if (tooltipY < 10) tooltipY = 10;
      if (tooltipY + tooltipHeight > height - 10) tooltipY = height - tooltipHeight - 10;
      
      ctx.fillStyle = 'rgba(13, 33, 55, 0.95)';
      ctx.strokeStyle = 'rgba(0, 212, 170, 0.5)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.roundRect(tooltipX, tooltipY, tooltipWidth, tooltipHeight, 6);
      ctx.fill();
      ctx.stroke();
      
      ctx.fillStyle = 'rgba(200, 200, 200, 0.9)';
      ctx.font = '9px Inter';
      ctx.textAlign = 'left';
      ctx.fillText(timeStr, tooltipX + 8, tooltipY + 14);
      
      ctx.fillStyle = 'rgba(0, 212, 170, 1)';
      ctx.font = 'bold 13px Inter';
      ctx.fillText(`${closestPoint.level.toFixed(2)} m`, tooltipX + 8, tooltipY + 32);
      
      ctx.fillStyle = closestPoint.velocity > 0 ? 'rgba(255, 107, 107, 0.9)' : 'rgba(100, 181, 246, 0.9)';
      ctx.font = '10px Inter';
      ctx.fillText(`${velDir} ${Math.abs(closestPoint.velocity).toFixed(2)} m/s`, tooltipX + 8, tooltipY + 48);
    }

    function updateTidesDisplay() {
      // Draw tide graphs with integrated high/low markers
      drawTideGraph('secondNarrowsTideGraph', 'secondNarrowsNowMarker', SECOND_NARROWS_TIDE_DATA);
      drawTideGraph('stevestonTideGraph', 'stevestonNowMarker', STEVESTON_TIDE_DATA);
      
      // Draw Fraser River graphs
      drawFraserRiverGraph('fraserSouthGraph', 'fraserSouthNowMarker', FRASER_SOUTH_ARM_DATA);
      drawFraserRiverGraph('fraserNorthGraph', 'fraserNorthNowMarker', FRASER_NORTH_ARM_DATA);
    }

    async function initialize() {
      document.getElementById('loadingState').style.display = 'flex';
      document.getElementById('errorState').style.display = 'none';
      document.getElementById('mainContent').classList.remove('loaded');
      
      try {
        const weather = await fetchWeatherData();
        updateCurrent(weather);
        build3DayForecast(weather);
        updateCurrentsDisplay();
        document.getElementById('loadingState').style.display = 'none';
        document.getElementById('mainContent').classList.add('loaded');
        
        // Draw tide graphs after content is visible
        requestAnimationFrame(() => {
          updateTidesDisplay();
        });
        
        // Fetch EC marine forecast (non-blocking)
        fetchECMarineForecast().catch(e => console.warn('EC Marine forecast error:', e));
      } catch (e) {
        console.error('Error:', e);
        showError(e.message);
      }
    }

    // Redraw tide graphs on window resize
    window.addEventListener('resize', () => {
      updateTidesDisplay();
    });

    initialize();
    setInterval(initialize, CONFIG.refreshInterval);
    document.getElementById('refreshBtn').addEventListener('click', initialize);
  </script>
</body>
</html>
