<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Seaforth Environmental Dispatch Dashboard</title>
  <link href="https://fonts.googleapis.com/css2?family=Archivo+Black&family=IBM+Plex+Mono:wght@400;600&family=Source+Serif+4:opsz,wght@8..60,400;8..60,600&display=swap" rel="stylesheet">
  <style>
    :root {
      --deep-navy: #0a1628;
      --ocean-dark: #0d2137;
      --ocean-mid: #143654;
      --teal-accent: #00d4aa;
      --teal-glow: #00ffcc;
      --amber-warning: #ffaa00;
      --coral-alert: #ff6b6b;
      --ice-white: #e8f4f8;
      --mist-gray: #94a3b8;
      --foam-white: #f0f9ff;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'IBM Plex Mono', monospace;
      background: var(--deep-navy);
      color: var(--ice-white);
      min-height: 100vh;
      overflow-x: hidden;
    }

    .ocean-bg {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      background: 
        radial-gradient(ellipse at 30% 20%, rgba(0, 212, 170, 0.08) 0%, transparent 50%),
        radial-gradient(ellipse at 70% 80%, rgba(20, 54, 84, 0.4) 0%, transparent 50%),
        linear-gradient(180deg, var(--deep-navy) 0%, var(--ocean-dark) 50%, var(--deep-navy) 100%);
    }

    .wave-pattern {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 200%;
      height: 200px;
      opacity: 0.03;
      background: repeating-linear-gradient(90deg, transparent, transparent 50px, var(--teal-accent) 50px, var(--teal-accent) 51px);
      animation: waveScroll 30s linear infinite;
    }

    @keyframes waveScroll {
      0% { transform: translateX(0); }
      100% { transform: translateX(-50%); }
    }

    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
      flex-direction: column;
      gap: 1.5rem;
    }

    .loading-spinner {
      width: 60px;
      height: 60px;
      border: 3px solid var(--ocean-mid);
      border-top-color: var(--teal-accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin { to { transform: rotate(360deg); } }

    .loading-text {
      font-size: 0.85rem;
      color: var(--mist-gray);
      letter-spacing: 0.1em;
    }

    .header {
      padding: 2rem 3rem;
      border-bottom: 1px solid rgba(0, 212, 170, 0.2);
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: rgba(10, 22, 40, 0.8);
      backdrop-filter: blur(10px);
      position: sticky;
      top: 0;
      z-index: 100;
    }

    .logo-section {
      display: flex;
      align-items: center;
      gap: 1.5rem;
    }

    .logo-icon {
      width: 56px;
      height: 56px;
      background: linear-gradient(135deg, var(--teal-accent), var(--ocean-mid));
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.8rem;
      box-shadow: 0 4px 20px rgba(0, 212, 170, 0.3);
    }

    .logo-text h1 {
      font-family: 'Archivo Black', sans-serif;
      font-size: 1.6rem;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      background: linear-gradient(90deg, var(--ice-white), var(--teal-accent));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      line-height: 1.1;
    }

    .logo-text h1 span {
      display: block;
      font-size: 0.9rem;
      letter-spacing: 0.15em;
      background: none;
      -webkit-text-fill-color: var(--mist-gray);
      color: var(--mist-gray);
    }

    .header-info { text-align: right; }

    .location {
      font-family: 'Source Serif 4', serif;
      font-size: 1.1rem;
      color: var(--foam-white);
    }

    .coordinates {
      font-size: 0.75rem;
      color: var(--teal-accent);
      margin-top: 0.25rem;
    }

    .last-update {
      font-size: 0.7rem;
      color: var(--mist-gray);
      margin-top: 0.5rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      justify-content: flex-end;
    }

    .live-indicator {
      width: 8px;
      height: 8px;
      background: var(--teal-accent);
      border-radius: 50%;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; box-shadow: 0 0 0 0 rgba(0, 212, 170, 0.5); }
      50% { opacity: 0.7; box-shadow: 0 0 0 6px rgba(0, 212, 170, 0); }
    }

    .main-content {
      padding: 1.25rem 2.5rem;
      max-width: 1800px;
      margin: 0 auto;
      display: none;
    }

    .main-content.loaded { display: block; }

    .current-hero {
      display: none; /* Hide old layout */
    }

    /* New unified status bar */
    .unified-status-bar {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1rem;
      align-items: stretch;
    }

    .status-card {
      background: linear-gradient(135deg, rgba(20, 54, 84, 0.6), rgba(13, 33, 55, 0.8));
      border: 1px solid rgba(0, 212, 170, 0.15);
      border-radius: 8px;
      padding: 0.5rem 0.75rem;
      position: relative;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }

    .status-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(90deg, transparent, var(--teal-accent), transparent);
    }

    .status-card.wind-status { flex: 0 0 auto; min-width: 100px; }
    .status-card.temp-status { flex: 0 0 auto; min-width: 80px; }
    .status-card.temp-status::before { background: linear-gradient(90deg, transparent, var(--amber-warning), transparent); }
    .status-card.conditions-status { flex: 0 0 auto; min-width: 110px; }
    .status-card.conditions-status::before { background: linear-gradient(90deg, transparent, var(--foam-white), transparent); }
    .status-card.forecast-status { 
      flex: 1; 
      border-left-color: var(--teal-accent);
    }
    .status-card.forecast-status::before { background: linear-gradient(90deg, transparent, rgba(0, 212, 170, 0.5), transparent); }

    .status-label {
      font-size: 0.5rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--mist-gray);
      margin-bottom: 0.15rem;
    }

    .status-value {
      font-family: 'Archivo Black', sans-serif;
      font-size: 1.4rem;
      line-height: 1;
      color: var(--teal-accent);
    }

    .status-value.temp { color: var(--amber-warning); }
    .status-value.conditions { 
      font-size: 0.9rem; 
      color: var(--foam-white); 
      font-family: 'Source Serif 4', serif;
      font-weight: 600;
    }

    .status-unit {
      font-size: 0.7rem;
      color: var(--mist-gray);
      font-weight: 400;
    }

    .status-detail {
      font-size: 0.55rem;
      color: var(--mist-gray);
      margin-top: 0.1rem;
    }

    .status-wind-dir {
      display: flex;
      align-items: center;
      gap: 0.3rem;
      font-size: 0.6rem;
      color: var(--mist-gray);
      margin-top: 0.15rem;
    }

    .status-wind-dir .mini-compass {
      width: 14px;
      height: 14px;
      border: 1px solid rgba(0, 212, 170, 0.4);
      border-radius: 50%;
      position: relative;
    }

    .status-wind-dir .mini-needle {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 2px;
      height: 6px;
      background: var(--teal-accent);
      transform-origin: center bottom;
      margin-left: -1px;
      margin-top: -6px;
    }

    /* Forecast inside status bar */
    .inline-forecast {
      display: flex;
      gap: 0.5rem;
      align-items: stretch;
      height: 100%;
    }

    .inline-forecast-main {
      flex: 0 0 auto;
      min-width: 200px;
      border-left: 2px solid var(--teal-accent);
      padding-left: 0.5rem;
    }

    .inline-forecast-title {
      font-size: 0.5rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--teal-accent);
      margin-bottom: 0.15rem;
      font-weight: 600;
    }

    .inline-forecast-text {
      font-size: 0.7rem;
      color: rgba(255, 255, 255, 0.9);
      line-height: 1.3;
    }

    .inline-forecast-extended {
      display: flex;
      gap: 0.4rem;
      flex: 1;
    }

    .inline-ext-day {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 4px;
      padding: 0.35rem 0.5rem;
      flex: 1;
      min-width: 0;
    }

    .inline-ext-name {
      font-size: 0.5rem;
      font-weight: 600;
      color: var(--teal-accent);
      margin-bottom: 0.1rem;
    }

    .inline-ext-text {
      font-size: 0.6rem;
      color: rgba(200, 200, 200, 0.8);
      line-height: 1.25;
      overflow: hidden;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
    }

    .inline-forecast-meta {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: flex-end;
      font-size: 0.5rem;
      color: var(--mist-gray);
      min-width: 80px;
    }

    .inline-forecast-meta a {
      color: var(--teal-accent);
      text-decoration: none;
      font-size: 0.55rem;
    }

    .inline-forecast-meta a:hover {
      text-decoration: underline;
    }

    /* PPA Status Card in unified bar */
    .status-card.ppa-status {
      flex: 1;
      min-width: 200px;
    }

    .status-card.ppa-status::before {
      background: linear-gradient(90deg, transparent, #64b5f6, transparent);
    }

    .inline-ppa {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      height: 100%;
    }

    .ppa-status-icon {
      font-size: 1.5rem;
      line-height: 1;
    }

    .ppa-status-content {
      flex: 1;
    }

    .ppa-status-title {
      font-size: 0.55rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: #64b5f6;
      margin-bottom: 0.15rem;
      font-weight: 600;
    }

    .ppa-status-desc {
      font-size: 0.6rem;
      color: rgba(200, 200, 200, 0.8);
      margin-bottom: 0.25rem;
    }

    .ppa-status-link {
      font-size: 0.6rem;
      color: var(--teal-accent);
      text-decoration: none;
      font-weight: 600;
    }

    .ppa-status-link:hover {
      text-decoration: underline;
    }

    /* Hide old elements */
    .weather-source-info, .forecast-section .marine-alert {
      display: none;
    }

    /* Responsive: stack on smaller screens */
    @media (max-width: 1100px) {
      .unified-status-bar {
        flex-wrap: wrap;
      }
      .status-card.ppa-status {
        flex: 1 1 100%;
        order: 10;
      }
    }

    .hero-card {
      background: linear-gradient(135deg, rgba(20, 54, 84, 0.6), rgba(13, 33, 55, 0.8));
      border: 1px solid rgba(0, 212, 170, 0.15);
      border-radius: 10px;
      padding: 0.75rem 1rem;
      position: relative;
      overflow: hidden;
    }

    .hero-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(90deg, transparent, var(--teal-accent), transparent);
    }

    .hero-card.temp-card::before { background: linear-gradient(90deg, transparent, var(--amber-warning), transparent); }
    .hero-card.conditions-card::before { background: linear-gradient(90deg, transparent, var(--foam-white), transparent); }

    .card-label {
      font-size: 0.55rem;
      text-transform: uppercase;
      letter-spacing: 0.15em;
      color: var(--mist-gray);
      margin-bottom: 0.25rem;
    }

    .card-value {
      font-family: 'Archivo Black', sans-serif;
      font-size: 1.9rem;
      line-height: 1;
      margin-bottom: 0.2rem;
    }

    .wind-card .card-value { color: var(--teal-accent); }
    .temp-card .card-value { color: var(--amber-warning); }

    .conditions-card .card-value {
      font-size: 1.3rem;
      color: var(--foam-white);
      font-family: 'Source Serif 4', serif;
      font-weight: 600;
    }

    .card-unit {
      font-size: 0.9rem;
      color: var(--mist-gray);
      font-weight: 400;
    }

    .card-detail {
      font-size: 0.65rem;
      color: var(--mist-gray);
      margin-top: 0.2rem;
    }

    .wind-direction {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.4rem;
    }

    .compass {
      width: 32px;
      height: 32px;
      border: 2px solid var(--teal-accent);
      border-radius: 50%;
      position: relative;
    }

    .compass-needle {
      width: 3px;
      height: 12px;
      background: linear-gradient(to top, var(--coral-alert), var(--teal-accent));
      border-radius: 2px;
      transform-origin: center bottom;
      position: absolute;
      top: 11px;
      left: 50%;
      margin-left: -2px;
      transition: transform 0.5s ease;
    }

    .compass::after {
      content: 'N';
      position: absolute;
      top: -18px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.55rem;
      color: var(--mist-gray);
    }

    .weather-source-info {
      text-align: center;
      font-size: 0.7rem;
      color: var(--mist-gray);
      margin-bottom: 1.5rem;
      padding: 0.5rem;
      background: rgba(0, 212, 170, 0.05);
      border-radius: 6px;
      border: 1px solid rgba(0, 212, 170, 0.1);
    }
    
    .weather-source-info .source-label {
      color: rgba(200, 200, 200, 0.6);
    }
    
    .weather-source-info .source-separator {
      margin: 0 0.75rem;
      color: rgba(0, 212, 170, 0.3);
    }
    
    #weatherStation, #weatherSource {
      color: var(--teal-accent);
    }

    .section-title {
      font-family: 'Archivo Black', sans-serif;
      font-size: 0.8rem;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      color: var(--mist-gray);
      margin-bottom: 0.6rem;
      padding-bottom: 0.35rem;
      border-bottom: 1px solid rgba(0, 212, 170, 0.2);
    }

    .forecast-section { margin-bottom: 1.5rem; }

    /* EC Official Marine Forecast Section */
    .ec-marine-forecast-section {
      margin-bottom: 1.25rem;
    }
    
    .ec-marine-forecast-container {
      background: linear-gradient(135deg, rgba(13, 33, 55, 0.9) 0%, rgba(20, 45, 70, 0.8) 100%);
      border: 1px solid rgba(0, 212, 170, 0.2);
      border-radius: 10px;
      overflow: hidden;
    }
    
    .ec-forecast-panel {
      padding: 0.75rem 1rem;
    }
    
    .ec-forecast-loading {
      text-align: center;
      color: var(--mist-gray);
      padding: 1rem;
    }
    
    .ec-forecast-grid {
      display: flex;
      gap: 0.75rem;
      align-items: stretch;
    }
    
    .ec-forecast-card {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 6px;
      padding: 0.6rem 0.75rem;
      border-left: 3px solid var(--teal-accent);
      flex: 1;
    }
    
    .ec-forecast-card.warning {
      border-left-color: #ff6b6b;
      background: rgba(255, 107, 107, 0.1);
    }
    
    .ec-forecast-card.extended {
      border-left-color: rgba(0, 212, 170, 0.5);
    }
    
    .ec-forecast-card-title {
      font-family: 'Archivo Black', sans-serif;
      font-size: 0.65rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--teal-accent);
      margin-bottom: 0.3rem;
    }
    
    .ec-forecast-card.warning .ec-forecast-card-title {
      color: #ff6b6b;
    }
    
    .ec-forecast-card-content {
      font-size: 0.8rem;
      line-height: 1.4;
      color: rgba(255, 255, 255, 0.9);
    }
    
    .ec-forecast-wind {
      margin-bottom: 0.25rem;
    }
    
    .ec-forecast-weather {
      color: rgba(200, 200, 200, 0.8);
      font-size: 0.75rem;
    }
    
    .ec-forecast-meta {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem 1rem;
      background: rgba(0, 0, 0, 0.3);
      font-size: 0.65rem;
      color: var(--mist-gray);
    }
    
    .ec-forecast-link {
      color: var(--teal-accent);
      text-decoration: none;
    }
    
    .ec-forecast-link:hover {
      text-decoration: underline;
    }
    
    .ec-extended-forecasts {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.5rem;
      padding-top: 0.5rem;
      border-top: 1px solid rgba(0, 212, 170, 0.1);
    }
    
    .ec-extended-day {
      background: rgba(0, 0, 0, 0.15);
      border-radius: 5px;
      padding: 0.5rem 0.6rem;
      flex: 1;
    }
    
    .ec-extended-day-name {
      font-weight: 600;
      font-size: 0.65rem;
      color: var(--teal-accent);
      margin-bottom: 0.15rem;
    }
    
    .ec-extended-day-forecast {
      font-size: 0.7rem;
      color: rgba(200, 200, 200, 0.8);
      line-height: 1.3;
    }

    /* Main 3-Column Dashboard Grid */
    .main-dashboard-grid {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 1.5rem;
      margin-bottom: 2.5rem;
    }
    
    /* Narrows-only grid (2 columns) */
    .main-dashboard-grid.narrows-only-grid {
      grid-template-columns: 1fr 1fr;
    }

    /* Hourly Conditions Section - Full Width */
    .hourly-conditions-section {
      margin-bottom: 1.5rem;
    }

    .hourly-conditions-container {
      background: linear-gradient(135deg, rgba(20, 54, 84, 0.5), rgba(13, 33, 55, 0.7));
      border-radius: 12px;
      border: 1px solid rgba(0, 212, 170, 0.15);
      padding: 0.5rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.25rem;
    }

    .hourly-cell {
      flex: 1 1 calc(100% / 24 - 0.25rem);
      min-width: 52px;
      background: rgba(20, 54, 84, 0.4);
      border-radius: 6px;
      padding: 0.35rem 0.2rem;
      text-align: center;
      transition: all 0.2s ease;
      border: 1px solid transparent;
    }

    .hourly-cell:hover {
      background: rgba(20, 54, 84, 0.7);
      border-color: rgba(0, 212, 170, 0.3);
    }

    .hourly-cell.current {
      background: rgba(0, 212, 170, 0.15);
      border-color: var(--teal-accent);
    }

    .hourly-cell-time {
      font-size: 0.5rem;
      font-weight: 600;
      color: var(--mist-gray);
      margin-bottom: 0.15rem;
    }

    .hourly-cell-day {
      font-size: 0.45rem;
      color: rgba(0, 212, 170, 0.7);
      margin-bottom: 0.1rem;
      font-weight: 600;
    }

    .hourly-cell-icon {
      font-size: 1rem;
      line-height: 1;
      margin-bottom: 0.1rem;
    }

    .hourly-cell-temp {
      font-size: 0.6rem;
      font-weight: 600;
      color: var(--amber-warning);
      margin-bottom: 0.1rem;
    }

    .hourly-cell-wind {
      font-size: 0.55rem;
      font-weight: 600;
      margin-bottom: 0.05rem;
    }

    .hourly-cell-wind.light { color: #64b5f6; }
    .hourly-cell-wind.moderate { color: var(--teal-accent); }
    .hourly-cell-wind.fresh { color: var(--amber-warning); }
    .hourly-cell-wind.strong { color: var(--coral-alert); }

    .hourly-cell-wind-dir {
      font-size: 0.4rem;
      color: var(--mist-gray);
      margin-bottom: 0.1rem;
    }

    .hourly-cell-rain {
      font-size: 0.45rem;
      color: #64b5f6;
    }

    .hourly-cell-rain.none {
      color: var(--ocean-mid);
    }

    /* Large screens: 24 per row */
    @media (min-width: 1400px) {
      .hourly-cell {
        flex: 1 1 calc(100% / 24 - 0.25rem);
      }
    }

    /* Medium-large screens: 16 per row */
    @media (max-width: 1399px) and (min-width: 1100px) {
      .hourly-cell {
        flex: 1 1 calc(100% / 16 - 0.25rem);
      }
    }

    /* Medium screens: 12 per row */
    @media (max-width: 1099px) and (min-width: 800px) {
      .hourly-cell {
        flex: 1 1 calc(100% / 12 - 0.25rem);
      }
    }

    /* Small screens: 8 per row */
    @media (max-width: 799px) and (min-width: 550px) {
      .hourly-cell {
        flex: 1 1 calc(100% / 8 - 0.25rem);
      }
    }

    /* Extra small screens: 6 per row */
    @media (max-width: 549px) and (min-width: 400px) {
      .hourly-cell {
        flex: 1 1 calc(100% / 6 - 0.25rem);
      }
    }

    /* Tiny screens: 4 per row */
    @media (max-width: 399px) {
      .hourly-cell {
        flex: 1 1 calc(100% / 4 - 0.25rem);
      }
    }

    .dashboard-column {
      display: flex;
      flex-direction: column;
    }

    .dashboard-column .section-title {
      margin-bottom: 1rem;
    }

    .forecast-column .marine-forecast-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .narrows-column .narrows-panel {
      flex: 1;
    }

    .current-data-source {
      text-align: center;
      font-size: 0.6rem;
      padding: 0.4rem 0.6rem;
      margin-top: 0.5rem;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 4px;
      color: var(--teal-accent);
      cursor: help;
      transition: all 0.3s ease;
    }
    
    .current-data-source:hover {
      background: rgba(0, 212, 170, 0.1);
    }

    .narrows-source-link {
      text-align: center;
      margin-top: 0.75rem;
      font-size: 0.65rem;
      color: var(--mist-gray);
    }

    .narrows-source-link a {
      color: var(--teal-accent);
      text-decoration: none;
    }

    .narrows-source-link a:hover {
      text-decoration: underline;
    }

    /* Full-Width Second Narrows Layout */
    .second-narrows-section {
      margin-bottom: 1.5rem;
    }

    .narrows-full-width {
      background: linear-gradient(135deg, rgba(20, 54, 84, 0.6), rgba(13, 33, 55, 0.8));
      border: 1px solid rgba(0, 212, 170, 0.2);
      border-radius: 12px;
      padding: 1rem 1.25rem;
    }

    .narrows-fw-top {
      display: flex;
      gap: 2rem;
      align-items: center;
      padding-bottom: 1rem;
      border-bottom: 1px solid rgba(0, 212, 170, 0.15);
      margin-bottom: 1rem;
      flex-wrap: wrap;
    }

    .narrows-fw-status {
      display: flex;
      align-items: center;
      gap: 1rem;
      min-width: 220px;
    }

    .fw-arrow-container {
      width: 64px;
      height: 64px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    .fw-arrow-container .current-ring {
      position: absolute;
      width: 100%;
      height: 100%;
      border: 2px solid rgba(0, 212, 170, 0.3);
      border-radius: 50%;
    }

    .fw-arrow-container .current-arrow {
      width: 36px;
      height: 36px;
    }

    .fw-state-info {
      text-align: left;
    }

    .fw-state-info .current-state {
      font-family: 'Archivo Black', sans-serif;
      font-size: 1rem;
      letter-spacing: 0.1em;
      margin-bottom: 0.15rem;
    }

    .fw-speed {
      font-family: 'Archivo Black', sans-serif;
      font-size: 2rem;
      color: var(--foam-white);
      line-height: 1;
      margin-bottom: 0.25rem;
    }

    .fw-speed .unit {
      font-size: 0.9rem;
      color: var(--mist-gray);
      font-family: 'IBM Plex Mono', monospace;
    }

    .fw-direction {
      font-size: 0.75rem;
      color: var(--mist-gray);
    }

    .narrows-fw-timeline {
      flex: 1;
      min-width: 200px;
    }

    .narrows-fw-timeline .timeline-label {
      font-size: 0.6rem;
      color: var(--mist-gray);
      margin-bottom: 0.4rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .narrows-fw-timeline .timeline-bar {
      height: 10px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 5px;
      position: relative;
      overflow: hidden;
      margin-bottom: 0.4rem;
    }

    .narrows-fw-timeline .timeline-progress {
      height: 100%;
      border-radius: 5px;
      transition: width 0.5s ease;
    }

    .narrows-fw-timeline .timeline-marker {
      position: absolute;
      top: -3px;
      width: 4px;
      height: 16px;
      background: var(--foam-white);
      border-radius: 2px;
      transform: translateX(-50%);
      box-shadow: 0 0 6px rgba(255, 255, 255, 0.5);
    }

    .fw-data-source {
      font-size: 0.6rem;
      color: var(--teal-accent);
    }

    .narrows-fw-events {
      min-width: 180px;
    }

    .fw-events-title {
      font-size: 0.6rem;
      color: var(--mist-gray);
      margin-bottom: 0.4rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .narrows-fw-events .current-events {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }

    .narrows-fw-events .current-event {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 4px;
      padding: 0.35rem 0.5rem;
      font-size: 0.7rem;
    }

    .narrows-fw-events .event-time {
      color: var(--mist-gray);
    }

    .narrows-fw-events .event-type {
      font-weight: 600;
    }

    .narrows-fw-events .event-type.max-flood { color: var(--teal-accent); }
    .narrows-fw-events .event-type.max-ebb { color: var(--coral-alert); }

    .narrows-fw-events .event-speed {
      color: var(--foam-white);
      margin-left: auto;
    }

    .narrows-fw-windows {
      margin-top: 0;
    }

    .narrows-fw-windows .slack-windows {
      margin-top: 0;
    }

    /* Responsive */
    @media (max-width: 900px) {
      .narrows-fw-top {
        flex-direction: column;
        align-items: stretch;
        gap: 1rem;
      }

      .narrows-fw-status {
        justify-content: center;
      }

      .narrows-fw-events {
        width: 100%;
      }

      .narrows-fw-events .current-events {
        flex-direction: row;
        flex-wrap: wrap;
      }
    }

    /* Tablet: 2 columns (forecast full width on top, narrows side by side below) */
    @media (max-width: 1200px) {
      .main-dashboard-grid {
        grid-template-columns: 1fr 1fr;
      }
      
      .main-dashboard-grid.narrows-only-grid {
        grid-template-columns: 1fr 1fr;
      }
      
      .forecast-column {
        grid-column: 1 / -1;
      }
    }

    /* Mobile: 1 column */
    @media (max-width: 768px) {
      .main-dashboard-grid {
        grid-template-columns: 1fr;
      }
      
      .main-dashboard-grid.narrows-only-grid {
        grid-template-columns: 1fr;
      }
      
      .forecast-column {
        grid-column: auto;
      }
      
      .forecast-hours-grid {
        grid-template-columns: repeat(6, 1fr);
      }
    }
    
    @media (max-width: 480px) {
      .forecast-hours-grid {
        grid-template-columns: repeat(4, 1fr);
      }
    }

    .marine-alert {
      background: linear-gradient(90deg, rgba(0, 212, 170, 0.1), transparent);
      border-left: 3px solid var(--teal-accent);
      padding: 0.6rem 1rem;
      margin-bottom: 1rem;
      border-radius: 0 6px 6px 0;
    }

    .marine-alert a { color: var(--teal-accent); text-decoration: none; }
    .marine-alert a:hover { text-decoration: underline; }

    .alert-title {
      font-weight: 600;
      color: var(--teal-accent);
      font-size: 0.7rem;
      margin-bottom: 0.25rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    .alert-text {
      font-family: 'Source Serif 4', serif;
      font-size: 0.85rem;
      color: var(--foam-white);
      line-height: 1.5;
    }

    /* 3-Day Marine Forecast Styles */
    .marine-forecast-container {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .forecast-day-panel {
      background: rgba(13, 33, 55, 0.5);
      border-radius: 12px;
      border: 1px solid rgba(0, 212, 170, 0.1);
      overflow: hidden;
    }

    .forecast-day-header {
      background: rgba(0, 212, 170, 0.1);
      padding: 0.6rem 0.75rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid rgba(0, 212, 170, 0.1);
    }

    .forecast-day-name {
      font-family: 'Archivo Black', sans-serif;
      font-size: 0.75rem;
      color: var(--foam-white);
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    .forecast-day-summary {
      font-size: 0.6rem;
      color: var(--mist-gray);
    }

    .forecast-hours-grid {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      gap: 0.25rem;
      padding: 0.5rem;
    }

    .forecast-hour-cell {
      background: rgba(20, 54, 84, 0.4);
      border-radius: 6px;
      padding: 0.4rem 0.25rem;
      text-align: center;
      transition: all 0.2s ease;
      border: 1px solid transparent;
    }

    .forecast-hour-cell:hover {
      background: rgba(20, 54, 84, 0.7);
      border-color: rgba(0, 212, 170, 0.3);
    }

    .forecast-hour-cell.current {
      background: rgba(0, 212, 170, 0.15);
      border-color: var(--teal-accent);
    }

    .hour-cell-time {
      font-size: 0.55rem;
      font-weight: 600;
      color: var(--mist-gray);
      margin-bottom: 0.2rem;
    }

    .hour-cell-icon {
      font-size: 1.2rem;
      line-height: 1;
      margin-bottom: 0.15rem;
    }

    .hour-cell-temp {
      font-size: 0.7rem;
      font-weight: 600;
      color: var(--amber-warning);
      margin-bottom: 0.15rem;
    }

    .hour-cell-wind {
      font-size: 0.65rem;
      font-weight: 600;
      margin-bottom: 0.1rem;
    }

    .hour-cell-wind.light { color: #64b5f6; }
    .hour-cell-wind.moderate { color: var(--teal-accent); }
    .hour-cell-wind.fresh { color: var(--amber-warning); }
    .hour-cell-wind.strong { color: var(--coral-alert); }

    .hour-cell-wind-dir {
      font-size: 0.45rem;
      color: var(--mist-gray);
      margin-bottom: 0.15rem;
    }

    .hour-cell-rain {
      font-size: 0.5rem;
      color: #64b5f6;
    }

    .hour-cell-rain.none {
      color: var(--ocean-mid);
    }

    /* PPA Marine Traffic Section */
    .ppa-traffic-section {
      margin-bottom: 2.5rem;
    }

    .ppa-traffic-container {
      background: linear-gradient(135deg, rgba(20, 54, 84, 0.5), rgba(13, 33, 55, 0.7));
      border-radius: 12px;
      padding: 1.25rem;
      border: 1px solid rgba(0, 212, 170, 0.15);
    }

    .ppa-quick-access {
      display: flex;
      align-items: center;
      gap: 1.25rem;
    }

    .ppa-icon {
      font-size: 2.5rem;
      background: rgba(0, 212, 170, 0.1);
      padding: 1rem;
      border-radius: 12px;
      line-height: 1;
    }

    .ppa-access-content {
      flex: 1;
    }

    .ppa-description {
      color: var(--mist-gray);
      font-size: 0.85rem;
      margin-bottom: 0.75rem;
      line-height: 1.4;
    }

    .ppa-external-link {
      display: inline-block;
      padding: 0.6rem 1.25rem;
      background: linear-gradient(135deg, var(--teal-accent), var(--ocean-mid));
      color: var(--deep-navy);
      text-decoration: none;
      border-radius: 8px;
      font-weight: 600;
      font-size: 0.85rem;
      transition: all 0.2s ease;
    }

    .ppa-external-link:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(0, 212, 170, 0.3);
    }

    @media (max-width: 768px) {
      .ppa-quick-access {
        flex-direction: column;
        text-align: center;
      }
    }

    /* Vessel Traffic Map Section */
    .vessel-traffic-section {
      margin-bottom: 2.5rem;
    }

    .vessel-map-container {
      background: linear-gradient(135deg, rgba(20, 54, 84, 0.5), rgba(13, 33, 55, 0.7));
      border-radius: 12px;
      padding: 1rem;
      border: 1px solid rgba(0, 212, 170, 0.15);
    }

    .vessel-map-wrapper {
      width: 100%;
      height: 400px;
      border-radius: 8px;
      overflow: hidden;
      background: #0a1929;
    }

    .vessel-map-wrapper iframe {
      width: 100%;
      height: 100%;
      border: none;
    }

    .vessel-map-legend {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      padding: 0.75rem 0;
      margin-top: 0.75rem;
      border-top: 1px solid rgba(0, 212, 170, 0.1);
      justify-content: center;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 0.35rem;
      font-size: 0.7rem;
      color: var(--mist-gray);
    }

    .legend-color {
      width: 12px;
      height: 12px;
      border-radius: 2px;
    }

    .legend-color.cargo { background: #76a82f; }
    .legend-color.tanker { background: #d32f2f; }
    .legend-color.passenger { background: #1976d2; }
    .legend-color.tug { background: #00bcd4; }
    .legend-color.fishing { background: #ff9800; }
    .legend-color.pleasure { background: #9c27b0; }

    .vessel-map-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 0.5rem;
      padding-top: 0.5rem;
    }

    .map-info-text {
      font-size: 0.65rem;
      color: var(--mist-gray);
    }

    .map-source-links {
      font-size: 0.65rem;
    }

    .map-source-links a {
      color: var(--teal-accent);
      text-decoration: none;
    }

    .map-source-links a:hover {
      text-decoration: underline;
    }

    .vessel-traffic-note {
      margin-top: 0.75rem;
      padding: 0.75rem 1rem;
      background: rgba(0, 212, 170, 0.05);
      border-left: 3px solid var(--teal-accent);
      border-radius: 0 8px 8px 0;
      font-size: 0.75rem;
      color: var(--mist-gray);
      line-height: 1.5;
    }
    
    .vessel-traffic-note strong {
      color: var(--seafoam);
    }

    @media (max-width: 768px) {
      .vessel-map-wrapper {
        height: 300px;
      }
      
      .vessel-map-legend {
        gap: 0.5rem;
      }
      
      .vessel-map-info {
        flex-direction: column;
        align-items: flex-start;
      }
    }

    .tide-section { margin-bottom: 2.5rem; }

    .tide-station-panel {
      background: linear-gradient(135deg, rgba(20, 54, 84, 0.5), rgba(13, 33, 55, 0.7));
      border-radius: 12px;
      padding: 1rem;
      margin-bottom: 1rem;
      border: 1px solid rgba(0, 212, 170, 0.15);
    }

    .source-stations-details {
      margin-top: 1rem;
    }

    .source-stations-summary {
      font-family: 'Inter', sans-serif;
      font-size: 0.75rem;
      color: var(--mist-gray);
      cursor: pointer;
      padding: 0.5rem 0;
      border-bottom: 1px solid rgba(0, 212, 170, 0.1);
      margin-bottom: 0.5rem;
      user-select: none;
    }

    .source-stations-summary:hover {
      color: var(--teal-accent);
    }

    .source-stations-details[open] .source-stations-summary {
      margin-bottom: 0.75rem;
    }

    .source-stations-details .tide-station-panel {
      opacity: 0.85;
      transform: scale(0.98);
    }

    .source-stations-details .tide-graph-container {
      height: 120px;
    }

    .tide-station-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.75rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid rgba(0, 212, 170, 0.1);
    }

    .tide-station-name {
      font-family: 'Archivo Black', sans-serif;
      font-size: 0.9rem;
      color: var(--foam-white);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .tide-station-location {
      font-size: 0.65rem;
      color: var(--mist-gray);
    }

    .tide-graph-container {
      position: relative;
      height: 140px;
      margin-bottom: 0.5rem;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 8px;
      overflow: hidden;
    }

    .tide-graph {
      width: 100%;
      height: 100%;
      cursor: crosshair;
    }

    .tide-graph-now-marker {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 2px;
      background: var(--coral-alert);
      box-shadow: 0 0 8px var(--coral-alert);
      z-index: 10;
    }

    .tide-graph-now-marker::before {
      content: 'NOW';
      position: absolute;
      top: 2px;
      left: 4px;
      font-size: 0.45rem;
      color: var(--coral-alert);
      font-weight: 600;
      letter-spacing: 0.05em;
    }

    .tide-events-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(70px, 1fr));
      gap: 0.35rem;
    }

    .tide-event-card {
      background: rgba(0, 0, 0, 0.25);
      border-radius: 6px;
      padding: 0.4rem 0.25rem;
      text-align: center;
      border-left: 3px solid transparent;
    }

    .tide-event-card.high {
      border-left-color: var(--teal-accent);
    }

    .tide-event-card.low {
      border-left-color: var(--coral-alert);
    }

    .tide-event-card.next {
      background: rgba(0, 212, 170, 0.15);
    }

    .tide-event-time {
      font-size: 0.55rem;
      color: var(--mist-gray);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 0.2rem;
    }

    .tide-event-type {
      font-family: 'Archivo Black', sans-serif;
      font-size: 0.7rem;
      margin-bottom: 0.2rem;
    }

    .tide-event-type.high { color: var(--teal-accent); }
    .tide-event-type.low { color: var(--coral-alert); }

    .tide-event-height {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--foam-white);
      line-height: 1.2;
    }

    .tide-event-height-ft {
      font-size: 0.6rem;
      color: var(--mist-gray);
    }

    .tide-source-link {
      text-align: center;
      font-size: 0.65rem;
      color: var(--mist-gray);
      margin-top: 0.5rem;
    }

    .tide-source-link a {
      color: var(--teal-accent);
      text-decoration: none;
    }

    .tide-source-link a:hover {
      text-decoration: underline;
    }

    /* Current Section Styles */
    .narrows-panel {
      background: linear-gradient(135deg, rgba(20, 54, 84, 0.5), rgba(13, 33, 55, 0.7));
      border-radius: 12px;
      padding: 1rem;
      border: 1px solid rgba(0, 212, 170, 0.15);
    }

    .narrows-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.75rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid rgba(0, 212, 170, 0.1);
    }

    .narrows-name {
      font-family: 'Archivo Black', sans-serif;
      font-size: 0.85rem;
      color: var(--foam-white);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .narrows-location {
      font-size: 0.6rem;
      color: var(--mist-gray);
    }

    /* Current Status Display */
    .current-status {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin-bottom: 1rem;
    }

    .current-arrow-container {
      width: 60px;
      height: 60px;
      min-width: 60px;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .current-ring {
      position: absolute;
      width: 100%;
      height: 100%;
      border: 2px solid rgba(0, 212, 170, 0.3);
      border-radius: 50%;
    }

    .current-arrow {
      width: 45px;
      height: 45px;
      transition: transform 0.5s ease;
    }

    .current-arrow.flood { color: var(--teal-accent); }
    .current-arrow.ebb { color: var(--coral-alert); }
    .current-arrow.slack { color: var(--mist-gray); }

    .current-info {
      flex: 1;
      min-width: 0;
    }

    .current-state {
      font-family: 'Archivo Black', sans-serif;
      font-size: 1.1rem;
      margin-bottom: 0.15rem;
    }

    .current-state.flood { color: var(--teal-accent); }
    .current-state.ebb { color: var(--coral-alert); }
    .current-state.slack { color: var(--amber-warning); }

    .current-speed {
      font-size: 1.5rem;
      font-weight: 600;
      color: var(--foam-white);
      line-height: 1;
    }

    .current-speed .unit {
      font-size: 0.8rem;
      color: var(--mist-gray);
      font-weight: 400;
    }

    .current-direction {
      font-size: 0.65rem;
      color: var(--mist-gray);
      margin-top: 0.2rem;
    }

    /* Current Timeline */
    .current-timeline {
      margin-top: 1rem;
    }

    .timeline-label {
      font-size: 0.6rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--mist-gray);
      margin-bottom: 0.5rem;
    }

    .timeline-bar {
      height: 8px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 4px;
      position: relative;
      overflow: hidden;
    }

    .timeline-progress {
      position: absolute;
      height: 100%;
      border-radius: 4px;
      transition: width 0.5s ease;
    }

    .timeline-progress.flood {
      background: linear-gradient(90deg, var(--teal-accent), rgba(0, 212, 170, 0.5));
    }

    .timeline-progress.ebb {
      background: linear-gradient(90deg, var(--coral-alert), rgba(255, 107, 107, 0.5));
    }

    .timeline-marker {
      position: absolute;
      top: -4px;
      width: 2px;
      height: 16px;
      background: var(--foam-white);
      border-radius: 1px;
    }

    /* Current Events List */
    .current-events {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 0.5rem;
      margin-top: 1rem;
    }

    .current-event {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 8px;
      padding: 0.6rem 0.75rem;
      display: flex;
      flex-direction: column;
    }

    .event-time {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--foam-white);
    }

    .event-type {
      font-size: 0.6rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-top: 0.15rem;
    }

    .event-type.slack { color: var(--amber-warning); }
    .event-type.max-flood { color: var(--teal-accent); }
    .event-type.max-ebb { color: var(--coral-alert); }

    .event-speed {
      font-size: 0.75rem;
      color: var(--mist-gray);
      margin-top: 0.1rem;
    }

    /* Slack Window Visual Timeline */
    .slack-windows {
      margin-top: 1rem;
      padding-top: 0.75rem;
      border-top: 1px solid rgba(0, 212, 170, 0.1);
    }

    .slack-windows-title {
      font-size: 0.6rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--mist-gray);
      margin-bottom: 0.5rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .slack-windows-title::before {
      content: 'â—ˆ';
      color: var(--amber-warning);
    }

    .window-card {
      background: rgba(0, 0, 0, 0.25);
      border-radius: 8px;
      padding: 0.6rem;
      margin-bottom: 0.5rem;
      border-left: 3px solid var(--amber-warning);
    }

    .window-card.active {
      background: rgba(255, 170, 0, 0.15);
      border-left-color: var(--teal-glow);
    }

    .window-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.4rem;
      flex-wrap: wrap;
      gap: 0.25rem;
    }

    .window-type {
      font-family: 'Archivo Black', sans-serif;
      font-size: 0.65rem;
      color: var(--amber-warning);
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }

    .window-card.active .window-type {
      color: var(--teal-glow);
    }

    .window-badge {
      font-size: 0.5rem;
      padding: 0.15rem 0.4rem;
      border-radius: 4px;
      background: rgba(0, 212, 170, 0.2);
      color: var(--teal-accent);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .window-card.active .window-badge {
      background: var(--teal-accent);
      color: var(--deep-navy);
      font-weight: 600;
    }

    .window-visual {
      position: relative;
      height: 24px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 4px;
      margin: 0.4rem 0;
      overflow: hidden;
    }

    .window-safe-zone {
      position: absolute;
      height: 100%;
      background: linear-gradient(90deg, 
        rgba(255, 170, 0, 0.1), 
        rgba(255, 170, 0, 0.3), 
        rgba(255, 170, 0, 0.3),
        rgba(255, 170, 0, 0.1)
      );
      border-left: 2px solid var(--amber-warning);
      border-right: 2px solid var(--amber-warning);
    }

    .window-slack-marker {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 2px;
      background: var(--foam-white);
      box-shadow: 0 0 6px rgba(255, 255, 255, 0.5);
    }

    .window-now-marker {
      position: absolute;
      top: -3px;
      bottom: -3px;
      width: 2px;
      background: var(--teal-glow);
      box-shadow: 0 0 8px var(--teal-glow);
      z-index: 10;
    }

    .window-now-marker::before {
      content: 'NOW';
      position: absolute;
      top: -12px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.4rem;
      color: var(--teal-glow);
      font-weight: 600;
      letter-spacing: 0.05em;
    }

    .window-flood-zone {
      position: absolute;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(0, 212, 170, 0.15));
    }

    .window-ebb-zone {
      position: absolute;
      height: 100%;
      background: linear-gradient(90deg, rgba(255, 107, 107, 0.15), transparent);
    }

    .window-times {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      font-size: 0.6rem;
      margin-top: 0.3rem;
    }

    .window-time-block {
      text-align: center;
    }

    .window-time-block.center {
      flex: 1;
    }

    .window-time-label {
      font-size: 0.4rem;
      color: var(--mist-gray);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .window-time-value {
      font-weight: 600;
      color: var(--foam-white);
      font-size: 0.75rem;
    }

    .window-time-value.slack {
      color: var(--amber-warning);
    }

    .window-duration {
      font-size: 0.55rem;
      color: var(--mist-gray);
      text-align: center;
      margin-top: 0.25rem;
    }

    .window-duration strong {
      color: var(--amber-warning);
      font-weight: 600;
    }

    .footer {
      padding: 2rem 3rem;
      border-top: 1px solid rgba(0, 212, 170, 0.1);
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.7rem;
      color: var(--mist-gray);
      flex-wrap: wrap;
      gap: 1rem;
    }

    .data-sources { display: flex; gap: 2rem; flex-wrap: wrap; }
    .data-source { display: flex; align-items: center; gap: 0.5rem; }
    .source-dot { width: 6px; height: 6px; border-radius: 50%; background: var(--teal-accent); animation: pulse 2s infinite; }
    .refresh-info { font-size: 0.65rem; color: var(--mist-gray); cursor: pointer; }
    .refresh-info:hover { color: var(--teal-accent); }

    @media (max-width: 1200px) { .current-hero { grid-template-columns: 1fr 1fr; } }

    @media (max-width: 768px) {
      .header { flex-direction: column; gap: 1rem; padding: 1.5rem; }
      .header-info { text-align: center; }
      .last-update { justify-content: center; }
      .current-hero { grid-template-columns: 1fr; }
      .main-content { padding: 1.5rem; }
      .card-value { font-size: 2.5rem; }
      .forecast-grid { grid-template-columns: repeat(auto-fill, minmax(75px, 1fr)); }
    }

    .error-message {
      background: linear-gradient(90deg, rgba(255, 107, 107, 0.15), transparent);
      border-left: 4px solid var(--coral-alert);
      padding: 1.5rem;
      margin: 2rem 3rem;
      border-radius: 0 8px 8px 0;
      color: var(--foam-white);
    }

    .error-message h3 { color: var(--coral-alert); margin-bottom: 0.5rem; font-family: 'Archivo Black', sans-serif; font-size: 1rem; }
    .error-message a { color: var(--teal-accent); }

    .retry-btn {
      margin-top: 1rem;
      padding: 0.75rem 1.5rem;
      background: var(--teal-accent);
      color: var(--deep-navy);
      border: none;
      border-radius: 8px;
      font-family: 'IBM Plex Mono', monospace;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }

    .retry-btn:hover { background: var(--teal-glow); transform: translateY(-2px); }
  </style>
</head>
<body>
  <div class="ocean-bg"></div>
  <div class="wave-pattern"></div>

  <div class="loading" id="loadingState">
    <div class="loading-spinner"></div>
    <div class="loading-text">ACQUIRING ENVIRONMENTAL DATA...</div>
  </div>

  <div id="errorState" style="display: none;"></div>

  <header class="header">
    <div class="logo-section">
      <div class="logo-icon">âš“</div>
      <div class="logo-text">
        <h1>Seaforth Environmental<span>Dispatch Dashboard</span></h1>
      </div>
    </div>
    <div class="header-info">
      <div class="location">Vancouver, British Columbia</div>
      <div class="coordinates">49.30Â°N Â· 123.11Â°W</div>
      <div class="last-update">
        <span class="live-indicator"></span>
        <span>Last updated: <span id="updateTime">â€”</span></span>
      </div>
    </div>
  </header>

  <main class="main-content" id="mainContent">
    <!-- New Unified Status Bar - Everything in 1 row -->
    <section class="unified-status-bar">
      <div class="status-card wind-status">
        <div class="status-label">Wind</div>
        <div class="status-value"><span id="currentWind2">â€”</span> <span class="status-unit">kts</span></div>
        <div class="status-wind-dir">
          <div class="mini-compass"><div class="mini-needle" id="miniNeedle"></div></div>
          <span id="windDirText2">â€”</span>
        </div>
        <div class="status-detail">Gusts <span id="currentGust2">â€”</span> kts</div>
      </div>
      <div class="status-card temp-status">
        <div class="status-label">Temp</div>
        <div class="status-value temp"><span id="currentTemp2">â€”</span><span class="status-unit">Â°C</span></div>
        <div class="status-detail"><span id="currentHumidity2">â€”</span>% Â· <span id="feelsLike2">â€”</span>Â°C</div>
      </div>
      <div class="status-card conditions-status">
        <div class="status-label">Conditions</div>
        <div class="status-value conditions" id="currentConditions2">â€”</div>
        <div class="status-detail"><span id="cloudCover2">â€”</span>% Â· <span id="pressure2">â€”</span> hPa</div>
      </div>
      <div class="status-card ppa-status">
        <div class="inline-ppa">
          <div class="ppa-status-icon">ðŸš¢</div>
          <div class="ppa-status-content">
            <div class="ppa-status-title">PPA Vessel Movements</div>
            <div class="ppa-status-desc">Scheduled pilot assignments & harbour transits</div>
            <a href="https://ppaportal.portlink.co/mt-tm" target="_blank" class="ppa-status-link">Open PPA Portal â†’</a>
          </div>
        </div>
      </div>
    </section>

    <!-- Old sections hidden by CSS -->
    <section class="current-hero">
      <div class="hero-card wind-card">
        <div class="card-label">Current Wind</div>
        <div class="card-value"><span id="currentWind">â€”</span> <span class="card-unit">kts</span></div>
        <div class="wind-direction">
          <div class="compass"><div class="compass-needle" id="compassNeedle"></div></div>
          <span id="windDirText">â€”</span>
        </div>
        <div class="card-detail">Gusts to <span id="currentGust">â€”</span> kts</div>
      </div>
      <div class="hero-card temp-card">
        <div class="card-label">Temperature</div>
        <div class="card-value"><span id="currentTemp">â€”</span><span class="card-unit">Â°C</span></div>
        <div class="card-detail">Humidity: <span id="currentHumidity">â€”</span>%</div>
        <div class="card-detail">Feels like: <span id="feelsLike">â€”</span>Â°C</div>
      </div>
      <div class="hero-card conditions-card">
        <div class="card-label">Conditions</div>
        <div class="card-value" id="currentConditions">â€”</div>
        <div class="card-detail">Cloud Cover: <span id="cloudCover">â€”</span>%</div>
        <div class="card-detail">Barometer: <span id="pressure">â€”</span> hPa</div>
      </div>
    </section>
    
    <div class="weather-source-info">
      <span class="source-label">ðŸ“ Station:</span> <span id="weatherStation">â€”</span>
      <span class="source-separator">Â·</span>
      <span class="source-label">ðŸ“¡ Source:</span> <span id="weatherSource">â€”</span>
    </div>

    <section class="forecast-section">
      <div class="marine-alert">
        <div class="alert-title">ðŸ“¡ Live Data Feed</div>
        <div class="alert-text">
          Current conditions from <span id="alertSourceName">Environment Canada</span> weather station. Forecasts from Open-Meteo (GFS/ICON models).
          For official marine warnings: <a href="https://weather.gc.ca/marine/forecast_e.html?mapID=02&siteID=14305" target="_blank">Environment Canada Marine Forecasts</a>
        </div>
      </div>
    </section>
    
    <!-- Hourly Conditions - Full Width Above Narrows -->
    <section class="hourly-conditions-section">
      <h2 class="section-title">Hourly Conditions (48h)</h2>
      <div class="hourly-conditions-container" id="marineForecastContainer">
        <!-- Populated by JavaScript -->
      </div>
    </section>

    <!-- Tides â€” Second Narrows -->
    <section class="tide-section">
      <h2 class="section-title">Tides â€” Second Narrows</h2>
      <div class="tide-station-panel">
        <div class="tide-station-header">
          <div class="tide-station-name">Second Narrows</div>
          <div class="tide-station-location">Vancouver Harbour â€¢ Station 7735</div>
        </div>
        <div class="tide-graph-container">
          <canvas id="secondNarrowsTideGraph" class="tide-graph"></canvas>
          <div class="tide-graph-now-marker" id="secondNarrowsNowMarker"></div>
        </div>
      </div>
      <div class="tide-source-link">
        Data from CHS predictions. Official source: 
        <a href="https://tides.gc.ca/en/stations/7735" target="_blank">CHS Vancouver Harbour</a>
      </div>
    </section>

    <!-- Second Narrows Currents - Full Width -->
    <section class="second-narrows-section">
      <h2 class="section-title">Second Narrows Currents â€” Ironworkers Bridge</h2>
      <div class="narrows-full-width" id="secondNarrowsPanel">
        <div class="narrows-fw-top">
          <div class="narrows-fw-status">
            <div class="fw-arrow-container">
              <div class="current-ring"></div>
              <svg class="current-arrow flood" id="secondNarrowsArrow" viewBox="0 0 24 24" fill="currentColor">
                <path d="M12 2L4 12h5v10h6V12h5L12 2z"/>
              </svg>
            </div>
            <div class="fw-state-info">
              <div class="current-state flood" id="secondNarrowsState">FLOOD</div>
              <div class="fw-speed"><span id="secondNarrowsSpeed">2.1</span> <span class="unit">kts</span></div>
              <div class="fw-direction" id="secondNarrowsDir">Flowing E (090Â°) into harbour</div>
            </div>
          </div>
          <div class="narrows-fw-timeline">
            <div class="timeline-label">Current Cycle Progress</div>
            <div class="timeline-bar">
              <div class="timeline-progress flood" id="secondNarrowsProgress" style="width: 45%"></div>
              <div class="timeline-marker" id="secondNarrowsMarker" style="left: 45%"></div>
            </div>
            <div class="fw-data-source" id="secondNarrowsDataSource">â— Loading...</div>
          </div>
          <div class="narrows-fw-events">
            <div class="fw-events-title">Upcoming</div>
            <div class="current-events" id="secondNarrowsEvents"></div>
          </div>
        </div>
        <div class="narrows-fw-windows">
          <div class="slack-windows" id="secondNarrowsWindows"></div>
        </div>
      </div>
      <div class="narrows-source-link">
        <a href="http://www.dairiki.org/tides/daily.php/sec" target="_blank">XTide Data</a> Â· 
        <a href="https://tides.gc.ca/en/current-predictions-station" target="_blank">CHS Tables</a> Â·
        Station 07745
      </div>
    </section>

    <!-- Vessel Traffic Map Section -->
    <section class="vessel-traffic-section">
      <h2 class="section-title">Live Vessel Traffic â€” Vancouver Harbour</h2>
      <div class="vessel-map-container">
        <div class="vessel-map-wrapper" id="vesselMapWrapper">
          <!-- VesselFinder embed map -->
          <script type="text/javascript">
            var width="100%";
            var height="400";
            var latitude="49.31";
            var longitude="-123.12";
            var zoom="12";
            var names=true;
            var maptype=1;
          </script>
          <script type="text/javascript" src="https://www.vesselfinder.com/aismap.js"></script>
        </div>
        <div class="vessel-map-legend">
          <div class="legend-item"><span class="legend-color cargo"></span> Cargo</div>
          <div class="legend-item"><span class="legend-color tanker"></span> Tanker</div>
          <div class="legend-item"><span class="legend-color passenger"></span> Passenger</div>
          <div class="legend-item"><span class="legend-color tug"></span> Tug/Special</div>
          <div class="legend-item"><span class="legend-color fishing"></span> Fishing</div>
          <div class="legend-item"><span class="legend-color pleasure"></span> Pleasure</div>
        </div>
        <div class="vessel-map-info">
          <span class="map-info-text">Real-time AIS data â€¢ Click vessels for details â€¢ Drag to pan, scroll to zoom</span>
          <div class="map-source-links">
            <a href="https://www.vesselfinder.com/ports/CAVAN001" target="_blank">Port Arrivals</a> Â· 
            <a href="https://www.marinetraffic.com/en/ais/details/ports/682" target="_blank">MarineTraffic</a> Â· 
            <a href="https://www.portvancouver.com/port-operations/" target="_blank">Port Operations</a>
          </div>
        </div>
      </div>
    </section>

    <section class="tide-section">
      <h2 class="section-title">Tides â€” Steveston</h2>
      
      <!-- Steveston/Richmond Tides -->
      <div class="tide-station-panel">
        <div class="tide-station-header">
          <div class="tide-station-name">Steveston (Richmond)</div>
          <div class="tide-station-location">Fraser River Mouth â€¢ Station 7607</div>
        </div>
        <div class="tide-graph-container">
          <canvas id="stevestonTideGraph" class="tide-graph"></canvas>
          <div class="tide-graph-now-marker" id="stevestonNowMarker"></div>
        </div>
      </div>
      
      <div class="tide-source-link">
        Data from CHS predictions. Official source: 
        <a href="https://tides.gc.ca/en/stations/7607" target="_blank">CHS Steveston</a>
      </div>
    </section>

    <!-- Fraser River Water Levels Section -->
    <section class="tide-section">
      <h2 class="section-title">Fraser River â€” Water Levels & Velocities</h2>
      
      <!-- Interpolated km 20 -->
      <div class="tide-station-panel" style="border-color: var(--teal-accent);">
        <div class="tide-station-header">
          <div class="tide-station-name">South Arm â€” km 20 (Interpolated)</div>
          <div class="tide-station-location">Calculated from Steveston & New Westminster â€¢ <span id="fraserKm20Status" style="color: var(--mist-gray);">Loading...</span></div>
        </div>
        <div class="tide-graph-container">
          <canvas id="fraserKm20Graph" class="tide-graph"></canvas>
          <div class="tide-graph-now-marker" id="fraserKm20NowMarker"></div>
        </div>
      </div>
      
      <!-- Source stations (collapsible, closed by default) -->
      <details class="source-stations-details">
        <summary class="source-stations-summary">Source Stations (Steveston km 0 & New Westminster km 32)</summary>
        
        <!-- South Arm - Steveston -->
        <div class="tide-station-panel" style="margin-top: 0.5rem;">
          <div class="tide-station-header">
            <div class="tide-station-name">Steveston (South Arm)</div>
            <div class="tide-station-location">km 0 â€¢ River Mouth â€¢ <span id="fraserSouthStatus" style="color: var(--mist-gray);">Loading...</span></div>
          </div>
          <div class="tide-graph-container">
            <canvas id="fraserSouthGraph" class="tide-graph"></canvas>
            <div class="tide-graph-now-marker" id="fraserSouthNowMarker"></div>
          </div>
        </div>
        
        <!-- New Westminster -->
        <div class="tide-station-panel">
          <div class="tide-station-header">
            <div class="tide-station-name">New Westminster</div>
            <div class="tide-station-location">km 32 â€¢ Fraser Surrey Docks â€¢ <span id="fraserNorthStatus" style="color: var(--mist-gray);">Loading...</span></div>
          </div>
          <div class="tide-graph-container">
            <canvas id="fraserNorthGraph" class="tide-graph"></canvas>
            <div class="tide-graph-now-marker" id="fraserNorthNowMarker"></div>
          </div>
        </div>
      </details>
      
      <div class="tide-source-link">
        Water level predictions from Canadian Hydrographic Service (CHS). Velocity estimated from rate of change. Official sources: 
        <a href="https://tides.gc.ca/en/stations/07607" target="_blank">Steveston</a> | 
        <a href="https://tides.gc.ca/en/stations/07654" target="_blank">New Westminster</a> | 
        <a href="https://www2.pac.dfo-mpo.gc.ca/avdpth_srch-eng.html?page=pwl" target="_blank">Avadepth</a>
      </div>
    </section>
  </main>

  <footer class="footer">
    <div class="data-sources">
      <div class="data-source"><span class="source-dot"></span><span>Environment Canada SWOB</span></div>
      <div class="data-source"><span class="source-dot"></span><span>Open-Meteo Forecasts</span></div>
      <div class="data-source"><span class="source-dot"></span><span>CHS Tidal Predictions</span></div>
      <div class="data-source"><span class="source-dot"></span><span>CCG Avadepth</span></div>
    </div>
    <div>
      <div>Seaforth Environmental Dispatch Dashboard Â© 2026</div>
      <div class="refresh-info" id="refreshBtn">ðŸ”„ Click to refresh | Auto-refresh: 30 min</div>
    </div>
  </footer>

  <script>
    const CONFIG = { lat: 49.30, lon: -123.11, refreshInterval: 30 * 60 * 1000 };

    // Station info for display
    const CURRENT_HARMONICS = {
      firstNarrows: { floodDir: 90, ebbDir: 270 },
      secondNarrows: { floodDir: 90, ebbDir: 270 }
    };

    const weatherCodes = {
      0: 'Clear Sky', 1: 'Mainly Clear', 2: 'Partly Cloudy', 3: 'Overcast',
      45: 'Foggy', 48: 'Rime Fog', 51: 'Light Drizzle', 53: 'Drizzle', 55: 'Dense Drizzle',
      61: 'Slight Rain', 63: 'Moderate Rain', 65: 'Heavy Rain', 66: 'Freezing Rain', 67: 'Heavy Freezing Rain',
      71: 'Slight Snow', 73: 'Moderate Snow', 75: 'Heavy Snow', 77: 'Snow Grains',
      80: 'Rain Showers', 81: 'Moderate Showers', 82: 'Heavy Showers', 85: 'Snow Showers', 86: 'Heavy Snow Showers',
      95: 'Thunderstorm', 96: 'Thunderstorm + Hail', 99: 'Severe Thunderstorm'
    };

    const weatherIcons = {
      0: 'â˜€ï¸', 1: 'ðŸŒ¤ï¸', 2: 'â›…', 3: 'â˜ï¸', 45: 'ðŸŒ«ï¸', 48: 'ðŸŒ«ï¸',
      51: 'ðŸŒ¦ï¸', 53: 'ðŸŒ¦ï¸', 55: 'ðŸŒ§ï¸', 61: 'ðŸŒ§ï¸', 63: 'ðŸŒ§ï¸', 65: 'ðŸŒ§ï¸', 66: 'ðŸŒ¨ï¸', 67: 'ðŸŒ¨ï¸',
      71: 'ðŸŒ¨ï¸', 73: 'ðŸŒ¨ï¸', 75: 'â„ï¸', 77: 'ðŸŒ¨ï¸', 80: 'ðŸŒ¦ï¸', 81: 'ðŸŒ§ï¸', 82: 'â›ˆï¸',
      85: 'ðŸŒ¨ï¸', 86: 'ðŸŒ¨ï¸', 95: 'â›ˆï¸', 96: 'â›ˆï¸', 99: 'â›ˆï¸'
    };

    const msToKnots = ms => Math.round(ms * 1.944);
    const getWindDirection = deg => ['N','NNE','NE','ENE','E','ESE','SE','SSE','S','SSW','SW','WSW','W','WNW','NW','NNW'][Math.round(deg / 22.5) % 16];
    const getWindClass = kts => kts < 5 ? 'light' : kts < 12 ? 'moderate' : kts < 20 ? 'fresh' : 'strong';
    const formatTime = d => d.toLocaleTimeString('en-CA', { hour: '2-digit', minute: '2-digit', hour12: false });
    const formatDay = d => d.toLocaleDateString('en-CA', { weekday: 'short' });
    const formatDateTime = d => d.toLocaleString('en-CA', { day: '2-digit', month: 'short', year: 'numeric', hour: '2-digit', minute: '2-digit', timeZoneName: 'short' });

    function showError(msg) {
      document.getElementById('loadingState').style.display = 'none';
      document.getElementById('mainContent').classList.remove('loaded');
      const err = document.getElementById('errorState');
      err.style.display = 'block';
      err.innerHTML = `
        <div class="error-message">
          <h3>âš ï¸ Unable to Load Weather Data</h3>
          <p>${msg}</p>
          <p style="margin-top:1rem;font-size:0.85rem">This is often caused by browser security when opening the file directly (file:// protocol).</p>
          <p style="margin-top:0.75rem;font-size:0.85rem"><strong>Quick fixes:</strong></p>
          <ul style="margin:0.5rem 0 0 1.5rem;font-size:0.85rem;line-height:1.8">
            <li>Upload this file to any web hosting (GitHub Pages, Netlify, etc.)</li>
            <li>Run a local server: <code style="background:var(--ocean-mid);padding:2px 6px;border-radius:4px">python -m http.server 8000</code></li>
            <li>Or use these direct links for current data:</li>
          </ul>
          <p style="margin-top:1rem">
            <a href="https://www.windfinder.com/forecast/vancouver_harbour" target="_blank">â†’ Windfinder Vancouver Harbour</a><br>
            <a href="https://weather.gc.ca/marine/forecast_e.html?mapID=02&siteID=14305" target="_blank">â†’ Environment Canada Marine</a><br>
            <a href="https://tides.gc.ca/en/stations/7735" target="_blank">â†’ Canadian Tides - Vancouver</a>
          </p>
          <button class="retry-btn" onclick="initialize()">Try Again</button>
        </div>`;
    }

    // CORS Proxy for government APIs that don't support CORS
    // CORS proxy configuration with fallback options
    const CORS_PROXIES = [
      { url: 'https://corsproxy.io/?url=', encode: true },
      { url: 'https://api.allorigins.win/raw?url=', encode: true },
      { url: 'https://api.codetabs.com/v1/proxy?quest=', encode: true }
    ];
    
    let currentProxyIndex = 0;
    
    function withCorsProxy(url) {
      const proxy = CORS_PROXIES[currentProxyIndex];
      return proxy.url + (proxy.encode ? encodeURIComponent(url) : url);
    }
    
    // Try next proxy if current one fails
    function rotateProxy() {
      currentProxyIndex = (currentProxyIndex + 1) % CORS_PROXIES.length;
      console.log(`Rotating to CORS proxy: ${CORS_PROXIES[currentProxyIndex].url}`);
    }

    // Environment Canada Marine Forecast RSS Feed
    // Strait of Georgia - covers both north (14301) and south (14305) of Nanaimo
    const EC_MARINE_RSS = 'https://weather.gc.ca/rss/marine/14300_e.xml';
    
    async function fetchWithProxyFallback(url, maxRetries = 3) {
      let lastError;
      for (let i = 0; i < maxRetries; i++) {
        try {
          const res = await fetch(withCorsProxy(url));
          if (!res.ok) throw new Error(`Fetch failed: ${res.status}`);
          return res;
        } catch (err) {
          lastError = err;
          console.warn(`Proxy ${currentProxyIndex} failed, trying next...`, err.message);
          rotateProxy();
        }
      }
      throw lastError;
    }
    
    async function fetchECMarineForecast() {
      const container = document.getElementById('ecMarineForecast');
      const issuedEl = document.getElementById('ecForecastIssued');
      
      // NEW: Inline elements
      const inlineText = document.getElementById('inlineForecastText');
      const inlineExtended = document.getElementById('inlineForecastExtended');
      const inlineIssued = document.getElementById('inlineForecastIssued');
      
      try {
        // Use CORS proxy for Environment Canada (they don't allow cross-origin requests)
        const res = await fetchWithProxyFallback(EC_MARINE_RSS);
        // res.ok already checked in fetchWithProxyFallback
        
        const text = await res.text();
        const parser = new DOMParser();
        const xml = parser.parseFromString(text, 'text/xml');
        
        const entries = xml.querySelectorAll('entry');
        if (entries.length === 0) throw new Error('No forecast entries found');
        
        let html = '<div class="ec-forecast-grid">';
        let extendedForecasts = [];
        let issuedTime = '';
        let mainForecastText = '';
        
        entries.forEach((entry, idx) => {
          const title = entry.querySelector('title')?.textContent || '';
          const summary = entry.querySelector('summary')?.textContent || '';
          const updated = entry.querySelector('updated')?.textContent || '';
          
          // Extract issued time from summary
          const issuedMatch = summary.match(/Issued\s+(\d{1,2}:\d{2}\s+[AP]M\s+\w+\s+\d+\s+\w+\s+\d{4})/i);
          if (issuedMatch && !issuedTime) {
            issuedTime = issuedMatch[1];
          }
          
          // Check if this is for our area (14305 = south of Nanaimo)
          const id = entry.querySelector('id')?.textContent || '';
          const isSouthArea = id.includes('14305');
          
          if (isSouthArea) {
            // Parse the forecast content
            const cleanSummary = summary.replace(/<br\/?>/gi, '\n').replace(/Issued.*/i, '').trim();
            
            if (title.toLowerCase().includes('extended')) {
              // Extended forecast - parse individual days
              const days = cleanSummary.split('\n').filter(d => d.trim());
              days.forEach(day => {
                const dayMatch = day.match(/^(\w+):\s*(.+)$/);
                if (dayMatch) {
                  extendedForecasts.push({
                    day: dayMatch[1],
                    forecast: dayMatch[2]
                  });
                }
              });
            } else if (title.toLowerCase().includes('forecast for')) {
              // Main forecast
              const lines = cleanSummary.split('\n').filter(l => l.trim());
              const windLines = lines.filter(l => l.toLowerCase().includes('wind'));
              const weatherLines = lines.filter(l => !l.toLowerCase().includes('wind') && l.trim());
              
              mainForecastText = windLines.join(' ') + (weatherLines.length > 0 ? ' ' + weatherLines.join(' ') : '');
              
              html += `
                <div class="ec-forecast-card">
                  <div class="ec-forecast-card-title">Current Forecast</div>
                  <div class="ec-forecast-card-content">
                    <div class="ec-forecast-wind">${windLines.join(' ')}</div>
                    ${weatherLines.length > 0 ? `<div class="ec-forecast-weather">${weatherLines.join(' ')}</div>` : ''}
                  </div>
                </div>
              `;
            }
          }
        });
        
        html += '</div>';
        
        // Add extended forecasts
        if (extendedForecasts.length > 0) {
          html += '<div class="ec-extended-forecasts">';
          extendedForecasts.forEach(ef => {
            html += `
              <div class="ec-extended-day">
                <div class="ec-extended-day-name">${ef.day}</div>
                <div class="ec-extended-day-forecast">${ef.forecast}</div>
              </div>
            `;
          });
          html += '</div>';
        }
        
        container.innerHTML = html;
        issuedEl.textContent = issuedTime ? `Issued: ${issuedTime}` : '';
        
        // NEW: Update inline status bar
        inlineText.textContent = mainForecastText || 'Forecast unavailable';
        inlineIssued.textContent = issuedTime ? issuedTime : '';
        
        // Populate inline extended forecasts (first 3)
        const extSlice = extendedForecasts.slice(0, 3);
        inlineExtended.innerHTML = extSlice.map(ef => `
          <div class="inline-ext-day">
            <div class="inline-ext-name">${ef.day}</div>
            <div class="inline-ext-text">${ef.forecast}</div>
          </div>
        `).join('');
        
      } catch (e) {
        console.warn('EC Marine RSS fetch failed:', e);
        // Fallback to showing a link
        container.innerHTML = `
          <div class="ec-forecast-grid">
            <div class="ec-forecast-card">
              <div class="ec-forecast-card-title">Strait of Georgia â€” South of Nanaimo</div>
              <div class="ec-forecast-card-content">
                <p style="margin-bottom: 0.75rem;">Unable to load live forecast. This may be due to CORS restrictions.</p>
                <p><a href="https://weather.gc.ca/marine/forecast_e.html?mapID=02&siteID=14305" target="_blank" style="color: var(--teal-accent);">View Official EC Marine Forecast â†’</a></p>
              </div>
            </div>
          </div>
        `;
        issuedEl.textContent = '';
        
        // NEW: Inline fallback
        inlineText.textContent = 'Unable to load forecast';
        inlineIssued.textContent = '';
        inlineExtended.innerHTML = '';
      }
    }

    // Environment Canada SWOB (Surface Weather Observation) API for real station data
    // Using Vancouver Int'l Airport (CYVR) - the most complete local weather station
    const EC_STATION = 'CYVR';
    const EC_STATION_NAME = "Vancouver Int'l Airport (YVR)";
    
    async function fetchECWeatherData() {
      // Fetch current conditions from Environment Canada SWOB API
      const swobUrl = `https://api.weather.gc.ca/collections/swob-realtime/items?f=json&limit=1&sortby=-date_tm-value&url=${EC_STATION}`;
      
      try {
        // Use CORS proxy for Environment Canada API
        const res = await fetch(withCorsProxy(swobUrl));
        if (!res.ok) throw new Error(`EC API returned ${res.status}`);
        const data = await res.json();
        
        if (data.features && data.features.length > 0) {
          const props = data.features[0].properties;
          return {
            source: 'Environment Canada',
            station: EC_STATION_NAME,
            stationId: EC_STATION,
            current: {
              temperature_2m: parseFloat(props['air_temp-value']) || null,
              relative_humidity_2m: parseFloat(props['rel_hum-value']) || null,
              wind_speed_10m: parseFloat(props['avg_wnd_spd_10m_pst10mts-value']) || parseFloat(props['avg_wnd_spd_10m_mt58-pst10mts-value']) || null, // m/s
              wind_direction_10m: parseFloat(props['avg_wnd_dir_10m_pst10mts-value']) || parseFloat(props['avg_wnd_dir_10m_mt58-pst10mts-value']) || null,
              wind_gusts_10m: parseFloat(props['max_wnd_spd_10m_pst10mts-value']) || null, // m/s
              pressure_msl: parseFloat(props['mslp-value']) / 10 || null, // Convert to hPa
              visibility: parseFloat(props['vis-value']) || null,
              weather_code: 0, // EC doesn't use WMO codes directly
              cloud_cover: null,
              apparent_temperature: null,
              observation_time: props['date_tm-value']
            }
          };
        }
        throw new Error('No data in EC response');
      } catch (e) {
        console.warn('EC API failed, falling back to Open-Meteo:', e);
        return null;
      }
    }
    
    async function fetchOpenMeteoData() {
      const url = `https://api.open-meteo.com/v1/forecast?latitude=${CONFIG.lat}&longitude=${CONFIG.lon}&current=temperature_2m,relative_humidity_2m,apparent_temperature,weather_code,cloud_cover,pressure_msl,wind_speed_10m,wind_direction_10m,wind_gusts_10m&hourly=temperature_2m,weather_code,wind_speed_10m,wind_direction_10m,wind_gusts_10m,precipitation,cloud_cover&daily=weather_code,temperature_2m_max,temperature_2m_min,wind_speed_10m_max,wind_gusts_10m_max,precipitation_sum&timezone=America/Vancouver&forecast_days=7`;
      const res = await fetch(url);
      if (!res.ok) throw new Error(`Open-Meteo API returned ${res.status}`);
      const data = await res.json();
      return {
        source: 'Open-Meteo',
        station: 'Model Data (49.30Â°N, 123.11Â°W)',
        ...data
      };
    }
    
    async function fetchWeatherData() {
      // Try Environment Canada first for current conditions, then Open-Meteo for forecasts
      const [ecData, omData] = await Promise.all([
        fetchECWeatherData().catch(() => null),
        fetchOpenMeteoData()
      ]);
      
      // Combine: EC for current if available, Open-Meteo for forecasts
      if (ecData && ecData.current && ecData.current.temperature_2m !== null) {
        return {
          source: 'Environment Canada',
          station: ecData.station,
          current: {
            ...omData.current,
            ...ecData.current,
            // Keep wind in m/s for conversion (EC already provides m/s)
            wind_speed_10m: ecData.current.wind_speed_10m || omData.current.wind_speed_10m,
            wind_gusts_10m: ecData.current.wind_gusts_10m || omData.current.wind_gusts_10m,
            wind_direction_10m: ecData.current.wind_direction_10m || omData.current.wind_direction_10m,
            temperature_2m: ecData.current.temperature_2m,
            relative_humidity_2m: ecData.current.relative_humidity_2m || omData.current.relative_humidity_2m,
            pressure_msl: ecData.current.pressure_msl || omData.current.pressure_msl,
            weather_code: omData.current.weather_code, // Use Open-Meteo for conditions text
            cloud_cover: omData.current.cloud_cover,
            apparent_temperature: omData.current.apparent_temperature
          },
          hourly: omData.hourly,
          daily: omData.daily,
          hourly_units: omData.hourly_units
        };
      }
      
      // Fallback to Open-Meteo only
      return omData;
    }

    // XTide reference data for Second Narrows (Vancouver) tides - January 2026
    // Heights in feet, times in PST
    const SECOND_NARROWS_TIDE_DATA = {
      '2026-01-27': [
        { time: '01:36', height: 12.7, type: 'high' },
        { time: '05:14', height: 11.8, type: 'low' },
        { time: '10:53', height: 15.1, type: 'high' },
        { time: '19:02', height: 3.1, type: 'low' }
      ],
      '2026-01-28': [
        { time: '03:07', height: 13.9, type: 'high' },
        { time: '06:58', height: 12.9, type: 'low' },
        { time: '11:41', height: 14.8, type: 'high' },
        { time: '20:02', height: 2.3, type: 'low' }
      ],
      '2026-01-29': [
        { time: '04:07', height: 14.9, type: 'high' },
        { time: '08:39', height: 13.1, type: 'low' },
        { time: '12:44', height: 14.6, type: 'high' },
        { time: '21:02', height: 1.7, type: 'low' }
      ],
      '2026-01-30': [
        { time: '04:54', height: 15.5, type: 'high' },
        { time: '09:57', height: 12.7, type: 'low' },
        { time: '13:57', height: 14.5, type: 'high' },
        { time: '21:58', height: 1.1, type: 'low' }
      ],
      '2026-01-31': [
        { time: '05:35', height: 15.9, type: 'high' },
        { time: '10:55', height: 12.1, type: 'low' },
        { time: '15:07', height: 14.5, type: 'high' },
        { time: '22:49', height: 0.9, type: 'low' }
      ],
      '2026-02-01': [
        { time: '06:12', height: 16.1, type: 'high' },
        { time: '11:43', height: 11.5, type: 'low' },
        { time: '16:10', height: 14.6, type: 'high' },
        { time: '23:34', height: 1.0, type: 'low' }
      ],
      '2026-02-02': [
        { time: '06:46', height: 16.2, type: 'high' },
        { time: '12:24', height: 10.9, type: 'low' },
        { time: '17:07', height: 14.7, type: 'high' }
      ],
      '2026-02-03': [
        { time: '00:16', height: 1.4, type: 'low' },
        { time: '07:18', height: 16.1, type: 'high' },
        { time: '13:02', height: 10.4, type: 'low' },
        { time: '17:59', height: 14.7, type: 'high' }
      ],
      '2026-02-04': [
        { time: '00:55', height: 2.0, type: 'low' },
        { time: '07:49', height: 15.8, type: 'high' },
        { time: '13:38', height: 10.0, type: 'low' },
        { time: '18:49', height: 14.6, type: 'high' }
      ],
      '2026-02-05': [
        { time: '01:33', height: 2.8, type: 'low' },
        { time: '08:19', height: 15.4, type: 'high' },
        { time: '14:12', height: 9.8, type: 'low' },
        { time: '19:38', height: 14.4, type: 'high' }
      ],
      '2026-02-06': [
        { time: '02:10', height: 3.7, type: 'low' },
        { time: '08:49', height: 14.9, type: 'high' },
        { time: '14:47', height: 9.7, type: 'low' },
        { time: '20:28', height: 14.1, type: 'high' }
      ],
      '2026-02-07': [
        { time: '02:48', height: 4.7, type: 'low' },
        { time: '09:20', height: 14.3, type: 'high' },
        { time: '15:23', height: 9.8, type: 'low' },
        { time: '21:19', height: 13.7, type: 'high' }
      ],
      '2026-02-08': [
        { time: '03:28', height: 5.7, type: 'low' },
        { time: '09:53', height: 13.6, type: 'high' },
        { time: '16:03', height: 10.0, type: 'low' },
        { time: '22:14', height: 13.3, type: 'high' }
      ],
      '2026-02-09': [
        { time: '04:14', height: 6.8, type: 'low' },
        { time: '10:30', height: 12.9, type: 'high' },
        { time: '16:50', height: 10.2, type: 'low' },
        { time: '23:16', height: 12.9, type: 'high' }
      ],
      '2026-02-10': [
        { time: '05:10', height: 7.8, type: 'low' },
        { time: '11:15', height: 12.3, type: 'high' },
        { time: '17:48', height: 10.3, type: 'low' }
      ],
      '2026-02-11': [
        { time: '00:27', height: 12.6, type: 'high' },
        { time: '06:22', height: 8.6, type: 'low' },
        { time: '12:13', height: 11.9, type: 'high' },
        { time: '19:01', height: 10.1, type: 'low' }
      ],
      '2026-02-12': [
        { time: '01:47', height: 12.6, type: 'high' },
        { time: '07:49', height: 9.1, type: 'low' },
        { time: '13:26', height: 11.9, type: 'high' },
        { time: '20:20', height: 9.4, type: 'low' }
      ],
      '2026-02-13': [
        { time: '03:08', height: 12.9, type: 'high' },
        { time: '09:13', height: 9.1, type: 'low' },
        { time: '14:46', height: 12.4, type: 'high' },
        { time: '21:31', height: 8.3, type: 'low' }
      ],
      '2026-02-14': [
        { time: '04:19', height: 13.5, type: 'high' },
        { time: '10:22', height: 8.6, type: 'low' },
        { time: '15:55', height: 13.2, type: 'high' },
        { time: '22:32', height: 6.9, type: 'low' }
      ]
    };

    // Steveston tides - typically ~30 min later and slightly lower amplitude
    // CHS IWLS API for tide/water level data
    // Station IDs: Steveston = 07607, New Westminster = 07654
    const CHS_API_BASE = 'https://api-iwls.dfo-mpo.gc.ca/api/v1';
    const STATION_STEVESTON = '07607';
    const STATION_NEW_WESTMINSTER = '07654';
    
    // Avadepth velocity model coefficients for km 20 South Arm
    // Based on Avadepth hydrodynamic model output for different discharge scenarios
    // These coefficients model velocity = f(water_level_change, discharge, tidal_phase)
    const AVADEPTH_KM20_MODEL = {
      // Velocity scaling factor at km 20 (relates rate of water level change to velocity)
      // Calibrated from Avadepth tables for 600 mÂ³/s discharge scenario
      // Factor varies by discharge - higher flows mean higher downstream bias
      velocityScaleFactors: {
        600: 5.5,    // Winter low flow
        1000: 5.0,
        2000: 4.2,
        3000: 3.5,
        4000: 3.0,
        5000: 2.5,
        6000: 2.0,
        8000: 1.5,
        10000: 1.0   // Freshet - strong downstream, minimal tidal influence
      },
      // Downstream bias (m/s) added to account for river flow
      // At low tide, even during flood tide, river flow can overcome tidal push
      downstreamBias: {
        600: 0.1,
        1000: 0.15,
        2000: 0.25,
        3000: 0.35,
        4000: 0.45,
        5000: 0.55,
        6000: 0.65,
        8000: 0.85,
        10000: 1.1
      },
      // Maximum velocities observed at km 20 (m/s)
      maxDownstream: 2.1,  // Strong ebb + river flow
      maxUpstream: -0.9    // Strong flood can briefly overcome river
    };
    
    // Cache for fetched river data
    let fraserSouthData = null;
    let fraserNorthData = null;
    let fraserDataLastFetch = null;
    let currentHopeDischarge = 600; // Default winter value
    
    // Fetch current Fraser River discharge at Hope from Water Survey Canada
    async function fetchHopeDischarge() {
      try {
        // Water Survey Canada real-time data for Fraser River at Hope (08MF005)
        const url = 'https://wateroffice.ec.gc.ca/services/real_time_data/csv/inline?stations[]=08MF005&parameters[]=47&start_date=' + 
          new Date(Date.now() - 24*3600000).toISOString().split('T')[0];
        
        const response = await fetch(withCorsProxy(url));
        if (!response.ok) return 600; // Default to low flow
        
        const text = await response.text();
        const lines = text.trim().split('\n');
        
        // Parse CSV to get most recent discharge value
        for (let i = lines.length - 1; i > 0; i--) {
          const parts = lines[i].split(',');
          if (parts.length >= 3) {
            const value = parseFloat(parts[2]);
            if (!isNaN(value) && value > 0) {
              console.log(`Current Fraser discharge at Hope: ${value} mÂ³/s`);
              currentHopeDischarge = value;
              return value;
            }
          }
        }
        return 600; // Default winter low flow
      } catch (e) {
        console.warn('Failed to fetch Hope discharge, using default:', e);
        return 600;
      }
    }
    
    // Get the appropriate Avadepth discharge scenario based on actual discharge
    function getAvadepthDischargeScenario(actualDischarge) {
      // Avadepth has 9 scenarios: 600, 1000, 2000, 3000, 4000, 5000, 6000, 8000, 10000 mÂ³/s
      const scenarios = [600, 1000, 2000, 3000, 4000, 5000, 6000, 8000, 10000];
      
      // Find closest scenario
      let closest = scenarios[0];
      let minDiff = Math.abs(actualDischarge - scenarios[0]);
      
      for (const scenario of scenarios) {
        const diff = Math.abs(actualDischarge - scenario);
        if (diff < minDiff) {
          minDiff = diff;
          closest = scenario;
        }
      }
      
      return closest;
    }
    
    // Calculate km 20 velocity using Avadepth-calibrated model
    function calculateKm20Velocity(waterLevelChange, hoursDelta, discharge) {
      const scenario = getAvadepthDischargeScenario(discharge);
      const scaleFactor = AVADEPTH_KM20_MODEL.velocityScaleFactors[scenario];
      const bias = AVADEPTH_KM20_MODEL.downstreamBias[scenario];
      
      // Rate of water level change (m/hr)
      const rateOfChange = hoursDelta > 0 ? waterLevelChange / hoursDelta : 0;
      
      // Base velocity from tidal component
      // Negative rate of change (rising water) = upstream flow (negative velocity)
      // Positive rate of change (falling water) = downstream flow (positive velocity)
      let velocity = -rateOfChange * scaleFactor;
      
      // Add downstream bias from river discharge
      velocity += bias;
      
      // Clamp to realistic range
      velocity = Math.max(AVADEPTH_KM20_MODEL.maxUpstream, Math.min(AVADEPTH_KM20_MODEL.maxDownstream, velocity));
      
      return velocity;
    }
    
    // Fetch CHS water level predictions for a station
    async function fetchCHSWaterLevels(stationId, stationName) {
      try {
        const now = new Date();
        const from = new Date(now.getTime() - 24 * 3600000); // 24 hours ago
        const to = new Date(now.getTime() + 72 * 3600000); // 72 hours ahead
        
        const fromStr = from.toISOString();
        const toStr = to.toISOString();
        
        // Fetch predictions (wlp = water level predictions)
        const url = `${CHS_API_BASE}/stations/${stationId}/data?time-series-code=wlp&from=${fromStr}&to=${toStr}`;
        
        console.log(`Fetching CHS data for ${stationName}...`);
        const response = await fetch(withCorsProxy(url));
        
        if (!response.ok) {
          throw new Error(`CHS API returned ${response.status}`);
        }
        
        const data = await response.json();
        
        if (!data || !Array.isArray(data) || data.length === 0) {
          throw new Error('No data returned from CHS API');
        }
        
        // Transform to our format - group by date with hourly entries
        const transformed = {};
        
        data.forEach(point => {
          const time = new Date(point.eventDate);
          const dateStr = getLocalDateString(time);
          const timeStr = time.toLocaleTimeString('en-CA', { hour: '2-digit', minute: '2-digit', hour12: false });
          
          if (!transformed[dateStr]) {
            transformed[dateStr] = [];
          }
          
          // Water level in meters, calculate approximate velocity from rate of change
          transformed[dateStr].push({
            time: timeStr,
            level: point.value,
            timestamp: time.getTime()
          });
        });
        
        // Calculate velocities based on rate of water level change
        // Positive = water dropping (ebb/downstream), Negative = water rising (flood/upstream)
        Object.keys(transformed).forEach(dateStr => {
          const dayData = transformed[dateStr];
          dayData.sort((a, b) => a.timestamp - b.timestamp);
          
          for (let i = 0; i < dayData.length; i++) {
            if (i === 0) {
              // Use next point for first entry
              if (dayData.length > 1) {
                const dt = (dayData[1].timestamp - dayData[0].timestamp) / 3600000; // hours
                const dh = dayData[1].level - dayData[0].level;
                dayData[i].velocity = -dh / dt * 2.0; // Velocity scaled to match Avadepth observations
              } else {
                dayData[i].velocity = 0;
              }
            } else {
              const dt = (dayData[i].timestamp - dayData[i-1].timestamp) / 3600000;
              const dh = dayData[i].level - dayData[i-1].level;
              dayData[i].velocity = -dh / dt * 2.0;
            }
            // Clamp velocity to reasonable range
            dayData[i].velocity = Math.max(-2, Math.min(2, dayData[i].velocity));
          }
        });
        
        console.log(`Loaded ${data.length} points for ${stationName}`);
        return transformed;
        
      } catch (e) {
        console.error(`Failed to fetch CHS data for ${stationName}:`, e);
        return null;
      }
    }
    
    // Fetch both Fraser River stations
    async function fetchFraserRiverData() {
      // Only refetch if data is stale (>30 min old)
      const now = Date.now();
      if (fraserDataLastFetch && (now - fraserDataLastFetch) < 30 * 60 * 1000) {
        return { south: fraserSouthData, north: fraserNorthData, km20: avadepthVelocityData };
      }
      
      // Fetch CHS water levels and Hope discharge in parallel
      const [southData, northData, hopeDischarge] = await Promise.all([
        fetchCHSWaterLevels(STATION_STEVESTON, 'Steveston (South Arm)'),
        fetchCHSWaterLevels(STATION_NEW_WESTMINSTER, 'New Westminster (North Arm)'),
        fetchHopeDischarge()
      ]);
      
      if (southData) fraserSouthData = southData;
      if (northData) fraserNorthData = northData;
      fraserDataLastFetch = now;
      
      // Get appropriate Avadepth discharge scenario
      const dischargeScenario = getAvadepthDischargeScenario(hopeDischarge);
      console.log(`Using Avadepth discharge scenario: ${dischargeScenario} mÂ³/s (actual: ${hopeDischarge} mÂ³/s)`);
      
      // Use Avadepth-calibrated model for km 20 velocities
      if (southData) {
        km20Data = calculateKm20FromCHS(southData);
        console.log('Calculated km 20 data using Avadepth model');
      }
      
      return { south: fraserSouthData, north: fraserNorthData, km20: km20Data };
    }
    
    // Calculate km 20 data from CHS water levels using Avadepth-calibrated model
    function calculateKm20FromCHS(stevestonData) {
      const discharge = currentHopeDischarge;
      const scenario = getAvadepthDischargeScenario(discharge);
      
      console.log(`Calculating km 20 velocities for discharge scenario ${scenario} mÂ³/s`);
      
      // Flatten and sort Steveston data
      const flat = [];
      Object.keys(stevestonData).forEach(dateStr => {
        stevestonData[dateStr].forEach(point => {
          flat.push({ ...point, dateStr });
        });
      });
      flat.sort((a, b) => a.timestamp - b.timestamp);
      
      if (flat.length === 0) return null;
      
      // Tidal propagation delay from Steveston to km 20 (~45 min)
      const DELAY_MS = 45 * 60 * 1000;
      
      // Calculate km 20 data with velocity from Avadepth model
      const result = {};
      
      for (let i = 1; i < flat.length; i++) {
        const prev = flat[i - 1];
        const curr = flat[i];
        
        // Shift time for km 20
        const km20Time = new Date(curr.timestamp + DELAY_MS);
        const dateStr = getLocalDateString(km20Time);
        const timeStr = km20Time.toLocaleTimeString('en-CA', { hour: '2-digit', minute: '2-digit', hour12: false });
        
        // Water level change
        const dLevel = curr.level - prev.level;
        const dtHours = (curr.timestamp - prev.timestamp) / 3600000;
        
        // Calculate velocity using Avadepth model
        const velocity = calculateKm20Velocity(dLevel, dtHours, discharge);
        
        // Interpolate water level for km 20 (slightly attenuated from Steveston)
        const km20Level = curr.level * 0.85; // ~15% attenuation at km 20
        
        if (!result[dateStr]) {
          result[dateStr] = [];
        }
        
        result[dateStr].push({
          time: timeStr,
          level: km20Level,
          velocity: velocity,
          timestamp: km20Time.getTime()
        });
      }
      
      // Remove duplicate times within each day
      Object.keys(result).forEach(dateStr => {
        const seen = new Set();
        result[dateStr] = result[dateStr].filter(p => {
          if (seen.has(p.time)) return false;
          seen.add(p.time);
          return true;
        });
        result[dateStr].sort((a, b) => a.timestamp - b.timestamp);
      });
      
      return result;
    }
    
    // Fetch CHS tide high/low predictions (wlp-hilo) for a station
    // This provides automatic perpetual tide predictions!
    async function fetchCHSTideHiLo(stationId, stationName) {
      try {
        const now = new Date();
        const from = new Date(now.getTime() - 12 * 3600000); // 12 hours ago
        const to = new Date(now.getTime() + 7 * 24 * 3600000); // 7 days ahead
        
        const fromStr = from.toISOString();
        const toStr = to.toISOString();
        
        // Fetch high/low predictions (wlp-hilo = water level predictions high/low)
        const url = `${CHS_API_BASE}/stations/${stationId}/data?time-series-code=wlp-hilo&from=${fromStr}&to=${toStr}`;
        
        console.log(`Fetching CHS tide hi-lo for ${stationName}...`);
        const response = await fetch(withCorsProxy(url));
        
        if (!response.ok) {
          throw new Error(`CHS API returned ${response.status}`);
        }
        
        const data = await response.json();
        
        if (!data || data.length === 0) {
          console.warn(`No tide hi-lo data returned for ${stationName}`);
          return null;
        }
        
        // Convert to our format: group by date with height in feet
        const result = {};
        let prevValue = null;
        
        data.forEach(point => {
          const time = new Date(point.eventDate);
          const dateStr = getLocalDateString(time);
          const timeStr = time.toLocaleTimeString('en-CA', { hour: '2-digit', minute: '2-digit', hour12: false });
          
          // Value is in meters, convert to feet
          const heightFeet = (point.value / 0.3048).toFixed(1);
          
          // Determine if high or low by comparing to previous
          let type = 'high';
          if (prevValue !== null) {
            type = point.value < prevValue ? 'low' : 'high';
          }
          prevValue = point.value;
          
          if (!result[dateStr]) result[dateStr] = [];
          result[dateStr].push({
            time: timeStr,
            height: parseFloat(heightFeet),
            type: type
          });
        });
        
        // Sort each day's events by time
        Object.keys(result).forEach(dateStr => {
          result[dateStr].sort((a, b) => {
            const [ah, am] = a.time.split(':').map(Number);
            const [bh, bm] = b.time.split(':').map(Number);
            return (ah * 60 + am) - (bh * 60 + bm);
          });
          
          // Re-determine high/low based on sorted order within day
          for (let i = 0; i < result[dateStr].length; i++) {
            const prev = i > 0 ? result[dateStr][i-1] : null;
            const curr = result[dateStr][i];
            const next = i < result[dateStr].length - 1 ? result[dateStr][i+1] : null;
            
            // If we have neighbors, compare heights
            if (prev && next) {
              curr.type = (curr.height > prev.height && curr.height > next.height) ? 'high' : 'low';
            } else if (prev) {
              curr.type = curr.height > prev.height ? 'high' : 'low';
            } else if (next) {
              curr.type = curr.height > next.height ? 'high' : 'low';
            }
          }
        });
        
        console.log(`Fetched ${data.length} tide events for ${stationName}`);
        return result;
        
      } catch (e) {
        console.warn(`Failed to fetch CHS tide hi-lo for ${stationName}:`, e);
        return null;
      }
    }
    
    // Cache for live tide data
    let liveTideData = { pointAtkinson: null, steveston: null };
    let tideDataLastFetch = null;
    
    // Station IDs for tide predictions
    const STATION_POINT_ATKINSON = '07795'; // Point Atkinson tide station
    const STATION_STEVESTON_TIDE = '07590'; // Steveston tide station
    
    // Fetch live tide data from CHS
    async function fetchLiveTideData() {
      const now = Date.now();
      // Only refetch if data is stale (>1 hour old)
      if (tideDataLastFetch && (now - tideDataLastFetch) < 60 * 60 * 1000) {
        return liveTideData;
      }
      
      try {
        const [pointAtkinson, steveston] = await Promise.all([
          fetchCHSTideHiLo(STATION_POINT_ATKINSON, 'Point Atkinson'),
          fetchCHSTideHiLo(STATION_STEVESTON_TIDE, 'Steveston')
        ]);
        
        if (pointAtkinson) liveTideData.pointAtkinson = pointAtkinson;
        if (steveston) liveTideData.steveston = steveston;
        tideDataLastFetch = now;
        
        return liveTideData;
      } catch (e) {
        console.warn('Failed to fetch live tide data:', e);
        return liveTideData;
      }
    }
    
    // Flatten river data from date-grouped format to flat array
    function flattenRiverData(riverData) {
      const flat = [];
      Object.keys(riverData).forEach(dateStr => {
        riverData[dateStr].forEach(point => {
          flat.push({ ...point });
        });
      });
      return flat;
    }
    
    // Find closest data point to a given timestamp
    function findClosestPoint(dataArray, targetTimestamp) {
      if (dataArray.length === 0) return null;
      
      let closest = dataArray[0];
      let minDiff = Math.abs(dataArray[0].timestamp - targetTimestamp);
      
      for (let i = 1; i < dataArray.length; i++) {
        const diff = Math.abs(dataArray[i].timestamp - targetTimestamp);
        if (diff < minDiff) {
          minDiff = diff;
          closest = dataArray[i];
        }
      }
      
      // Only return if within 2 hours of target
      if (minDiff > 2 * 3600000) return null;
      return closest;
    }
    
    // Cache for km 20 data
    let fraserKm20Data = null;
    
    // Legacy static data as fallback
    const STEVESTON_TIDE_DATA_FALLBACK = {
      '2026-01-27': [
        { time: '02:06', height: 12.2, type: 'high' },
        { time: '05:44', height: 11.3, type: 'low' },
        { time: '11:23', height: 14.6, type: 'high' },
        { time: '19:32', height: 3.4, type: 'low' }
      ],
      '2026-01-28': [
        { time: '03:37', height: 13.4, type: 'high' },
        { time: '07:28', height: 12.4, type: 'low' },
        { time: '12:11', height: 14.3, type: 'high' },
        { time: '20:32', height: 2.6, type: 'low' }
      ],
      '2026-01-29': [
        { time: '04:37', height: 14.4, type: 'high' },
        { time: '09:09', height: 12.6, type: 'low' },
        { time: '13:14', height: 14.1, type: 'high' },
        { time: '21:32', height: 2.0, type: 'low' }
      ],
      '2026-01-30': [
        { time: '05:24', height: 15.0, type: 'high' },
        { time: '10:27', height: 12.2, type: 'low' },
        { time: '14:27', height: 14.0, type: 'high' },
        { time: '22:28', height: 1.4, type: 'low' }
      ],
      '2026-01-31': [
        { time: '06:05', height: 15.4, type: 'high' },
        { time: '11:25', height: 11.6, type: 'low' },
        { time: '15:37', height: 14.0, type: 'high' },
        { time: '23:19', height: 1.2, type: 'low' }
      ],
      '2026-02-01': [
        { time: '06:42', height: 15.6, type: 'high' },
        { time: '12:13', height: 11.0, type: 'low' },
        { time: '16:40', height: 14.1, type: 'high' }
      ],
      '2026-02-02': [
        { time: '00:04', height: 1.3, type: 'low' },
        { time: '07:16', height: 15.7, type: 'high' },
        { time: '12:54', height: 10.4, type: 'low' },
        { time: '17:37', height: 14.2, type: 'high' }
      ],
      '2026-02-03': [
        { time: '00:46', height: 1.7, type: 'low' },
        { time: '07:48', height: 15.6, type: 'high' },
        { time: '13:32', height: 9.9, type: 'low' },
        { time: '18:29', height: 14.2, type: 'high' }
      ],
      '2026-02-04': [
        { time: '01:25', height: 2.3, type: 'low' },
        { time: '08:19', height: 15.3, type: 'high' },
        { time: '14:08', height: 9.5, type: 'low' },
        { time: '19:19', height: 14.1, type: 'high' }
      ],
      '2026-02-05': [
        { time: '02:03', height: 3.1, type: 'low' },
        { time: '08:49', height: 14.9, type: 'high' },
        { time: '14:42', height: 9.3, type: 'low' },
        { time: '20:08', height: 13.9, type: 'high' }
      ],
      '2026-02-06': [
        { time: '02:40', height: 4.0, type: 'low' },
        { time: '09:19', height: 14.4, type: 'high' },
        { time: '15:17', height: 9.2, type: 'low' },
        { time: '20:58', height: 13.6, type: 'high' }
      ],
      '2026-02-07': [
        { time: '03:18', height: 5.0, type: 'low' },
        { time: '09:50', height: 13.8, type: 'high' },
        { time: '15:53', height: 9.3, type: 'low' },
        { time: '21:49', height: 13.2, type: 'high' }
      ],
      '2026-02-08': [
        { time: '03:58', height: 6.0, type: 'low' },
        { time: '10:23', height: 13.1, type: 'high' },
        { time: '16:33', height: 9.5, type: 'low' },
        { time: '22:44', height: 12.8, type: 'high' }
      ],
      '2026-02-09': [
        { time: '04:44', height: 7.1, type: 'low' },
        { time: '11:00', height: 12.4, type: 'high' },
        { time: '17:20', height: 9.7, type: 'low' },
        { time: '23:46', height: 12.4, type: 'high' }
      ],
      '2026-02-10': [
        { time: '05:40', height: 8.1, type: 'low' },
        { time: '11:45', height: 11.8, type: 'high' },
        { time: '18:18', height: 9.8, type: 'low' }
      ],
      '2026-02-11': [
        { time: '00:57', height: 12.1, type: 'high' },
        { time: '06:52', height: 8.9, type: 'low' },
        { time: '12:43', height: 11.4, type: 'high' },
        { time: '19:31', height: 9.6, type: 'low' }
      ],
      '2026-02-12': [
        { time: '02:17', height: 12.1, type: 'high' },
        { time: '08:19', height: 9.4, type: 'low' },
        { time: '13:56', height: 11.4, type: 'high' },
        { time: '20:50', height: 8.9, type: 'low' }
      ],
      '2026-02-13': [
        { time: '03:38', height: 12.4, type: 'high' },
        { time: '09:43', height: 9.4, type: 'low' },
        { time: '15:16', height: 11.9, type: 'high' },
        { time: '22:01', height: 7.8, type: 'low' }
      ],
      '2026-02-14': [
        { time: '04:49', height: 13.0, type: 'high' },
        { time: '10:52', height: 9.1, type: 'low' },
        { time: '16:25', height: 12.7, type: 'high' },
        { time: '23:02', height: 6.4, type: 'low' }
      ]
    };

    // Fraser River South Arm water levels at km 20 (based on Avadepth patterns)
    // Heights in meters, referenced to Chart Datum (Local Low Water)
    // River discharge at Hope: ~600 mÂ³/s (winter low flow)
    const FRASER_SOUTH_ARM_DATA = {
      '2026-01-27': [
        { time: '00:00', level: 2.0, velocity: 0.2 },
        { time: '01:00', level: 2.6, velocity: -0.2 },
        { time: '02:00', level: 3.0, velocity: -0.4 },
        { time: '03:00', level: 3.2, velocity: -0.2 },
        { time: '04:00', level: 3.2, velocity: 0.2 },
        { time: '05:00', level: 3.0, velocity: 0.4 },
        { time: '06:00', level: 2.8, velocity: 0.4 },
        { time: '07:00', level: 2.8, velocity: 0.2 },
        { time: '08:00', level: 3.0, velocity: -0.2 },
        { time: '09:00', level: 3.2, velocity: -0.4 },
        { time: '10:00', level: 3.4, velocity: -0.4 },
        { time: '11:00', level: 3.5, velocity: -0.2 },
        { time: '12:00', level: 3.4, velocity: 0.2 },
        { time: '13:00', level: 3.2, velocity: 0.4 },
        { time: '14:00', level: 2.8, velocity: 0.8 },
        { time: '15:00', level: 2.2, velocity: 1.2 },
        { time: '16:00', level: 1.6, velocity: 1.2 },
        { time: '17:00', level: 1.1, velocity: 1.0 },
        { time: '18:00', level: 0.7, velocity: 0.8 },
        { time: '19:00', level: 0.5, velocity: 0.5 },
        { time: '20:00', level: 0.4, velocity: 0.4 },
        { time: '21:00', level: 0.6, velocity: 0.3 },
        { time: '22:00', level: 1.0, velocity: 0.2 },
        { time: '23:00', level: 1.6, velocity: 0.1 }
      ],
      '2026-01-28': [
        { time: '00:00', level: 2.5, velocity: -0.4 },
        { time: '01:00', level: 3.0, velocity: -0.6 },
        { time: '02:00', level: 3.2, velocity: -0.4 },
        { time: '03:00', level: 3.4, velocity: -0.2 },
        { time: '04:00', level: 3.3, velocity: 0.0 },
        { time: '05:00', level: 3.3, velocity: 0.2 },
        { time: '06:00', level: 3.2, velocity: 0.2 },
        { time: '07:00', level: 3.1, velocity: 0.2 },
        { time: '08:00', level: 3.2, velocity: -0.2 },
        { time: '09:00', level: 3.3, velocity: -0.4 },
        { time: '10:00', level: 3.5, velocity: -0.4 },
        { time: '11:00', level: 3.6, velocity: -0.4 },
        { time: '12:00', level: 3.7, velocity: -0.2 },
        { time: '13:00', level: 3.5, velocity: 0.4 },
        { time: '14:00', level: 3.2, velocity: 0.6 },
        { time: '15:00', level: 2.6, velocity: 1.0 },
        { time: '16:00', level: 2.0, velocity: 1.2 },
        { time: '17:00', level: 1.5, velocity: 1.2 },
        { time: '18:00', level: 0.9, velocity: 1.2 },
        { time: '19:00', level: 0.5, velocity: 0.9 },
        { time: '20:00', level: 0.3, velocity: 0.6 },
        { time: '21:00', level: 0.4, velocity: 0.4 },
        { time: '22:00', level: 0.7, velocity: 0.4 },
        { time: '23:00', level: 1.2, velocity: 0.4 }
      ],
      // Jan 29 velocities calibrated to Avadepth km 20 predictions (600 mÂ³/s discharge)
      '2026-01-29': [
        { time: '00:00', level: 1.9, velocity: -0.1 },
        { time: '01:00', level: 2.6, velocity: -0.5 },
        { time: '02:00', level: 3.1, velocity: -0.7 },
        { time: '03:00', level: 3.5, velocity: -0.7 },
        { time: '04:00', level: 3.6, velocity: -0.6 },
        { time: '05:00', level: 3.6, velocity: -0.4 },
        { time: '06:00', level: 3.5, velocity: -0.2 },
        { time: '07:00', level: 3.4, velocity: 0.0 },
        { time: '08:00', level: 3.2, velocity: 0.2 },
        { time: '09:00', level: 3.2, velocity: 0.2 },
        { time: '10:00', level: 3.3, velocity: 0.0 },
        { time: '11:00', level: 3.4, velocity: -0.2 },
        { time: '12:00', level: 3.5, velocity: -0.3 },
        { time: '13:00', level: 3.6, velocity: -0.3 },
        { time: '14:00', level: 3.4, velocity: -0.3 },
        { time: '15:00', level: 3.1, velocity: -0.1 },
        { time: '16:00', level: 2.6, velocity: 0.3 },
        { time: '17:00', level: 2.0, velocity: 0.8 },
        { time: '18:00', level: 1.4, velocity: 1.1 },
        { time: '19:00', level: 0.9, velocity: 1.2 },
        { time: '20:00', level: 0.4, velocity: 1.1 },
        { time: '21:00', level: 0.2, velocity: 1.1 },
        { time: '22:00', level: 0.2, velocity: 1.1 },
        { time: '23:00', level: 0.6, velocity: 0.9 }
      ],
      '2026-01-30': [
        { time: '00:00', level: 1.2, velocity: 0.1 },
        { time: '01:00', level: 1.9, velocity: -0.2 },
        { time: '02:00', level: 2.7, velocity: -0.4 },
        { time: '03:00', level: 3.3, velocity: -0.4 },
        { time: '04:00', level: 3.7, velocity: -0.4 },
        { time: '05:00', level: 3.9, velocity: -0.2 },
        { time: '06:00', level: 3.8, velocity: 0.2 },
        { time: '07:00', level: 3.6, velocity: 0.4 },
        { time: '08:00', level: 3.4, velocity: 0.4 },
        { time: '09:00', level: 3.2, velocity: 0.4 },
        { time: '10:00', level: 3.1, velocity: 0.2 },
        { time: '11:00', level: 3.2, velocity: -0.2 },
        { time: '12:00', level: 3.3, velocity: -0.2 },
        { time: '13:00', level: 3.5, velocity: -0.2 },
        { time: '14:00', level: 3.6, velocity: 0.0 },
        { time: '15:00', level: 3.5, velocity: 0.4 },
        { time: '16:00', level: 3.1, velocity: 0.8 },
        { time: '17:00', level: 2.6, velocity: 1.0 },
        { time: '18:00', level: 2.0, velocity: 1.2 },
        { time: '19:00', level: 1.4, velocity: 1.2 },
        { time: '20:00', level: 0.8, velocity: 1.0 },
        { time: '21:00', level: 0.3, velocity: 0.6 },
        { time: '22:00', level: 0.1, velocity: 0.3 },
        { time: '23:00', level: 0.1, velocity: 0.2 }
      ],
      '2026-01-31': [
        { time: '00:00', level: 0.5, velocity: 0.1 },
        { time: '01:00', level: 1.2, velocity: -0.1 },
        { time: '02:00', level: 2.1, velocity: -0.3 },
        { time: '03:00', level: 2.9, velocity: -0.4 },
        { time: '04:00', level: 3.5, velocity: -0.4 },
        { time: '05:00', level: 3.9, velocity: -0.4 },
        { time: '06:00', level: 4.0, velocity: 0.0 },
        { time: '07:00', level: 3.8, velocity: 0.4 },
        { time: '08:00', level: 3.6, velocity: 0.4 },
        { time: '09:00', level: 3.3, velocity: 0.4 },
        { time: '10:00', level: 3.0, velocity: 0.4 },
        { time: '11:00', level: 2.9, velocity: 0.2 },
        { time: '12:00', level: 3.0, velocity: -0.2 },
        { time: '13:00', level: 3.2, velocity: -0.4 },
        { time: '14:00', level: 3.4, velocity: -0.4 },
        { time: '15:00', level: 3.6, velocity: -0.2 },
        { time: '16:00', level: 3.5, velocity: 0.4 },
        { time: '17:00', level: 3.1, velocity: 0.8 },
        { time: '18:00', level: 2.6, velocity: 1.0 },
        { time: '19:00', level: 2.0, velocity: 1.2 },
        { time: '20:00', level: 1.3, velocity: 1.2 },
        { time: '21:00', level: 0.7, velocity: 1.0 },
        { time: '22:00', level: 0.2, velocity: 0.6 },
        { time: '23:00', level: 0.0, velocity: 0.3 }
      ],
      '2026-02-01': [
        { time: '00:00', level: 0.1, velocity: 0.2 },
        { time: '01:00', level: 0.6, velocity: 0.0 },
        { time: '02:00', level: 1.4, velocity: -0.2 },
        { time: '03:00', level: 2.3, velocity: -0.4 },
        { time: '04:00', level: 3.2, velocity: -0.4 },
        { time: '05:00', level: 3.7, velocity: -0.4 },
        { time: '06:00', level: 4.0, velocity: -0.2 },
        { time: '07:00', level: 4.0, velocity: 0.0 },
        { time: '08:00', level: 3.7, velocity: 0.4 },
        { time: '09:00', level: 3.4, velocity: 0.6 },
        { time: '10:00', level: 3.0, velocity: 0.6 },
        { time: '11:00', level: 2.8, velocity: 0.4 },
        { time: '12:00', level: 2.7, velocity: 0.2 },
        { time: '13:00', level: 2.8, velocity: -0.2 },
        { time: '14:00', level: 3.1, velocity: -0.4 },
        { time: '15:00', level: 3.4, velocity: -0.4 },
        { time: '16:00', level: 3.5, velocity: 0.0 },
        { time: '17:00', level: 3.5, velocity: 0.4 },
        { time: '18:00', level: 3.1, velocity: 0.8 },
        { time: '19:00', level: 2.5, velocity: 1.0 },
        { time: '20:00', level: 1.9, velocity: 1.2 },
        { time: '21:00', level: 1.3, velocity: 1.0 },
        { time: '22:00', level: 0.7, velocity: 0.8 },
        { time: '23:00', level: 0.2, velocity: 0.5 }
      ]
    };

    // Fraser River North Arm at km 20 (slightly different pattern - lower amplitude)
    const FRASER_NORTH_ARM_DATA = {
      '2026-01-27': [
        { time: '00:00', level: 1.7, velocity: -0.2 },
        { time: '01:00', level: 2.0, velocity: -0.2 },
        { time: '02:00', level: 2.3, velocity: -0.1 },
        { time: '03:00', level: 2.4, velocity: 0.0 },
        { time: '04:00', level: 2.3, velocity: 0.1 },
        { time: '05:00', level: 2.1, velocity: 0.2 },
        { time: '06:00', level: 2.0, velocity: 0.2 },
        { time: '07:00', level: 2.0, velocity: 0.2 },
        { time: '08:00', level: 2.1, velocity: 0.1 },
        { time: '09:00', level: 2.3, velocity: 0.0 },
        { time: '10:00', level: 2.5, velocity: -0.1 },
        { time: '11:00', level: 2.7, velocity: -0.2 },
        { time: '12:00', level: 2.8, velocity: -0.2 },
        { time: '13:00', level: 2.8, velocity: -0.2 },
        { time: '14:00', level: 2.5, velocity: -0.1 },
        { time: '15:00', level: 2.1, velocity: 0.1 },
        { time: '16:00', level: 1.7, velocity: 0.2 },
        { time: '17:00', level: 1.3, velocity: 0.4 },
        { time: '18:00', level: 1.0, velocity: 0.5 },
        { time: '19:00', level: 0.8, velocity: 0.4 },
        { time: '20:00', level: 0.6, velocity: 0.3 },
        { time: '21:00', level: 0.5, velocity: 0.2 },
        { time: '22:00', level: 0.5, velocity: 0.1 },
        { time: '23:00', level: 0.7, velocity: 0.0 }
      ],
      '2026-01-28': [
        { time: '00:00', level: 1.7, velocity: -0.2 },
        { time: '01:00', level: 2.0, velocity: -0.2 },
        { time: '02:00', level: 2.3, velocity: -0.1 },
        { time: '03:00', level: 2.4, velocity: 0.0 },
        { time: '04:00', level: 2.3, velocity: 0.1 },
        { time: '05:00', level: 2.1, velocity: 0.2 },
        { time: '06:00', level: 2.0, velocity: 0.2 },
        { time: '07:00', level: 2.0, velocity: 0.2 },
        { time: '08:00', level: 2.1, velocity: 0.1 },
        { time: '09:00', level: 2.3, velocity: 0.0 },
        { time: '10:00', level: 2.5, velocity: -0.1 },
        { time: '11:00', level: 2.7, velocity: -0.2 },
        { time: '12:00', level: 2.8, velocity: -0.2 },
        { time: '13:00', level: 2.8, velocity: -0.2 },
        { time: '14:00', level: 2.5, velocity: -0.1 },
        { time: '15:00', level: 2.1, velocity: 0.1 },
        { time: '16:00', level: 1.7, velocity: 0.2 },
        { time: '17:00', level: 1.3, velocity: 0.4 },
        { time: '18:00', level: 1.0, velocity: 0.5 },
        { time: '19:00', level: 0.8, velocity: 0.4 },
        { time: '20:00', level: 0.6, velocity: 0.3 },
        { time: '21:00', level: 0.5, velocity: 0.2 },
        { time: '22:00', level: 0.5, velocity: 0.1 },
        { time: '23:00', level: 0.7, velocity: 0.0 }
      ],
      '2026-01-29': [
        { time: '00:00', level: 1.1, velocity: -0.1 },
        { time: '01:00', level: 1.5, velocity: -0.2 },
        { time: '02:00', level: 1.9, velocity: -0.2 },
        { time: '03:00', level: 2.1, velocity: -0.1 },
        { time: '04:00', level: 2.2, velocity: 0.0 },
        { time: '05:00', level: 2.1, velocity: 0.1 },
        { time: '06:00', level: 1.9, velocity: 0.2 },
        { time: '07:00', level: 1.8, velocity: 0.2 },
        { time: '08:00', level: 1.8, velocity: 0.2 },
        { time: '09:00', level: 2.0, velocity: 0.1 },
        { time: '10:00', level: 2.3, velocity: 0.0 },
        { time: '11:00', level: 2.5, velocity: -0.1 },
        { time: '12:00', level: 2.7, velocity: -0.2 },
        { time: '13:00', level: 2.7, velocity: -0.2 },
        { time: '14:00', level: 2.5, velocity: -0.1 },
        { time: '15:00', level: 2.1, velocity: 0.1 },
        { time: '16:00', level: 1.7, velocity: 0.2 },
        { time: '17:00', level: 1.3, velocity: 0.4 },
        { time: '18:00', level: 1.0, velocity: 0.4 },
        { time: '19:00', level: 0.8, velocity: 0.4 },
        { time: '20:00', level: 0.6, velocity: 0.3 },
        { time: '21:00', level: 0.5, velocity: 0.2 },
        { time: '22:00', level: 0.5, velocity: 0.1 },
        { time: '23:00', level: 0.5, velocity: 0.0 }
      ],
      '2026-01-30': [
        { time: '00:00', level: 0.7, velocity: -0.1 },
        { time: '01:00', level: 1.0, velocity: -0.2 },
        { time: '02:00', level: 1.5, velocity: -0.2 },
        { time: '03:00', level: 1.9, velocity: -0.2 },
        { time: '04:00', level: 2.2, velocity: -0.1 },
        { time: '05:00', level: 2.2, velocity: 0.0 },
        { time: '06:00', level: 2.0, velocity: 0.1 },
        { time: '07:00', level: 1.8, velocity: 0.2 },
        { time: '08:00', level: 1.7, velocity: 0.2 },
        { time: '09:00', level: 1.8, velocity: 0.2 },
        { time: '10:00', level: 2.0, velocity: 0.1 },
        { time: '11:00', level: 2.3, velocity: 0.0 },
        { time: '12:00', level: 2.5, velocity: -0.2 },
        { time: '13:00', level: 2.6, velocity: -0.2 },
        { time: '14:00', level: 2.5, velocity: -0.1 },
        { time: '15:00', level: 2.1, velocity: 0.1 },
        { time: '16:00', level: 1.7, velocity: 0.2 },
        { time: '17:00', level: 1.2, velocity: 0.4 },
        { time: '18:00', level: 0.9, velocity: 0.4 },
        { time: '19:00', level: 0.8, velocity: 0.4 },
        { time: '20:00', level: 0.6, velocity: 0.3 },
        { time: '21:00', level: 0.5, velocity: 0.2 },
        { time: '22:00', level: 0.4, velocity: 0.1 },
        { time: '23:00', level: 0.4, velocity: 0.0 }
      ],
      '2026-01-31': [
        { time: '00:00', level: 0.5, velocity: -0.1 },
        { time: '01:00', level: 0.7, velocity: -0.1 },
        { time: '02:00', level: 1.1, velocity: -0.2 },
        { time: '03:00', level: 1.6, velocity: -0.2 },
        { time: '04:00', level: 2.0, velocity: -0.1 },
        { time: '05:00', level: 2.2, velocity: 0.0 },
        { time: '06:00', level: 2.1, velocity: 0.1 },
        { time: '07:00', level: 1.9, velocity: 0.1 },
        { time: '08:00', level: 1.7, velocity: 0.2 },
        { time: '09:00', level: 1.6, velocity: 0.2 },
        { time: '10:00', level: 1.7, velocity: 0.1 },
        { time: '11:00', level: 1.9, velocity: 0.0 },
        { time: '12:00', level: 2.2, velocity: -0.1 },
        { time: '13:00', level: 2.5, velocity: -0.2 },
        { time: '14:00', level: 2.5, velocity: -0.2 },
        { time: '15:00', level: 2.3, velocity: -0.1 },
        { time: '16:00', level: 1.9, velocity: 0.1 },
        { time: '17:00', level: 1.3, velocity: 0.3 },
        { time: '18:00', level: 1.0, velocity: 0.4 },
        { time: '19:00', level: 0.8, velocity: 0.4 },
        { time: '20:00', level: 0.6, velocity: 0.3 },
        { time: '21:00', level: 0.5, velocity: 0.2 },
        { time: '22:00', level: 0.4, velocity: 0.1 },
        { time: '23:00', level: 0.3, velocity: 0.0 }
      ],
      '2026-02-01': [
        { time: '00:00', level: 0.4, velocity: -0.1 },
        { time: '01:00', level: 0.5, velocity: -0.1 },
        { time: '02:00', level: 0.9, velocity: -0.2 },
        { time: '03:00', level: 1.3, velocity: -0.2 },
        { time: '04:00', level: 1.7, velocity: -0.2 },
        { time: '05:00', level: 2.0, velocity: -0.1 },
        { time: '06:00', level: 2.1, velocity: 0.0 },
        { time: '07:00', level: 2.0, velocity: 0.1 },
        { time: '08:00', level: 1.8, velocity: 0.2 },
        { time: '09:00', level: 1.6, velocity: 0.2 },
        { time: '10:00', level: 1.5, velocity: 0.2 },
        { time: '11:00', level: 1.6, velocity: 0.1 },
        { time: '12:00', level: 1.9, velocity: 0.0 },
        { time: '13:00', level: 2.2, velocity: -0.1 },
        { time: '14:00', level: 2.4, velocity: -0.2 },
        { time: '15:00', level: 2.4, velocity: -0.1 },
        { time: '16:00', level: 2.0, velocity: 0.1 },
        { time: '17:00', level: 1.5, velocity: 0.3 },
        { time: '18:00', level: 1.1, velocity: 0.4 },
        { time: '19:00', level: 0.8, velocity: 0.4 },
        { time: '20:00', level: 0.6, velocity: 0.3 },
        { time: '21:00', level: 0.5, velocity: 0.2 },
        { time: '22:00', level: 0.4, velocity: 0.1 },
        { time: '23:00', level: 0.3, velocity: 0.0 }
      ]
    };

    function getTidesForStation(stationData) {
      const now = new Date();
      const tides = [];
      
      // Get today and next few days
      for (let d = 0; d < 4; d++) {
        const date = new Date(now);
        date.setDate(date.getDate() + d);
        const dateStr = getLocalDateString(date);
        
        if (stationData[dateStr]) {
          stationData[dateStr].forEach(tide => {
            const [hours, mins] = tide.time.split(':').map(Number);
            const tideTime = new Date(date);
            tideTime.setHours(hours, mins, 0, 0);
            
            tides.push({
              time: tideTime,
              heightFt: tide.height,
              heightM: (tide.height * 0.3048).toFixed(2),
              type: tide.type
            });
          });
        }
      }
      
      // Sort by time and filter to events from 1 hour ago onwards (to show current context)
      return tides.sort((a, b) => a.time - b.time).filter(t => t.time >= new Date(now.getTime() - 3600000)).slice(0, 12);
    }

    function generateTideCurve(stationData, hoursSpan = 72) {
      const now = new Date();
      const startTime = new Date(now.getTime() - 2 * 3600000); // Start 2 hours ago
      const endTime = new Date(startTime.getTime() + hoursSpan * 3600000);
      const points = [];
      
      // Get all tide events in range - need to cover full span plus buffer
      const tides = [];
      for (let d = -1; d < 5; d++) {
        const date = new Date(now);
        date.setDate(date.getDate() + d);
        const dateStr = getLocalDateString(date);
        
        if (stationData[dateStr]) {
          stationData[dateStr].forEach(tide => {
            const [hours, mins] = tide.time.split(':').map(Number);
            const tideTime = new Date(date);
            tideTime.setHours(hours, mins, 0, 0);
            tides.push({ time: tideTime, height: tide.height, type: tide.type });
          });
        }
      }
      
      // If no tide data found, return empty
      if (tides.length === 0) {
        return { points: [], startTime, endTime, now };
      }
      
      tides.sort((a, b) => a.time - b.time);
      
      // Generate curve points using sinusoidal interpolation
      const interval = 15 * 60000; // 15 minutes
      for (let t = startTime.getTime(); t <= endTime.getTime(); t += interval) {
        const currentTime = new Date(t);
        
        // Find surrounding tide events
        let prevTide = null, nextTide = null;
        for (let i = 0; i < tides.length; i++) {
          if (tides[i].time.getTime() <= t) prevTide = tides[i];
          if (tides[i].time.getTime() > t && !nextTide) nextTide = tides[i];
        }
        
        let height = 8; // Default mean level
        if (prevTide && nextTide) {
          const totalTime = nextTide.time.getTime() - prevTide.time.getTime();
          const elapsed = t - prevTide.time.getTime();
          const progress = elapsed / totalTime;
          
          // Cosine interpolation for smooth tide curve
          const cosProgress = (1 - Math.cos(progress * Math.PI)) / 2;
          height = prevTide.height + (nextTide.height - prevTide.height) * cosProgress;
        } else if (prevTide) {
          height = prevTide.height;
        } else if (nextTide) {
          height = nextTide.height;
        }
        
        points.push({
          time: currentTime,
          height: height,
          x: (t - startTime.getTime()) / (endTime.getTime() - startTime.getTime())
        });
      }
      
      return { points, startTime, endTime, now };
    }

    function drawTideGraph(canvasId, markerId, stationData) {
      const canvas = document.getElementById(canvasId);
      const marker = document.getElementById(markerId);
      if (!canvas) return;
      
      const ctx = canvas.getContext('2d');
      const container = canvas.parentElement;
      
      // Use offsetWidth/Height for more reliable sizing
      const width = container.offsetWidth || 800;
      const height = container.offsetHeight || 140;
      
      // Set canvas size with device pixel ratio for sharp rendering
      const dpr = window.devicePixelRatio || 1;
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
      ctx.scale(dpr, dpr);
      
      const curve = generateTideCurve(stationData);
      const points = curve.points;
      
      // If no points, show message
      if (points.length === 0) {
        ctx.fillStyle = 'rgba(200, 200, 200, 0.5)';
        ctx.font = '12px Inter';
        ctx.textAlign = 'center';
        ctx.fillText('No tide data available for this period', width / 2, height / 2);
        return;
      }
      
      // Find min/max heights
      const heights = points.map(p => p.height);
      const minH = Math.min(...heights) - 1;
      const maxH = Math.max(...heights) + 1;
      
      const padding = { top: 20, bottom: 20, left: 35, right: 35 };
      const graphWidth = width - padding.left - padding.right;
      const graphHeight = height - padding.top - padding.bottom;
      
      // Store graph params for mouse interaction
      canvas.graphParams = { curve, points, minH, maxH, padding, graphWidth, graphHeight, width, height, stationData };
      
      // Draw the static graph
      drawStaticGraph(ctx, canvas.graphParams);
      
      // Position NOW marker
      const nowX = padding.left + ((curve.now.getTime() - curve.startTime.getTime()) / (curve.endTime.getTime() - curve.startTime.getTime())) * graphWidth;
      marker.style.left = `${nowX}px`;
      
      // Add mouse event listeners (only once)
      if (!canvas.hasMouseListeners) {
        canvas.hasMouseListeners = true;
        
        canvas.addEventListener('mousemove', (e) => {
          const rect = canvas.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;
          drawGraphWithCrosshairs(canvas, mouseX, mouseY);
        });
        
        canvas.addEventListener('mouseleave', () => {
          // Redraw without crosshairs
          const ctx = canvas.getContext('2d');
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          const dpr = window.devicePixelRatio || 1;
          ctx.scale(dpr, dpr);
          drawStaticGraph(ctx, canvas.graphParams);
        });
      }
    }
    
    function drawStaticGraph(ctx, params) {
      const { curve, points, minH, maxH, padding, graphWidth, graphHeight, width, height, stationData } = params;
      
      // Clear canvas
      ctx.clearRect(0, 0, width, height);
      
      // Draw grid lines
      ctx.strokeStyle = 'rgba(0, 212, 170, 0.15)';
      ctx.lineWidth = 1;
      
      // Horizontal grid (height levels) - show both feet and meters
      for (let h = Math.ceil(minH); h <= Math.floor(maxH); h += 2) {
        const y = padding.top + graphHeight * (1 - (h - minH) / (maxH - minH));
        ctx.beginPath();
        ctx.moveTo(padding.left, y);
        ctx.lineTo(width - padding.right, y);
        ctx.stroke();
        
        // Height labels - feet on left
        ctx.fillStyle = 'rgba(200, 200, 200, 0.6)';
        ctx.font = '9px Inter';
        ctx.textAlign = 'right';
        ctx.fillText(`${h}ft`, padding.left - 4, y + 3);
        
        // Height labels - meters on right
        const meters = (h * 0.3048).toFixed(1);
        ctx.textAlign = 'left';
        ctx.fillText(`${meters}m`, width - padding.right + 4, y + 3);
      }
      
      // Draw time labels - show day markers for 3-day view
      ctx.fillStyle = 'rgba(200, 200, 200, 0.6)';
      ctx.font = '9px Inter';
      ctx.textAlign = 'center';
      
      // Draw vertical day separator lines and labels
      for (let h = 0; h <= 72; h += 12) {
        const x = padding.left + (h / 72) * graphWidth;
        const labelTime = new Date(curve.startTime.getTime() + h * 3600000);
        
        // Draw subtle vertical grid line at midnight
        if (labelTime.getHours() === 0 || h === 0) {
          ctx.strokeStyle = 'rgba(0, 212, 170, 0.2)';
          ctx.beginPath();
          ctx.moveTo(x, padding.top);
          ctx.lineTo(x, height - padding.bottom);
          ctx.stroke();
        }
        
        // Show day name at midnight, time otherwise
        if (labelTime.getHours() === 0) {
          ctx.fillText(formatDay(labelTime), x, height - 5);
        } else if (h % 24 === 12) {
          ctx.fillText('12:00', x, height - 5);
        }
      }
      
      // Draw tide curve - gradient fill
      ctx.beginPath();
      ctx.moveTo(padding.left, height - padding.bottom);
      
      points.forEach((p, i) => {
        const x = padding.left + p.x * graphWidth;
        const y = padding.top + graphHeight * (1 - (p.height - minH) / (maxH - minH));
        if (i === 0) ctx.lineTo(x, y);
        else ctx.lineTo(x, y);
      });
      
      ctx.lineTo(padding.left + graphWidth, height - padding.bottom);
      ctx.closePath();
      
      const gradient = ctx.createLinearGradient(0, padding.top, 0, height - padding.bottom);
      gradient.addColorStop(0, 'rgba(0, 212, 170, 0.4)');
      gradient.addColorStop(1, 'rgba(0, 212, 170, 0.05)');
      ctx.fillStyle = gradient;
      ctx.fill();
      
      // Draw tide curve line
      ctx.beginPath();
      points.forEach((p, i) => {
        const x = padding.left + p.x * graphWidth;
        const y = padding.top + graphHeight * (1 - (p.height - minH) / (maxH - minH));
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.strokeStyle = 'rgba(0, 212, 170, 0.9)';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Draw high/low tide markers on the curve
      drawTideMarkers(ctx, params);
    }
    
    function drawTideMarkers(ctx, params) {
      const { curve, minH, maxH, padding, graphWidth, graphHeight, stationData } = params;
      
      const tideEvents = [];
      for (let d = -1; d < 5; d++) {
        const date = new Date(curve.now);
        date.setDate(date.getDate() + d);
        const dateStr = getLocalDateString(date);
        
        if (stationData[dateStr]) {
          stationData[dateStr].forEach(tide => {
            const [hours, mins] = tide.time.split(':').map(Number);
            const tideTime = new Date(date);
            tideTime.setHours(hours, mins, 0, 0);
            
            if (tideTime >= curve.startTime && tideTime <= curve.endTime) {
              tideEvents.push({
                time: tideTime,
                height: tide.height,
                type: tide.type
              });
            }
          });
        }
      }
      
      // Draw markers for each tide event
      tideEvents.forEach(tide => {
        const xPos = padding.left + ((tide.time.getTime() - curve.startTime.getTime()) / (curve.endTime.getTime() - curve.startTime.getTime())) * graphWidth;
        const yPos = padding.top + graphHeight * (1 - (tide.height - minH) / (maxH - minH));
        
        // Draw dot
        ctx.beginPath();
        ctx.arc(xPos, yPos, 4, 0, Math.PI * 2);
        ctx.fillStyle = tide.type === 'high' ? 'rgba(0, 212, 170, 1)' : 'rgba(255, 107, 107, 1)';
        ctx.fill();
        
        // Draw label background
        const label = `${tide.type === 'high' ? 'â–²' : 'â–¼'} ${(tide.height * 0.3048).toFixed(1)}m`;
        const timeLabel = formatTime(tide.time);
        ctx.font = 'bold 8px Inter';
        const labelWidth = Math.max(ctx.measureText(label).width, ctx.measureText(timeLabel).width) + 6;
        
        const labelY = tide.type === 'high' ? yPos - 22 : yPos + 8;
        
        ctx.fillStyle = 'rgba(13, 33, 55, 0.9)';
        ctx.fillRect(xPos - labelWidth/2, labelY, labelWidth, 20);
        
        ctx.fillStyle = tide.type === 'high' ? 'rgba(0, 212, 170, 1)' : 'rgba(255, 107, 107, 1)';
        ctx.font = 'bold 8px Inter';
        ctx.textAlign = 'center';
        ctx.fillText(label, xPos, labelY + 9);
        ctx.fillStyle = 'rgba(200, 200, 200, 0.8)';
        ctx.font = '7px Inter';
        ctx.fillText(timeLabel, xPos, labelY + 17);
      });
    }
    
    function drawGraphWithCrosshairs(canvas, mouseX, mouseY) {
      const ctx = canvas.getContext('2d');
      const params = canvas.graphParams;
      if (!params) return;
      
      const { curve, points, minH, maxH, padding, graphWidth, graphHeight, width, height } = params;
      
      // Reset transform and redraw base graph
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      const dpr = window.devicePixelRatio || 1;
      ctx.scale(dpr, dpr);
      drawStaticGraph(ctx, params);
      
      // Check if mouse is in graph area
      if (mouseX < padding.left || mouseX > width - padding.right || 
          mouseY < padding.top || mouseY > height - padding.bottom) {
        return;
      }
      
      // Calculate time and height at mouse position
      const xRatio = (mouseX - padding.left) / graphWidth;
      const timeAtMouse = new Date(curve.startTime.getTime() + xRatio * (curve.endTime.getTime() - curve.startTime.getTime()));
      
      // Find closest point to get height
      let closestPoint = points[0];
      let minDist = Math.abs(points[0].x - xRatio);
      for (const p of points) {
        const dist = Math.abs(p.x - xRatio);
        if (dist < minDist) {
          minDist = dist;
          closestPoint = p;
        }
      }
      
      const heightAtMouse = closestPoint.height;
      const yAtCurve = padding.top + graphHeight * (1 - (heightAtMouse - minH) / (maxH - minH));
      
      // Draw crosshairs
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
      ctx.lineWidth = 1;
      ctx.setLineDash([5, 5]);
      
      // Vertical line
      ctx.beginPath();
      ctx.moveTo(mouseX, padding.top);
      ctx.lineTo(mouseX, height - padding.bottom);
      ctx.stroke();
      
      // Horizontal line at curve height
      ctx.beginPath();
      ctx.moveTo(padding.left, yAtCurve);
      ctx.lineTo(width - padding.right, yAtCurve);
      ctx.stroke();
      
      ctx.setLineDash([]);
      
      // Draw point on curve
      ctx.beginPath();
      ctx.arc(mouseX, yAtCurve, 6, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(0, 212, 170, 1)';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Draw info tooltip
      const heightM = (heightAtMouse * 0.3048).toFixed(2);
      const heightFt = heightAtMouse.toFixed(1);
      const timeStr = timeAtMouse.toLocaleString('en-CA', { 
        weekday: 'short', 
        month: 'short', 
        day: 'numeric',
        hour: '2-digit', 
        minute: '2-digit',
        hour12: false 
      });
      
      // Tooltip dimensions
      const tooltipWidth = 140;
      const tooltipHeight = 50;
      let tooltipX = mouseX + 15;
      let tooltipY = mouseY - 25;
      
      // Keep tooltip in bounds
      if (tooltipX + tooltipWidth > width - 10) tooltipX = mouseX - tooltipWidth - 15;
      if (tooltipY < 10) tooltipY = 10;
      if (tooltipY + tooltipHeight > height - 10) tooltipY = height - tooltipHeight - 10;
      
      // Draw tooltip background
      ctx.fillStyle = 'rgba(13, 33, 55, 0.95)';
      ctx.strokeStyle = 'rgba(0, 212, 170, 0.5)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.roundRect(tooltipX, tooltipY, tooltipWidth, tooltipHeight, 6);
      ctx.fill();
      ctx.stroke();
      
      // Draw tooltip text
      ctx.fillStyle = 'rgba(200, 200, 200, 0.9)';
      ctx.font = '10px Inter';
      ctx.textAlign = 'left';
      ctx.fillText(timeStr, tooltipX + 8, tooltipY + 16);
      
      ctx.fillStyle = 'rgba(0, 212, 170, 1)';
      ctx.font = 'bold 14px Inter';
      ctx.fillText(`${heightM} m`, tooltipX + 8, tooltipY + 34);
      
      ctx.fillStyle = 'rgba(200, 200, 200, 0.7)';
      ctx.font = '10px Inter';
      ctx.fillText(`(${heightFt} ft)`, tooltipX + 75, tooltipY + 34);
    }

    function buildTideDisplay(tides, containerId) {
      const container = document.getElementById(containerId);
      if (!container) return;
      
      const now = new Date();
      let foundNext = false;
      
      container.innerHTML = tides.map(t => {
        const isNext = !foundNext && t.time > now;
        if (isNext) foundNext = true;
        
        return `
          <div class="tide-event-card ${t.type} ${isNext ? 'next' : ''}">
            <div class="tide-event-time">${formatDay(t.time)} ${formatTime(t.time)}</div>
            <div class="tide-event-type ${t.type}">${t.type === 'high' ? 'â–² High' : 'â–¼ Low'}</div>
            <div class="tide-event-height">${t.heightM} m</div>
            <div class="tide-event-height-ft">${t.heightFt} ft</div>
          </div>
        `;
      }).join('');
    }

    // Current calculations for First and Second Narrows
    // Using XTide reference data for accurate predictions
    
    // Reference data from XTide (dairiki.org) for January-February 2026
    // Format: [dayOfMonth, slackTimes[], maxTimes[], maxSpeeds[]] 
    // Negative speed = Ebb, Positive = Flood
    const FIRST_NARROWS_DATA = {
      '2026-01-27': {
        slacks: ['02:12', '11:16', '19:47'],
        maxes: [
          { time: '03:50', speed: -0.5 },
          { time: '08:46', speed: 1.5 },
          { time: '15:46', speed: -4.3 },
          { time: '23:18', speed: 3.3 }
        ]
      },
      '2026-01-28': {
        slacks: ['03:59', '12:04', '20:49'],
        maxes: [
          { time: '05:33', speed: -0.5 },
          { time: '09:59', speed: 1.0 },
          { time: '16:53', speed: -4.5 },
        ]
      },
      '2026-01-29': {
        slacks: ['05:03', '09:13', '13:08', '21:47'],
        maxes: [
          { time: '00:29', speed: 4.0 },
          { time: '06:57', speed: -0.8 },
          { time: '11:21', speed: 0.8 },
          { time: '18:00', speed: -4.8 }
        ]
      },
      '2026-01-30': {
        slacks: ['05:49', '10:36', '14:21', '22:41'],
        maxes: [
          { time: '01:28', speed: 4.6 },
          { time: '07:59', speed: -1.3 },
          { time: '12:36', speed: 0.9 },
          { time: '19:01', speed: -5.0 }
        ]
      },
      '2026-01-31': {
        slacks: ['06:28', '11:35', '15:33', '23:30'],
        maxes: [
          { time: '02:19', speed: 5.0 },
          { time: '08:48', speed: -1.8 },
          { time: '13:40', speed: 1.2 },
          { time: '19:56', speed: -5.2 }
        ]
      },
      '2026-02-01': {
        slacks: ['07:02', '12:23', '16:36'],
        maxes: [
          { time: '00:16', speed: 5.2 },
          { time: '03:05', speed: 5.3 },
          { time: '09:30', speed: -2.2 },
          { time: '14:36', speed: 1.4 },
          { time: '20:46', speed: -5.3 }
        ]
      },
      '2026-02-02': {
        slacks: ['07:33', '13:04', '17:33'],
        maxes: [
          { time: '00:57', speed: 5.5 },
          { time: '03:47', speed: 5.5 },
          { time: '10:06', speed: -2.5 },
          { time: '15:26', speed: 1.6 },
          { time: '21:33', speed: -5.3 }
        ]
      },
      '2026-02-03': {
        slacks: ['08:01', '13:41', '18:26'],
        maxes: [
          { time: '01:36', speed: 5.5 },
          { time: '04:27', speed: 5.5 },
          { time: '10:40', speed: -2.7 },
          { time: '16:12', speed: 1.7 },
          { time: '22:17', speed: -5.2 }
        ]
      },
      '2026-02-04': {
        slacks: ['08:28', '14:15', '19:17'],
        maxes: [
          { time: '02:13', speed: 5.4 },
          { time: '05:05', speed: 5.4 },
          { time: '11:12', speed: -2.8 },
          { time: '16:56', speed: 1.7 },
          { time: '22:59', speed: -5.0 }
        ]
      },
      '2026-02-05': {
        slacks: ['08:55', '14:47', '20:07'],
        maxes: [
          { time: '02:49', speed: 5.2 },
          { time: '05:43', speed: 5.2 },
          { time: '11:44', speed: -2.8 },
          { time: '17:39', speed: 1.6 },
          { time: '23:41', speed: -4.7 }
        ]
      },
      '2026-02-06': {
        slacks: ['09:22', '15:20', '20:57'],
        maxes: [
          { time: '03:26', speed: 4.9 },
          { time: '06:21', speed: 4.9 },
          { time: '12:16', speed: -2.7 },
          { time: '18:22', speed: 1.4 }
        ]
      },
      '2026-02-07': {
        slacks: ['09:51', '15:54', '21:49'],
        maxes: [
          { time: '00:23', speed: -4.3 },
          { time: '04:04', speed: 4.5 },
          { time: '07:01', speed: 4.5 },
          { time: '12:50', speed: -2.5 },
          { time: '19:07', speed: 1.2 }
        ]
      },
      '2026-02-08': {
        slacks: ['10:24', '16:32', '22:44'],
        maxes: [
          { time: '01:08', speed: -3.8 },
          { time: '04:46', speed: 4.0 },
          { time: '07:46', speed: 4.0 },
          { time: '13:28', speed: -2.2 },
          { time: '19:55', speed: 0.9 }
        ]
      },
      '2026-02-09': {
        slacks: ['11:03', '17:17', '23:45'],
        maxes: [
          { time: '01:57', speed: -3.3 },
          { time: '05:35', speed: 3.4 },
          { time: '08:40', speed: 3.4 },
          { time: '14:14', speed: -1.9 },
          { time: '20:50', speed: 0.6 }
        ]
      },
      '2026-02-10': {
        slacks: ['11:52', '18:14'],
        maxes: [
          { time: '02:54', speed: -2.7 },
          { time: '06:37', speed: 2.8 },
          { time: '09:51', speed: 2.8 },
          { time: '15:13', speed: -1.5 },
          { time: '21:57', speed: 0.4 }
        ]
      },
      '2026-02-11': {
        slacks: ['00:56', '12:56', '19:26'],
        maxes: [
          { time: '04:04', speed: -2.2 },
          { time: '08:01', speed: 2.2 },
          { time: '11:25', speed: 2.2 },
          { time: '16:29', speed: -1.2 },
          { time: '23:19', speed: 0.3 }
        ]
      },
      '2026-02-12': {
        slacks: ['02:25', '14:19', '20:53'],
        maxes: [
          { time: '05:37', speed: -1.8 },
          { time: '09:58', speed: 1.8 },
          { time: '13:17', speed: 1.8 },
          { time: '17:58', speed: -1.1 }
        ]
      },
      '2026-02-13': {
        slacks: ['04:16', '10:20', '15:51', '22:25'],
        maxes: [
          { time: '00:55', speed: 0.4 },
          { time: '07:26', speed: -1.6 },
          { time: '12:02', speed: 1.6 },
          { time: '14:58', speed: 1.6 },
          { time: '19:27', speed: -1.4 }
        ]
      },
      '2026-02-14': {
        slacks: ['05:37', '11:10', '17:05', '23:48'],
        maxes: [
          { time: '02:23', speed: 0.7 },
          { time: '08:33', speed: -1.6 },
          { time: '13:20', speed: 1.6 },
          { time: '16:07', speed: 1.6 },
          { time: '20:36', speed: -1.9 }
        ]
      }
    };
    
    const SECOND_NARROWS_DATA = {
      '2026-01-27': {
        slacks: ['01:53', '11:24', '19:35'],
        maxes: [
          { time: '03:42', speed: -0.7 },
          { time: '08:49', speed: 1.6 },
          { time: '15:42', speed: -4.0 },
          { time: '23:06', speed: 3.4 }
        ]
      },
      '2026-01-28': {
        slacks: ['03:36', '12:16', '20:38'],
        maxes: [
          { time: '05:21', speed: -0.7 },
          { time: '10:03', speed: 1.2 },
          { time: '16:50', speed: -4.2 },
        ]
      },
      '2026-01-29': {
        slacks: ['04:43', '09:03', '13:23', '21:37'],
        maxes: [
          { time: '00:17', speed: 4.0 },
          { time: '06:44', speed: -1.0 },
          { time: '11:24', speed: 1.0 },
          { time: '17:56', speed: -4.5 }
        ]
      },
      '2026-01-30': {
        slacks: ['05:32', '10:23', '14:34', '22:31'],
        maxes: [
          { time: '01:17', speed: 4.5 },
          { time: '07:46', speed: -1.5 },
          { time: '12:37', speed: 1.2 },
          { time: '18:57', speed: -4.8 }
        ]
      },
      '2026-01-31': {
        slacks: ['06:13', '11:23', '15:43', '23:21'],
        maxes: [
          { time: '02:08', speed: 5.0 },
          { time: '08:37', speed: -2.0 },
          { time: '13:40', speed: 1.5 },
          { time: '19:52', speed: -4.9 }
        ]
      },
      '2026-02-01': {
        slacks: ['06:48', '12:12', '16:46'],
        maxes: [
          { time: '00:06', speed: 5.1 },
          { time: '02:54', speed: 5.2 },
          { time: '09:20', speed: -2.4 },
          { time: '14:36', speed: 1.6 },
          { time: '20:43', speed: -5.1 }
        ]
      },
      '2026-02-02': {
        slacks: ['07:20', '12:55', '17:43'],
        maxes: [
          { time: '00:47', speed: 5.3 },
          { time: '03:36', speed: 5.4 },
          { time: '09:58', speed: -2.7 },
          { time: '15:26', speed: 1.8 },
          { time: '21:30', speed: -5.1 }
        ]
      },
      '2026-02-03': {
        slacks: ['07:49', '13:33', '18:36'],
        maxes: [
          { time: '01:26', speed: 5.4 },
          { time: '04:16', speed: 5.4 },
          { time: '10:33', speed: -2.9 },
          { time: '16:12', speed: 1.9 },
          { time: '22:14', speed: -5.0 }
        ]
      },
      '2026-02-04': {
        slacks: ['08:17', '14:08', '19:27'],
        maxes: [
          { time: '02:03', speed: 5.3 },
          { time: '04:55', speed: 5.3 },
          { time: '11:06', speed: -3.0 },
          { time: '16:56', speed: 1.9 },
          { time: '22:56', speed: -4.8 }
        ]
      },
      '2026-02-05': {
        slacks: ['08:45', '14:42', '20:17'],
        maxes: [
          { time: '02:40', speed: 5.1 },
          { time: '05:34', speed: 5.1 },
          { time: '11:39', speed: -3.0 },
          { time: '17:39', speed: 1.8 },
          { time: '23:37', speed: -4.5 }
        ]
      },
      '2026-02-06': {
        slacks: ['09:14', '15:16', '21:07'],
        maxes: [
          { time: '03:18', speed: 4.8 },
          { time: '06:14', speed: 4.8 },
          { time: '12:12', speed: -2.9 },
          { time: '18:22', speed: 1.6 }
        ]
      },
      '2026-02-07': {
        slacks: ['09:44', '15:51', '21:59'],
        maxes: [
          { time: '00:19', speed: -4.1 },
          { time: '03:57', speed: 4.4 },
          { time: '06:56', speed: 4.4 },
          { time: '12:47', speed: -2.7 },
          { time: '19:07', speed: 1.4 }
        ]
      },
      '2026-02-08': {
        slacks: ['10:18', '16:30', '22:54'],
        maxes: [
          { time: '01:04', speed: -3.6 },
          { time: '04:41', speed: 3.9 },
          { time: '07:43', speed: 3.9 },
          { time: '13:26', speed: -2.4 },
          { time: '19:55', speed: 1.1 }
        ]
      },
      '2026-02-09': {
        slacks: ['10:58', '17:15', '23:55'],
        maxes: [
          { time: '01:53', speed: -3.1 },
          { time: '05:31', speed: 3.3 },
          { time: '08:38', speed: 3.3 },
          { time: '14:12', speed: -2.1 },
          { time: '20:50', speed: 0.8 }
        ]
      },
      '2026-02-10': {
        slacks: ['11:48', '18:14'],
        maxes: [
          { time: '02:50', speed: -2.5 },
          { time: '06:34', speed: 2.7 },
          { time: '09:49', speed: 2.7 },
          { time: '15:10', speed: -1.7 },
          { time: '21:57', speed: 0.5 }
        ]
      },
      '2026-02-11': {
        slacks: ['01:06', '12:54', '19:26'],
        maxes: [
          { time: '04:01', speed: -2.0 },
          { time: '07:58', speed: 2.1 },
          { time: '11:23', speed: 2.1 },
          { time: '16:27', speed: -1.4 },
          { time: '23:19', speed: 0.4 }
        ]
      },
      '2026-02-12': {
        slacks: ['02:35', '14:17', '20:53'],
        maxes: [
          { time: '05:34', speed: -1.6 },
          { time: '09:55', speed: 1.7 },
          { time: '13:15', speed: 1.7 },
          { time: '17:56', speed: -1.3 }
        ]
      },
      '2026-02-13': {
        slacks: ['04:26', '10:18', '15:49', '22:25'],
        maxes: [
          { time: '00:55', speed: 0.5 },
          { time: '07:23', speed: -1.4 },
          { time: '11:59', speed: 1.5 },
          { time: '14:55', speed: 1.5 },
          { time: '19:24', speed: -1.6 }
        ]
      },
      '2026-02-14': {
        slacks: ['05:47', '11:08', '17:03', '23:48'],
        maxes: [
          { time: '02:23', speed: 0.8 },
          { time: '08:30', speed: -1.4 },
          { time: '13:17', speed: 1.5 },
          { time: '16:04', speed: 1.5 },
          { time: '20:33', speed: -2.1 }
        ]
      }
    };

    function parseTimeToday(timeStr, baseDate) {
      const [hours, minutes] = timeStr.split(':').map(Number);
      const result = new Date(baseDate);
      result.setHours(hours, minutes, 0, 0);
      return result;
    }

    function getLocalDateString(date) {
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    }

    function calculateCurrents(stationConfig, referenceData) {
      const now = new Date();
      const today = getLocalDateString(now);
      const tomorrow = new Date(now);
      tomorrow.setDate(tomorrow.getDate() + 1);
      const tomorrowStr = getLocalDateString(tomorrow);
      
      const { maxFlood, maxEbb, floodDir, ebbDir } = stationConfig;
      
      // Check if we have reference data for today
      let todayData = referenceData[today];
      let tomorrowData = referenceData[tomorrowStr];
      
      // If no data for today, use tidal extrapolation from most recent data
      // M2 tidal period is ~12.42 hours, so we can project forward
      if (!todayData) {
        const M2_PERIOD_MS = 12.42 * 3600 * 1000; // ~12h 25m
        const LUNAR_DAY_MS = 24.84 * 3600 * 1000; // ~24h 50m
        
        // Find most recent available data
        const availableDates = Object.keys(referenceData).sort().reverse();
        if (availableDates.length > 0) {
          const lastDate = availableDates[0];
          const lastData = referenceData[lastDate];
          
          // Calculate days since last data
          const lastDateObj = new Date(lastDate + 'T00:00:00');
          const daysSince = Math.floor((now - lastDateObj) / (24 * 3600 * 1000));
          
          // Shift times forward by daysSince lunar days (~24h 50m each)
          const shiftMs = daysSince * LUNAR_DAY_MS;
          
          console.log(`No current data for ${today}, extrapolating from ${lastDate} (+${daysSince} lunar days)`);
          
          // Create extrapolated data for today
          todayData = {
            slacks: lastData.slacks.map(timeStr => {
              const [h, m] = timeStr.split(':').map(Number);
              const originalMs = h * 3600000 + m * 60000;
              const shiftedMs = (originalMs + shiftMs) % (24 * 3600000);
              const newH = Math.floor(shiftedMs / 3600000);
              const newM = Math.floor((shiftedMs % 3600000) / 60000);
              return `${String(newH).padStart(2, '0')}:${String(newM).padStart(2, '0')}`;
            }),
            maxes: lastData.maxes.map(max => {
              const [h, m] = max.time.split(':').map(Number);
              const originalMs = h * 3600000 + m * 60000;
              const shiftedMs = (originalMs + shiftMs) % (24 * 3600000);
              const newH = Math.floor(shiftedMs / 3600000);
              const newM = Math.floor((shiftedMs % 3600000) / 60000);
              return {
                time: `${String(newH).padStart(2, '0')}:${String(newM).padStart(2, '0')}`,
                speed: max.speed * 0.95 // Slightly reduce confidence for extrapolated data
              };
            })
          };
          
          // Also extrapolate tomorrow
          const shiftMsTomorrow = (daysSince + 1) * LUNAR_DAY_MS;
          tomorrowData = {
            slacks: lastData.slacks.map(timeStr => {
              const [h, m] = timeStr.split(':').map(Number);
              const originalMs = h * 3600000 + m * 60000;
              const shiftedMs = (originalMs + shiftMsTomorrow) % (24 * 3600000);
              const newH = Math.floor(shiftedMs / 3600000);
              const newM = Math.floor((shiftedMs % 3600000) / 60000);
              return `${String(newH).padStart(2, '0')}:${String(newM).padStart(2, '0')}`;
            }),
            maxes: lastData.maxes.map(max => {
              const [h, m] = max.time.split(':').map(Number);
              const originalMs = h * 3600000 + m * 60000;
              const shiftedMs = (originalMs + shiftMsTomorrow) % (24 * 3600000);
              const newH = Math.floor(shiftedMs / 3600000);
              const newM = Math.floor((shiftedMs % 3600000) / 60000);
              return {
                time: `${String(newH).padStart(2, '0')}:${String(newM).padStart(2, '0')}`,
                speed: max.speed * 0.95
              };
            })
          };
        }
      }
      
      const events = [];
      const slackWindows = [];
      
      if (todayData) {
        // Parse today's data
        const todayBase = new Date(now);
        todayBase.setHours(0, 0, 0, 0);
        
        // Collect all slacks and maxes from today and tomorrow for interpolation
        const allEvents = [];
        
        // Add today's slacks
        todayData.slacks.forEach(timeStr => {
          const slackTime = parseTimeToday(timeStr, todayBase);
          allEvents.push({ time: slackTime, type: 'slack', speed: 0 });
        });
        
        // Add today's maxes
        todayData.maxes.forEach(max => {
          const maxTime = parseTimeToday(max.time, todayBase);
          allEvents.push({ time: maxTime, type: max.speed > 0 ? 'max-flood' : 'max-ebb', speed: max.speed });
        });
        
        // Add tomorrow's early events
        if (tomorrowData) {
          const tomorrowBase = new Date(tomorrow);
          tomorrowBase.setHours(0, 0, 0, 0);
          
          tomorrowData.slacks.slice(0, 3).forEach(timeStr => {
            const slackTime = parseTimeToday(timeStr, tomorrowBase);
            allEvents.push({ time: slackTime, type: 'slack', speed: 0 });
          });
          
          tomorrowData.maxes.slice(0, 3).forEach(max => {
            const maxTime = parseTimeToday(max.time, tomorrowBase);
            allEvents.push({ time: maxTime, type: max.speed > 0 ? 'max-flood' : 'max-ebb', speed: max.speed });
          });
        }
        
        // Sort all events by time
        allEvents.sort((a, b) => a.time - b.time);
        
        // Find the events immediately before and after now
        let prevEvent = null;
        let nextEvent = null;
        
        for (let i = 0; i < allEvents.length; i++) {
          if (allEvents[i].time <= now) {
            prevEvent = allEvents[i];
          } else {
            nextEvent = allEvents[i];
            break;
          }
        }
        
        // Calculate current speed using sinusoidal interpolation
        let currentSpeed = 0;
        let isFlood = false;
        let isEbb = false;
        let inOneKnotWindow = false;
        
        if (prevEvent && nextEvent) {
          const totalTime = nextEvent.time - prevEvent.time;
          const elapsed = now - prevEvent.time;
          const progress = elapsed / totalTime;
          
          if (prevEvent.type === 'slack' && nextEvent.type !== 'slack') {
            // Going from slack to max: use sine curve rising
            // speed = nextMax * sin(progress * Ï€/2)
            currentSpeed = nextEvent.speed * Math.sin(progress * Math.PI / 2);
          } else if (prevEvent.type !== 'slack' && nextEvent.type === 'slack') {
            // Going from max to slack: use cosine curve falling
            // speed = prevMax * cos(progress * Ï€/2)
            currentSpeed = prevEvent.speed * Math.cos(progress * Math.PI / 2);
          } else if (prevEvent.type === 'slack' && nextEvent.type === 'slack') {
            // Between two slacks - find the max in between
            const middleMax = allEvents.find(e => e.time > prevEvent.time && e.time < nextEvent.time && e.type !== 'slack');
            if (middleMax) {
              const timeToMax = middleMax.time - prevEvent.time;
              const totalHalf = nextEvent.time - prevEvent.time;
              if (elapsed < timeToMax) {
                // Rising toward max
                const halfProgress = elapsed / timeToMax;
                currentSpeed = middleMax.speed * Math.sin(halfProgress * Math.PI / 2);
              } else {
                // Falling from max
                const halfProgress = (elapsed - timeToMax) / (totalHalf - timeToMax);
                currentSpeed = middleMax.speed * Math.cos(halfProgress * Math.PI / 2);
              }
            }
          } else {
            // Between two maxes - should go through slack
            // Simple linear interpolation as fallback
            currentSpeed = prevEvent.speed + (nextEvent.speed - prevEvent.speed) * progress;
          }
        } else if (prevEvent) {
          // After last event, estimate decay
          currentSpeed = prevEvent.speed * 0.5;
        }
        
        isFlood = currentSpeed > 0.1;
        isEbb = currentSpeed < -0.1;
        inOneKnotWindow = Math.abs(currentSpeed) <= 1.0;
        
        // Build events list for display (future events only)
        allEvents.forEach(e => {
          if (e.time > now && e.type !== 'slack') {
            events.push({
              time: e.time,
              type: e.type,
              speed: Math.abs(e.speed).toFixed(1)
            });
          } else if (e.time > now && e.type === 'slack') {
            // Determine high or low slack
            const prevMax = allEvents.filter(m => m.time < e.time && m.type !== 'slack').pop();
            events.push({
              time: e.time,
              type: prevMax && prevMax.speed > 0 ? 'high-slack' : 'low-slack',
              speed: 0
            });
          }
        });
        
        // Calculate slack windows (1-knot windows) for today and future days
        // A 1-knot window is roughly when current drops below 1 knot around slack
        
        // First, collect ALL slacks and maxes from all available days
        const allSlacks = [];
        const allMaxes = [];
        
        // Helper to add data from a day
        const addDayData = (dayData, dayBase) => {
          if (!dayData) return;
          dayData.slacks.forEach(s => {
            allSlacks.push(parseTimeToday(s, dayBase));
          });
          dayData.maxes.forEach(m => {
            allMaxes.push({ ...m, time: parseTimeToday(m.time, dayBase) });
          });
        };
        
        // Add yesterday's data (for early morning slacks)
        const yesterday = new Date(todayBase);
        yesterday.setDate(yesterday.getDate() - 1);
        const yesterdayStr = getLocalDateString(yesterday);
        const yesterdayData = referenceData[yesterdayStr];
        if (yesterdayData) {
          const yesterdayBase = new Date(yesterday);
          yesterdayBase.setHours(0, 0, 0, 0);
          addDayData(yesterdayData, yesterdayBase);
        }
        
        // Add today's data
        addDayData(todayData, todayBase);
        
        // Add tomorrow's data
        if (tomorrowData) {
          const tomorrowBase = new Date(tomorrow);
          tomorrowBase.setHours(0, 0, 0, 0);
          addDayData(tomorrowData, tomorrowBase);
        }
        
        // Add day after tomorrow's data
        const dayAfterTomorrow = new Date(tomorrow);
        dayAfterTomorrow.setDate(dayAfterTomorrow.getDate() + 1);
        const dayAfterTomorrowStr = getLocalDateString(dayAfterTomorrow);
        const dayAfterTomorrowData = referenceData[dayAfterTomorrowStr];
        if (dayAfterTomorrowData) {
          const dayAfterBase = new Date(dayAfterTomorrow);
          dayAfterBase.setHours(0, 0, 0, 0);
          addDayData(dayAfterTomorrowData, dayAfterBase);
        }
        
        // Sort all events by time
        allSlacks.sort((a, b) => a - b);
        allMaxes.sort((a, b) => a.time - b.time);
        
        // Now calculate windows for each slack
        allSlacks.forEach((slackTime) => {
          if (slackTime < new Date(now.getTime() - 2 * 3600000)) return; // Skip past slacks
          
          // Find the max before and after this slack from the combined list
          const maxBefore = allMaxes.filter(m => m.time < slackTime).pop();
          const maxAfter = allMaxes.find(m => m.time > slackTime);
          
          if (maxBefore || maxAfter) {
            let windowStart = slackTime;
            let windowEnd = slackTime;
            
            // The current follows approximately: speed = peak * sin(Ï€/2 * t/T)
            // where t is time from slack and T is time from slack to max
            // We want to find when |speed| = 1 knot
            // 1 = peak * sin(Ï€/2 * t/T)
            // sin(Ï€/2 * t/T) = 1/peak
            // t/T = (2/Ï€) * arcsin(1/peak)
            // t = T * (2/Ï€) * arcsin(1/peak)
            
            if (maxBefore) {
              const beforePeak = Math.abs(maxBefore.speed);
              const timeFromSlackToMaxBefore = slackTime - maxBefore.time; // T
              
              if (beforePeak > 1) {
                // Time before slack when current drops to 1 knot
                const t = timeFromSlackToMaxBefore * (2 / Math.PI) * Math.asin(1 / beforePeak);
                windowStart = new Date(slackTime.getTime() - t);
              } else {
                // Max is less than 1 knot, window starts at max
                windowStart = maxBefore.time;
              }
            }
            
            if (maxAfter) {
              const afterPeak = Math.abs(maxAfter.speed);
              const timeFromSlackToMaxAfter = maxAfter.time - slackTime; // T
              
              if (afterPeak > 1) {
                // Time after slack when current rises to 1 knot
                const t = timeFromSlackToMaxAfter * (2 / Math.PI) * Math.asin(1 / afterPeak);
                windowEnd = new Date(slackTime.getTime() + t);
              } else {
                // Max is less than 1 knot, window ends at max
                windowEnd = maxAfter.time;
              }
            }
            
            if (windowEnd > now) {
              slackWindows.push({
                start: windowStart,
                slack: slackTime,
                end: windowEnd,
                type: maxBefore && maxBefore.speed > 0 ? 'high-slack' : 'low-slack',
                nextDirection: maxAfter && maxAfter.speed > 0 ? 'flood' : 'ebb'
              });
            }
          }
        });
        
        // Sort windows by slack time
        slackWindows.sort((a, b) => a.slack - b.slack);
        
        return {
          currentSpeed: Math.abs(currentSpeed).toFixed(1),
          isFlood,
          isEbb,
          isSlack: !isFlood && !isEbb,
          inOneKnotWindow,
          direction: isFlood || (!isFlood && !isEbb && currentSpeed >= 0) ? floodDir : ebbDir,
          directionDeg: isFlood || (!isFlood && !isEbb && currentSpeed >= 0) ? stationConfig.floodDeg : stationConfig.ebbDeg,
          events: events.slice(0, 8),
          slackWindows: slackWindows.filter(w => w.end > now).slice(0, 5),
          progressPercent: 50,
          hasReferenceData: true
        };
      }
      
      // Fallback to harmonic calculation if no reference data
      return calculateCurrentsFallback(stationConfig);
    }
    
    // Fallback harmonic calculation (less accurate)
    function calculateCurrentsFallback(stationConfig) {
      const now = new Date();
      const base = new Date(now);
      base.setHours(0, 0, 0, 0);
      
      const M2_period = 12.42 * 3600000;
      const { maxFlood, maxEbb, floodDir, ebbDir, phaseOffset } = stationConfig;
      
      const nowT = now.getTime() - base.getTime();
      const phase = 2 * Math.PI * (nowT + phaseOffset) / M2_period;
      const rawNow = Math.sin(phase);
      const currentSpeed = rawNow > 0 ? rawNow * maxFlood : rawNow * maxEbb;
      
      return {
        currentSpeed: Math.abs(currentSpeed).toFixed(1),
        isFlood: currentSpeed > 0.1,
        isEbb: currentSpeed < -0.1,
        isSlack: Math.abs(currentSpeed) <= 0.1,
        inOneKnotWindow: Math.abs(currentSpeed) <= 1.0,
        direction: currentSpeed >= 0 ? floodDir : ebbDir,
        directionDeg: currentSpeed >= 0 ? stationConfig.floodDeg : stationConfig.ebbDeg,
        events: [],
        slackWindows: [],
        progressPercent: 50,
        hasReferenceData: false
      };
    }

    // Station configurations
    const FIRST_NARROWS = {
      maxFlood: 3.5,  // knots
      maxEbb: 5.0,    // knots (stronger)
      floodDir: 'SE into harbour',
      ebbDir: 'NW out to Strait',
      floodDeg: 135,
      ebbDeg: 315,
      phaseOffset: 1.5 * 3600000, // Current phase offset from Point Atkinson tide
      // Tide-derived model parameters
      slackLagAfterTide: 0.5 * 3600000, // Slack occurs ~30 min after high/low tide
      maxCurrentLagAfterTide: 3.5 * 3600000 // Max current ~3.5 hours after tide extreme
    };

    const SECOND_NARROWS = {
      maxFlood: 3.0,
      maxEbb: 4.5,
      floodDir: 'E into harbour',
      ebbDir: 'W out to Strait',
      floodDeg: 90,
      ebbDeg: 270,
      phaseOffset: 2.5 * 3600000, // Second Narrows lags First Narrows by ~1 hour
      // Tide-derived model parameters  
      slackLagAfterTide: 1.0 * 3600000, // Second Narrows slack ~1 hour after tide
      maxCurrentLagAfterTide: 4.0 * 3600000 // Max current ~4 hours after tide extreme
    };
    
    // =====================================================
    // AUTOMATIC CURRENT CALCULATION FROM LIVE TIDE DATA
    // =====================================================
    // This calculates currents perpetually using CHS tide predictions
    // No more hardcoded XTide data needed!
    
    /**
     * Calculate currents from live CHS tide data (hi-lo predictions)
     * 
     * Physics model:
     * - Current velocity follows sinusoidal pattern between slack waters
     * - Slack water occurs shortly after high/low tide (with station-specific lag)
     * - Maximum current occurs mid-way between slack waters
     * - Ebb current (outward) occurs during falling tide
     * - Flood current (inward) occurs during rising tide
     * 
     * @param {Object} stationConfig - Station parameters (maxFlood, maxEbb, etc.)
     * @param {Object} tideData - Live tide data from CHS in format { 'YYYY-MM-DD': [{time, height, type}] }
     * @returns {Object} - Current state in same format as calculateCurrents()
     */
    function calculateCurrentsFromLiveTide(stationConfig, tideData) {
      const now = new Date();
      const { maxFlood, maxEbb, floodDir, ebbDir, slackLagAfterTide, maxCurrentLagAfterTide } = stationConfig;
      
      // Collect all tide events from available data
      const allTides = [];
      Object.keys(tideData).forEach(dateStr => {
        const dayTides = tideData[dateStr];
        dayTides.forEach(tide => {
          const [hours, mins] = tide.time.split(':').map(Number);
          const tideTime = new Date(dateStr + 'T00:00:00');
          tideTime.setHours(hours, mins, 0, 0);
          allTides.push({
            time: tideTime,
            height: tide.height,
            type: tide.type
          });
        });
      });
      
      // Sort by time
      allTides.sort((a, b) => a.time - b.time);
      
      if (allTides.length < 2) {
        console.warn('Insufficient tide data for current calculation');
        return calculateCurrentsFallback(stationConfig);
      }
      
      // Generate derived current events (slacks and maxes) from tide events
      const currentEvents = [];
      
      for (let i = 0; i < allTides.length; i++) {
        const tide = allTides[i];
        const nextTide = allTides[i + 1];
        
        // Slack occurs shortly after each high/low tide
        const slackTime = new Date(tide.time.getTime() + slackLagAfterTide);
        currentEvents.push({
          time: slackTime,
          type: 'slack',
          speed: 0,
          tideType: tide.type // 'high' or 'low'
        });
        
        // Maximum current occurs between this tide and the next
        if (nextTide) {
          const maxTime = new Date(tide.time.getTime() + maxCurrentLagAfterTide);
          
          // Determine if flood or ebb based on tide transition
          // After HIGH tide â†’ falling water â†’ EBB (outward)
          // After LOW tide â†’ rising water â†’ FLOOD (inward)
          const isEbbMax = tide.type === 'high';
          const peakSpeed = isEbbMax ? -maxEbb : maxFlood;
          
          // Scale max speed by tidal range (bigger range = stronger current)
          const tidalRange = Math.abs(nextTide.height - tide.height);
          const avgRange = 12; // typical tidal range in feet for Vancouver
          const rangeMultiplier = Math.min(1.3, Math.max(0.7, tidalRange / avgRange));
          
          currentEvents.push({
            time: maxTime,
            type: isEbbMax ? 'max-ebb' : 'max-flood',
            speed: peakSpeed * rangeMultiplier
          });
        }
      }
      
      // Sort all current events by time
      currentEvents.sort((a, b) => a.time - b.time);
      
      // Find events surrounding now
      let prevEvent = null;
      let nextEvent = null;
      
      for (let i = 0; i < currentEvents.length; i++) {
        if (currentEvents[i].time <= now) {
          prevEvent = currentEvents[i];
        } else {
          nextEvent = currentEvents[i];
          break;
        }
      }
      
      // Calculate current speed using sinusoidal interpolation
      let currentSpeed = 0;
      let progressPercent = 50;
      
      if (prevEvent && nextEvent) {
        const totalTime = nextEvent.time - prevEvent.time;
        const elapsed = now - prevEvent.time;
        const progress = elapsed / totalTime;
        progressPercent = Math.min(100, Math.max(0, progress * 100));
        
        if (prevEvent.type === 'slack' && nextEvent.type !== 'slack') {
          // Going from slack to max: sine curve rising
          currentSpeed = nextEvent.speed * Math.sin(progress * Math.PI / 2);
        } else if (prevEvent.type !== 'slack' && nextEvent.type === 'slack') {
          // Going from max to slack: cosine curve falling
          currentSpeed = prevEvent.speed * Math.cos(progress * Math.PI / 2);
        } else {
          // Between two events of same type (shouldn't happen often)
          currentSpeed = prevEvent.speed + (nextEvent.speed - prevEvent.speed) * progress;
        }
      } else if (prevEvent) {
        currentSpeed = prevEvent.speed * 0.5;
      }
      
      const isFlood = currentSpeed > 0.1;
      const isEbb = currentSpeed < -0.1;
      const inOneKnotWindow = Math.abs(currentSpeed) <= 1.0;
      
      // Build events list for display
      const events = currentEvents
        .filter(e => e.time > now && e.type !== 'slack')
        .slice(0, 8)
        .map(e => ({
          time: e.time,
          type: e.type,
          speed: Math.abs(e.speed).toFixed(1)
        }));
      
      // Calculate slack windows (1-knot windows)
      const slackWindows = [];
      const slackEvents = currentEvents.filter(e => e.type === 'slack' && e.time > new Date(now.getTime() - 2 * 3600000));
      
      slackEvents.forEach(slack => {
        const maxBefore = currentEvents.filter(m => m.time < slack.time && m.type !== 'slack').pop();
        const maxAfter = currentEvents.find(m => m.time > slack.time && m.type !== 'slack');
        
        if (maxBefore || maxAfter) {
          let windowStart = slack.time;
          let windowEnd = slack.time;
          
          if (maxBefore) {
            const beforePeak = Math.abs(maxBefore.speed);
            const timeFromSlackToMaxBefore = slack.time - maxBefore.time;
            if (beforePeak > 1) {
              const t = timeFromSlackToMaxBefore * (2 / Math.PI) * Math.asin(Math.min(1, 1 / beforePeak));
              windowStart = new Date(slack.time.getTime() - t);
            } else {
              windowStart = maxBefore.time;
            }
          }
          
          if (maxAfter) {
            const afterPeak = Math.abs(maxAfter.speed);
            const timeFromSlackToMaxAfter = maxAfter.time - slack.time;
            if (afterPeak > 1) {
              const t = timeFromSlackToMaxAfter * (2 / Math.PI) * Math.asin(Math.min(1, 1 / afterPeak));
              windowEnd = new Date(slack.time.getTime() + t);
            } else {
              windowEnd = maxAfter.time;
            }
          }
          
          if (windowEnd > now) {
            slackWindows.push({
              start: windowStart,
              slack: slack.time,
              end: windowEnd,
              type: slack.tideType === 'high' ? 'high-slack' : 'low-slack',
              nextDirection: maxAfter && maxAfter.speed > 0 ? 'flood' : 'ebb'
            });
          }
        }
      });
      
      slackWindows.sort((a, b) => a.slack - b.slack);
      
      return {
        currentSpeed: Math.abs(currentSpeed).toFixed(1),
        isFlood,
        isEbb,
        isSlack: !isFlood && !isEbb,
        inOneKnotWindow,
        direction: isFlood || (!isFlood && !isEbb && currentSpeed >= 0) ? floodDir : ebbDir,
        directionDeg: isFlood || (!isFlood && !isEbb && currentSpeed >= 0) ? stationConfig.floodDeg : stationConfig.ebbDeg,
        events: events.slice(0, 8),
        slackWindows: slackWindows.filter(w => w.end > now).slice(0, 5),
        progressPercent,
        hasReferenceData: true,
        dataSource: 'live-tide' // Mark that this came from live tide data
      };
    }
    
    // Global flag to track if we're using live or fallback current data
    let currentDataSource = { first: 'fallback', second: 'fallback' };

    function updateCurrentsDisplay() {
      // Try to use live tide data for automatic perpetual current predictions
      const useLiveTide = liveTideData.pointAtkinson && Object.keys(liveTideData.pointAtkinson).length > 2;
      
      // Second Narrows
      let second;
      if (useLiveTide) {
        second = calculateCurrentsFromLiveTide(SECOND_NARROWS, liveTideData.pointAtkinson);
        currentDataSource.second = 'live-tide';
        console.log('Second Narrows: Using live CHS tide-derived currents');
      } else {
        second = calculateCurrents(SECOND_NARROWS, SECOND_NARROWS_DATA);
        currentDataSource.second = second.hasReferenceData ? 'xtide-reference' : 'harmonic-fallback';
      }
      document.getElementById('secondNarrowsSpeed').textContent = second.currentSpeed;
      
      const secondState = document.getElementById('secondNarrowsState');
      const secondArrow = document.getElementById('secondNarrowsArrow');
      const secondProgress = document.getElementById('secondNarrowsProgress');
      const secondDir = document.getElementById('secondNarrowsDir');
      
      if (second.isSlack) {
        secondState.textContent = 'SLACK';
        secondState.className = 'current-state slack';
        secondArrow.className = 'current-arrow slack';
        secondArrow.style.transform = 'rotate(0deg)';
        secondProgress.className = 'timeline-progress flood';
        secondDir.textContent = 'Minimal current â€” turning';
      } else if (second.isFlood) {
        secondState.textContent = 'FLOOD';
        secondState.className = 'current-state flood';
        secondArrow.className = 'current-arrow flood';
        secondArrow.style.transform = `rotate(${SECOND_NARROWS.floodDeg}deg)`;
        secondProgress.className = 'timeline-progress flood';
        secondDir.textContent = `Flowing ${second.direction} (${second.directionDeg}Â°)`;
      } else {
        secondState.textContent = 'EBB';
        secondState.className = 'current-state ebb';
        secondArrow.className = 'current-arrow ebb';
        secondArrow.style.transform = `rotate(${SECOND_NARROWS.ebbDeg}deg)`;
        secondProgress.className = 'timeline-progress ebb';
        secondDir.textContent = `Flowing ${second.direction} (${second.directionDeg}Â°)`;
      }
      
      secondProgress.style.width = `${second.progressPercent}%`;
      document.getElementById('secondNarrowsMarker').style.left = `${second.progressPercent}%`;
      
      // Second Narrows Events
      const secondEventsEl = document.getElementById('secondNarrowsEvents');
      const secondNextFlood = second.events.find(e => e.type === 'max-flood');
      const secondNextEbb = second.events.find(e => e.type === 'max-ebb');
      const secondMaxEvents = [secondNextFlood, secondNextEbb].filter(Boolean);
      secondEventsEl.innerHTML = secondMaxEvents.map(e => `
        <div class="current-event">
          <div class="event-time">${formatTime(e.time)}</div>
          <div class="event-type ${e.type}">${e.type === 'max-flood' ? 'â–² Max Flood' : 'â–¼ Max Ebb'}</div>
          <div class="event-speed">${e.speed} kts</div>
        </div>
      `).join('');
      
      // Second Narrows Slack Windows
      renderSlackWindows('secondNarrowsWindows', second.slackWindows, second.inOneKnotWindow);
      
      // Update Second Narrows data source indicator
      updateCurrentDataSourceIndicator('secondNarrowsDataSource', currentDataSource.second);
    }
    
    // Update the data source indicator in the UI
    function updateCurrentDataSourceIndicator(elementId, source) {
      const el = document.getElementById(elementId);
      if (!el) return;
      
      switch (source) {
        case 'live-tide':
          el.textContent = 'â— Live CHS Tide-Derived';
          el.style.color = 'var(--teal-accent)';
          el.title = 'Currents calculated automatically from live CHS tide predictions - perpetual & self-updating';
          break;
        case 'xtide-reference':
          el.textContent = 'â—‹ XTide Reference';
          el.style.color = 'var(--amber-warning)';
          el.title = 'Using pre-computed XTide reference data - limited date range';
          break;
        case 'harmonic-fallback':
          el.textContent = 'â—Œ Harmonic Estimate';
          el.style.color = 'var(--coral-alert)';
          el.title = 'Using basic harmonic calculation - less accurate';
          break;
        default:
          el.textContent = '? Unknown';
          el.style.color = 'var(--mist-gray)';
      }
    }
    
    // Render slack windows visual
    function renderSlackWindows(elementId, windows, currentlyInWindow) {
      const container = document.getElementById(elementId);
      const now = new Date();
      const todayStr = getLocalDateString(now);
      
      if (windows.length === 0) {
        container.innerHTML = '<div class="slack-windows-title">1-Knot Safe Passage Windows</div><div style="color: var(--mist-gray); font-size: 0.75rem;">No upcoming windows in reference data</div>';
        return;
      }
      
      let html = '<div class="slack-windows-title">1-Knot Safe Passage Windows</div>';
      
      windows.forEach((w, idx) => {
        const duration = Math.round((w.end - w.start) / 60000); // minutes
        const isActive = now >= w.start && now <= w.end;
        const isPast = now > w.end;
        
        if (isPast) return;
        
        // Check if this is today or a future day
        const windowDateStr = getLocalDateString(w.slack);
        const isToday = windowDateStr === todayStr;
        const dayLabel = isToday ? '' : w.slack.toLocaleDateString('en-CA', { weekday: 'short', month: 'short', day: 'numeric' }) + ' â€” ';
        
        // Calculate positions for the visual bar (as percentage)
        const totalSpan = w.end - w.start;
        const slackPos = ((w.slack - w.start) / totalSpan) * 100;
        const nowPos = isActive ? ((now - w.start) / totalSpan) * 100 : -1;
        
        // Determine what comes before and after slack
        const beforeSlack = w.type === 'high-slack' ? 'flood' : 'ebb';
        const afterSlack = w.nextDirection;
        
        html += `
          <div class="window-card ${isActive ? 'active' : ''}">
            <div class="window-header">
              <div class="window-type">${dayLabel}${w.type === 'high-slack' ? 'High Slack' : 'Low Slack'} Window</div>
              ${isActive ? '<div class="window-badge">â— NOW IN WINDOW</div>' : idx === 0 ? '<div class="window-badge">Next</div>' : ''}
            </div>
            <div class="window-visual">
              <div class="window-${beforeSlack}-zone" style="left: 0; width: ${slackPos}%"></div>
              <div class="window-${afterSlack}-zone" style="left: ${slackPos}%; width: ${100 - slackPos}%"></div>
              <div class="window-safe-zone" style="left: 0; width: 100%"></div>
              <div class="window-slack-marker" style="left: ${slackPos}%"></div>
              ${isActive ? `<div class="window-now-marker" style="left: ${nowPos}%"></div>` : ''}
            </div>
            <div class="window-times">
              <div class="window-time-block">
                <div class="window-time-label">Window Opens</div>
                <div class="window-time-value">${formatTime(w.start)}</div>
              </div>
              <div class="window-time-block center">
                <div class="window-time-label">Slack</div>
                <div class="window-time-value slack">${formatTime(w.slack)}</div>
              </div>
              <div class="window-time-block" style="text-align: right">
                <div class="window-time-label">Window Closes</div>
                <div class="window-time-value">${formatTime(w.end)}</div>
              </div>
            </div>
            <div class="window-duration">
              Window duration: <strong>${duration} minutes</strong> 
              ${isActive ? ` â€¢ ${Math.round((w.end - now) / 60000)} min remaining` : ''}
            </div>
          </div>
        `;
      });
      
      container.innerHTML = html;
    }

    function updateCurrent(d) {
      const c = d.current;
      const wKts = msToKnots(c.wind_speed_10m), gKts = msToKnots(c.wind_gusts_10m), wDir = c.wind_direction_10m;
      
      // Old elements (hidden but keep for compatibility)
      document.getElementById('currentWind').textContent = wKts;
      document.getElementById('currentGust').textContent = gKts;
      document.getElementById('windDirText').textContent = `${getWindDirection(wDir)} (${Math.round(wDir)}Â°)`;
      document.getElementById('compassNeedle').style.transform = `rotate(${wDir}deg)`;
      document.getElementById('currentTemp').textContent = Math.round(c.temperature_2m);
      document.getElementById('currentHumidity').textContent = c.relative_humidity_2m || 'â€”';
      document.getElementById('feelsLike').textContent = c.apparent_temperature ? Math.round(c.apparent_temperature) : 'â€”';
      document.getElementById('currentConditions').textContent = weatherCodes[c.weather_code] || 'Unknown';
      document.getElementById('cloudCover').textContent = c.cloud_cover || 'â€”';
      document.getElementById('pressure').textContent = c.pressure_msl ? Math.round(c.pressure_msl) : 'â€”';
      document.getElementById('updateTime').textContent = formatDateTime(new Date());
      
      // Update source info
      document.getElementById('weatherStation').textContent = d.station || 'Model Data';
      document.getElementById('weatherSource').textContent = d.source || 'Open-Meteo';
      document.getElementById('alertSourceName').textContent = d.source || 'Open-Meteo';
      
      // NEW: Update unified status bar
      document.getElementById('currentWind2').textContent = wKts;
      document.getElementById('currentGust2').textContent = gKts;
      document.getElementById('windDirText2').textContent = `${getWindDirection(wDir)} (${Math.round(wDir)}Â°)`;
      document.getElementById('miniNeedle').style.transform = `rotate(${wDir}deg)`;
      document.getElementById('currentTemp2').textContent = Math.round(c.temperature_2m);
      document.getElementById('currentHumidity2').textContent = c.relative_humidity_2m || 'â€”';
      document.getElementById('feelsLike2').textContent = c.apparent_temperature ? Math.round(c.apparent_temperature) : 'â€”';
      document.getElementById('currentConditions2').textContent = weatherCodes[c.weather_code] || 'Unknown';
      document.getElementById('cloudCover2').textContent = c.cloud_cover || 'â€”';
      document.getElementById('pressure2').textContent = c.pressure_msl ? Math.round(c.pressure_msl) : 'â€”';
    }

    function build3DayForecast(d) {
      const container = document.getElementById('marineForecastContainer');
      container.innerHTML = '';
      const h = d.hourly;
      const now = new Date();
      
      // Find start index (current hour)
      let start = h.time.findIndex(t => new Date(t) >= now);
      if (start < 0) start = 0;
      
      // Collect 48 hours of data and create cells directly in container
      let lastDay = null;
      for (let i = start; i < Math.min(start + 48, h.time.length); i++) {
        const t = new Date(h.time[i]);
        const hour = {
          time: t,
          temp: Math.round(h.temperature_2m[i]),
          windSpeed: msToKnots(h.wind_speed_10m[i]),
          windDir: getWindDirection(h.wind_direction_10m[i]),
          windDirDeg: h.wind_direction_10m[i],
          precipitation: h.precipitation[i],
          weatherCode: h.weather_code ? h.weather_code[i] : 0,
          cloudCover: h.cloud_cover ? h.cloud_cover[i] : 0
        };
        
        const isCurrent = i === start;
        const cell = createHourlyCell(hour, isCurrent, lastDay);
        lastDay = t.getDate();
        container.appendChild(cell);
      }
    }
    
    function createHourlyCell(hour, isCurrent, lastDay) {
      const cell = document.createElement('div');
      cell.className = `hourly-cell ${isCurrent ? 'current' : ''}`;
      
      // Get weather icon based on weather code
      const icon = weatherIcons[hour.weatherCode] || getSimpleWeatherIcon(hour);
      
      // Show day label at midnight or when day changes
      const isNewDay = lastDay !== null && hour.time.getDate() !== lastDay;
      const showDayLabel = hour.time.getHours() === 0 || isNewDay || lastDay === null;
      const dayLabel = showDayLabel ? hour.time.toLocaleDateString('en-CA', { weekday: 'short' }) : '';
      
      cell.innerHTML = `
        ${dayLabel ? `<div class="hourly-cell-day">${dayLabel}</div>` : ''}
        <div class="hourly-cell-time">${formatTime(hour.time)}</div>
        <div class="hourly-cell-icon">${icon}</div>
        <div class="hourly-cell-temp">${hour.temp}Â°</div>
        <div class="hourly-cell-wind ${getWindClass(hour.windSpeed)}">${hour.windSpeed}</div>
        <div class="hourly-cell-wind-dir">${hour.windDir}</div>
        <div class="hourly-cell-rain ${hour.precipitation < 0.1 ? 'none' : ''}">${hour.precipitation >= 0.1 ? hour.precipitation.toFixed(1) : 'â€”'}</div>
      `;
      
      return cell;
    }
    
    // Fallback simple weather icon based on conditions
    function getSimpleWeatherIcon(hour) {
      const isDay = hour.time.getHours() >= 6 && hour.time.getHours() < 20;
      if (hour.precipitation > 1) return 'ðŸŒ§ï¸';
      if (hour.precipitation > 0.1) return 'ðŸŒ¦ï¸';
      if (hour.cloudCover > 80) return 'â˜ï¸';
      if (hour.cloudCover > 40) return isDay ? 'â›…' : 'â˜ï¸';
      return isDay ? 'â˜€ï¸' : 'ðŸŒ™';
    }

    // Fraser River Water Level & Velocity Graph
    function drawFraserRiverGraph(canvasId, markerId, riverData) {
      const canvas = document.getElementById(canvasId);
      const marker = document.getElementById(markerId);
      if (!canvas) return;
      
      const ctx = canvas.getContext('2d');
      const container = canvas.parentElement;
      
      const width = container.offsetWidth || 800;
      const height = container.offsetHeight || 140;
      
      const dpr = window.devicePixelRatio || 1;
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
      ctx.scale(dpr, dpr);
      
      const now = new Date();
      const startTime = new Date(now.getTime() - 2 * 3600000);
      const endTime = new Date(startTime.getTime() + 72 * 3600000);
      
      // Collect all data points
      const points = [];
      for (let d = -1; d < 5; d++) {
        const date = new Date(now);
        date.setDate(date.getDate() + d);
        const dateStr = getLocalDateString(date);
        
        if (riverData[dateStr]) {
          riverData[dateStr].forEach(entry => {
            const [hours, mins] = entry.time.split(':').map(Number);
            const pointTime = new Date(date);
            pointTime.setHours(hours, mins || 0, 0, 0);
            
            if (pointTime >= startTime && pointTime <= endTime) {
              points.push({
                time: pointTime,
                level: entry.level,
                velocity: entry.velocity,
                x: (pointTime.getTime() - startTime.getTime()) / (endTime.getTime() - startTime.getTime())
              });
            }
          });
        }
      }
      
      points.sort((a, b) => a.time - b.time);
      
      if (points.length === 0) {
        ctx.fillStyle = 'rgba(200, 200, 200, 0.5)';
        ctx.font = '12px Inter';
        ctx.textAlign = 'center';
        ctx.fillText('No river data available', width / 2, height / 2);
        return;
      }
      
      // Find min/max
      const levels = points.map(p => p.level);
      const velocities = points.map(p => p.velocity);
      const minL = Math.min(...levels) - 0.2;
      const maxL = Math.max(...levels) + 0.2;
      const minV = Math.min(...velocities);
      const maxV = Math.max(...velocities);
      const maxAbsV = Math.max(Math.abs(minV), Math.abs(maxV), 0.3);
      
      const padding = { top: 20, bottom: 20, left: 40, right: 50 };
      const graphWidth = width - padding.left - padding.right;
      const graphHeight = height - padding.top - padding.bottom;
      
      // Store params for mouse interaction
      canvas.graphParams = { points, minL, maxL, minV: -maxAbsV, maxV: maxAbsV, padding, graphWidth, graphHeight, width, height, startTime, endTime, now };
      
      // Draw the graph
      drawFraserStaticGraph(ctx, canvas.graphParams);
      
      // Position NOW marker
      const nowX = padding.left + ((now.getTime() - startTime.getTime()) / (endTime.getTime() - startTime.getTime())) * graphWidth;
      marker.style.left = `${nowX}px`;
      
      // Mouse events
      if (!canvas.hasMouseListeners) {
        canvas.hasMouseListeners = true;
        
        canvas.addEventListener('mousemove', (e) => {
          const rect = canvas.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;
          drawFraserWithCrosshairs(canvas, mouseX, mouseY);
        });
        
        canvas.addEventListener('mouseleave', () => {
          const ctx = canvas.getContext('2d');
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          const dpr = window.devicePixelRatio || 1;
          ctx.scale(dpr, dpr);
          drawFraserStaticGraph(ctx, canvas.graphParams);
        });
      }
    }
    
    function drawFraserStaticGraph(ctx, params) {
      const { points, minL, maxL, minV, maxV, padding, graphWidth, graphHeight, width, height, startTime, endTime, now } = params;
      
      ctx.clearRect(0, 0, width, height);
      
      // Grid lines
      ctx.strokeStyle = 'rgba(0, 212, 170, 0.15)';
      ctx.lineWidth = 1;
      
      // Horizontal grid for water level
      for (let l = 0; l <= 3; l += 0.5) {
        if (l >= minL && l <= maxL) {
          const y = padding.top + graphHeight * (1 - (l - minL) / (maxL - minL));
          ctx.beginPath();
          ctx.moveTo(padding.left, y);
          ctx.lineTo(width - padding.right, y);
          ctx.stroke();
          
          // Level label on left
          ctx.fillStyle = 'rgba(0, 212, 170, 0.7)';
          ctx.font = '9px Inter';
          ctx.textAlign = 'right';
          ctx.fillText(`${l.toFixed(1)}m`, padding.left - 4, y + 3);
        }
      }
      
      // Velocity scale on right
      ctx.fillStyle = 'rgba(200, 200, 200, 0.5)';
      ctx.font = '8px Inter';
      ctx.textAlign = 'left';
      const velLabels = [-1, 0, 1];
      velLabels.forEach(v => {
        if (v >= minV && v <= maxV) {
          const y = padding.top + graphHeight * (1 - (v - minV) / (maxV - minV));
          ctx.fillText(`${v > 0 ? '+' : ''}${v.toFixed(1)} m/s`, width - padding.right + 4, y + 3);
        }
      });
      
      // Time labels
      ctx.fillStyle = 'rgba(200, 200, 200, 0.6)';
      ctx.font = '9px Inter';
      ctx.textAlign = 'center';
      
      // Draw time labels at specific hours (0, 6, 12, 18 of each day)
      const totalHours = 72;
      for (let h = 0; h <= totalHours; h += 6) {
        const labelTime = new Date(startTime.getTime() + h * 3600000);
        const x = padding.left + (h / totalHours) * graphWidth;
        const hour = labelTime.getHours();
        
        // Draw vertical grid line at midnight
        if (hour === 0) {
          ctx.strokeStyle = 'rgba(0, 212, 170, 0.25)';
          ctx.beginPath();
          ctx.moveTo(x, padding.top);
          ctx.lineTo(x, height - padding.bottom);
          ctx.stroke();
          ctx.fillText(formatDay(labelTime), x, height - 5);
        } else if (hour === 12) {
          // Draw lighter line and label at noon
          ctx.strokeStyle = 'rgba(0, 212, 170, 0.1)';
          ctx.beginPath();
          ctx.moveTo(x, padding.top);
          ctx.lineTo(x, height - padding.bottom);
          ctx.stroke();
          ctx.fillText('12:00', x, height - 5);
        } else if (hour === 6 || hour === 18) {
          // Just draw a subtle grid line
          ctx.strokeStyle = 'rgba(0, 212, 170, 0.08)';
          ctx.beginPath();
          ctx.moveTo(x, padding.top);
          ctx.lineTo(x, height - padding.bottom);
          ctx.stroke();
        }
      }
      
      // Draw zero velocity line
      const zeroY = padding.top + graphHeight * (1 - (0 - minV) / (maxV - minV));
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
      ctx.setLineDash([3, 3]);
      ctx.beginPath();
      ctx.moveTo(padding.left, zeroY);
      ctx.lineTo(width - padding.right, zeroY);
      ctx.stroke();
      ctx.setLineDash([]);
      
      // Draw water level curve - filled area
      ctx.beginPath();
      ctx.moveTo(padding.left, height - padding.bottom);
      points.forEach((p, i) => {
        const x = padding.left + p.x * graphWidth;
        const y = padding.top + graphHeight * (1 - (p.level - minL) / (maxL - minL));
        ctx.lineTo(x, y);
      });
      ctx.lineTo(padding.left + graphWidth, height - padding.bottom);
      ctx.closePath();
      
      const gradient = ctx.createLinearGradient(0, padding.top, 0, height - padding.bottom);
      gradient.addColorStop(0, 'rgba(0, 212, 170, 0.4)');
      gradient.addColorStop(1, 'rgba(0, 212, 170, 0.05)');
      ctx.fillStyle = gradient;
      ctx.fill();
      
      // Draw water level line
      ctx.beginPath();
      points.forEach((p, i) => {
        const x = padding.left + p.x * graphWidth;
        const y = padding.top + graphHeight * (1 - (p.level - minL) / (maxL - minL));
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.strokeStyle = 'rgba(0, 212, 170, 0.9)';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Draw velocity bars
      points.forEach((p, i) => {
        const x = padding.left + p.x * graphWidth;
        const barHeight = Math.abs(p.velocity) / (maxV - minV) * graphHeight * 0.3;
        
        if (p.velocity > 0) {
          // Downstream (ebb) - coral/red
          ctx.fillStyle = 'rgba(255, 107, 107, 0.4)';
          ctx.fillRect(x - 2, zeroY - barHeight, 4, barHeight);
        } else if (p.velocity < 0) {
          // Upstream (flood) - blue
          ctx.fillStyle = 'rgba(100, 181, 246, 0.4)';
          ctx.fillRect(x - 2, zeroY, 4, barHeight);
        }
      });
      
      // Legend
      ctx.font = '8px Inter';
      ctx.textAlign = 'left';
      ctx.fillStyle = 'rgba(255, 107, 107, 0.8)';
      ctx.fillText('â†“ Downstream (ebb)', padding.left + 5, padding.top + 10);
      ctx.fillStyle = 'rgba(100, 181, 246, 0.8)';
      ctx.fillText('â†‘ Upstream (flood)', padding.left + 5, padding.top + 20);
    }
    
    function drawFraserWithCrosshairs(canvas, mouseX, mouseY) {
      const ctx = canvas.getContext('2d');
      const params = canvas.graphParams;
      if (!params) return;
      
      const { points, minL, maxL, minV, maxV, padding, graphWidth, graphHeight, width, height, startTime, endTime, now } = params;
      
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      const dpr = window.devicePixelRatio || 1;
      ctx.scale(dpr, dpr);
      drawFraserStaticGraph(ctx, params);
      
      if (mouseX < padding.left || mouseX > width - padding.right || 
          mouseY < padding.top || mouseY > height - padding.bottom) {
        return;
      }
      
      const xRatio = (mouseX - padding.left) / graphWidth;
      const timeAtMouse = new Date(startTime.getTime() + xRatio * (endTime.getTime() - startTime.getTime()));
      
      // Find closest point
      let closestPoint = points[0];
      let minDist = Math.abs(points[0].x - xRatio);
      for (const p of points) {
        const dist = Math.abs(p.x - xRatio);
        if (dist < minDist) {
          minDist = dist;
          closestPoint = p;
        }
      }
      
      const levelY = padding.top + graphHeight * (1 - (closestPoint.level - minL) / (maxL - minL));
      
      // Crosshairs
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
      ctx.lineWidth = 1;
      ctx.setLineDash([5, 5]);
      
      ctx.beginPath();
      ctx.moveTo(mouseX, padding.top);
      ctx.lineTo(mouseX, height - padding.bottom);
      ctx.stroke();
      
      ctx.beginPath();
      ctx.moveTo(padding.left, levelY);
      ctx.lineTo(width - padding.right, levelY);
      ctx.stroke();
      
      ctx.setLineDash([]);
      
      // Point marker
      ctx.beginPath();
      ctx.arc(mouseX, levelY, 6, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(0, 212, 170, 1)';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Tooltip
      const timeStr = timeAtMouse.toLocaleString('en-CA', { 
        weekday: 'short', month: 'short', day: 'numeric',
        hour: '2-digit', minute: '2-digit', hour12: false 
      });
      
      const velDir = closestPoint.velocity > 0 ? 'â†“ Downstream' : closestPoint.velocity < 0 ? 'â†‘ Upstream' : 'â€” Slack';
      
      const tooltipWidth = 150;
      const tooltipHeight = 60;
      let tooltipX = mouseX + 15;
      let tooltipY = mouseY - 30;
      
      if (tooltipX + tooltipWidth > width - 10) tooltipX = mouseX - tooltipWidth - 15;
      if (tooltipY < 10) tooltipY = 10;
      if (tooltipY + tooltipHeight > height - 10) tooltipY = height - tooltipHeight - 10;
      
      ctx.fillStyle = 'rgba(13, 33, 55, 0.95)';
      ctx.strokeStyle = 'rgba(0, 212, 170, 0.5)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.roundRect(tooltipX, tooltipY, tooltipWidth, tooltipHeight, 6);
      ctx.fill();
      ctx.stroke();
      
      ctx.fillStyle = 'rgba(200, 200, 200, 0.9)';
      ctx.font = '9px Inter';
      ctx.textAlign = 'left';
      ctx.fillText(timeStr, tooltipX + 8, tooltipY + 14);
      
      ctx.fillStyle = 'rgba(0, 212, 170, 1)';
      ctx.font = 'bold 13px Inter';
      ctx.fillText(`${closestPoint.level.toFixed(2)} m`, tooltipX + 8, tooltipY + 32);
      
      ctx.fillStyle = closestPoint.velocity > 0 ? 'rgba(255, 107, 107, 0.9)' : 'rgba(100, 181, 246, 0.9)';
      ctx.font = '10px Inter';
      ctx.fillText(`${velDir} ${Math.abs(closestPoint.velocity).toFixed(2)} m/s`, tooltipX + 8, tooltipY + 48);
    }

    async function updateTidesDisplay() {
      // Try to fetch live tide data from CHS API (automatic, perpetual!)
      try {
        const tideData = await fetchLiveTideData();
        
        // Update currents with new tide data
        updateCurrentsDisplay();
        
        // Point Atkinson / Second Narrows tide graph
        if (tideData.pointAtkinson && Object.keys(tideData.pointAtkinson).length > 0) {
          drawTideGraph('secondNarrowsTideGraph', 'secondNarrowsNowMarker', tideData.pointAtkinson);
          console.log('Using live CHS tide data for Point Atkinson');
        } else {
          drawTideGraph('secondNarrowsTideGraph', 'secondNarrowsNowMarker', SECOND_NARROWS_TIDE_DATA);
          console.log('Using fallback tide data for Second Narrows');
        }
        
        // Steveston tide graph
        if (tideData.steveston && Object.keys(tideData.steveston).length > 0) {
          drawTideGraph('stevestonTideGraph', 'stevestonNowMarker', tideData.steveston);
          console.log('Using live CHS tide data for Steveston');
        } else {
          drawTideGraph('stevestonTideGraph', 'stevestonNowMarker', STEVESTON_TIDE_DATA_FALLBACK);
          console.log('Using fallback tide data for Steveston');
        }
      } catch (e) {
        console.warn('Failed to fetch live tide data, using fallback:', e);
        drawTideGraph('secondNarrowsTideGraph', 'secondNarrowsNowMarker', SECOND_NARROWS_TIDE_DATA);
        drawTideGraph('stevestonTideGraph', 'stevestonNowMarker', STEVESTON_TIDE_DATA_FALLBACK);
      }
      
      // Fetch live Fraser River data from CHS API with Avadepth-calibrated velocity model
      try {
        const fraserData = await fetchFraserRiverData();
        
        // Draw km 20 graph (primary display) - uses Avadepth-calibrated velocity model
        if (fraserData.km20 && Object.keys(fraserData.km20).length > 0) {
          drawFraserRiverGraph('fraserKm20Graph', 'fraserKm20NowMarker', fraserData.km20);
          const scenario = getAvadepthDischargeScenario(currentHopeDischarge);
          updateFraserDataStatus('fraserKm20Status', true, `Avadepth Model (${scenario} mÂ³/s)`);
        } else {
          // Fall back to old static km 20 data
          drawFraserRiverGraph('fraserKm20Graph', 'fraserKm20NowMarker', FRASER_SOUTH_ARM_DATA);
          updateFraserDataStatus('fraserKm20Status', false, 'Fallback Data');
        }
        
        // Draw Fraser River source station graphs
        if (fraserData.south && Object.keys(fraserData.south).length > 0) {
          drawFraserRiverGraph('fraserSouthGraph', 'fraserSouthNowMarker', fraserData.south);
          updateFraserDataStatus('fraserSouthStatus', true, 'Live CHS Data');
        } else {
          drawFraserRiverGraph('fraserSouthGraph', 'fraserSouthNowMarker', FRASER_SOUTH_ARM_DATA);
          updateFraserDataStatus('fraserSouthStatus', false, 'Fallback Data');
        }
        
        if (fraserData.north && Object.keys(fraserData.north).length > 0) {
          drawFraserRiverGraph('fraserNorthGraph', 'fraserNorthNowMarker', fraserData.north);
          updateFraserDataStatus('fraserNorthStatus', true, 'Live CHS Data');
        } else {
          drawFraserRiverGraph('fraserNorthGraph', 'fraserNorthNowMarker', FRASER_NORTH_ARM_DATA);
          updateFraserDataStatus('fraserNorthStatus', false, 'Fallback Data');
        }
      } catch (e) {
        console.warn('Failed to load live Fraser data, using fallback:', e);
        drawFraserRiverGraph('fraserKm20Graph', 'fraserKm20NowMarker', FRASER_SOUTH_ARM_DATA);
        drawFraserRiverGraph('fraserSouthGraph', 'fraserSouthNowMarker', FRASER_SOUTH_ARM_DATA);
        drawFraserRiverGraph('fraserNorthGraph', 'fraserNorthNowMarker', FRASER_NORTH_ARM_DATA);
        updateFraserDataStatus('fraserKm20Status', false, 'Fallback Data');
        updateFraserDataStatus('fraserSouthStatus', false, 'Fallback Data');
        updateFraserDataStatus('fraserNorthStatus', false, 'Fallback Data');
      }
    }
    
    function updateFraserDataStatus(elementId, isLive, label) {
      const el = document.getElementById(elementId);
      if (el) {
        el.textContent = label;
        el.style.color = isLive ? 'var(--teal-accent)' : 'var(--amber-warning)';
      }
    }

    async function initialize() {
      document.getElementById('loadingState').style.display = 'flex';
      document.getElementById('errorState').style.display = 'none';
      document.getElementById('mainContent').classList.remove('loaded');
      
      try {
        // Fetch weather and tide data in parallel
        const [weather] = await Promise.all([
          fetchWeatherData(),
          fetchLiveTideData() // This populates liveTideData for current calculations
        ]);
        
        updateCurrent(weather);
        build3DayForecast(weather);
        
        // Now update currents - this will use live tide data if available
        updateCurrentsDisplay();
        
        document.getElementById('loadingState').style.display = 'none';
        document.getElementById('mainContent').classList.add('loaded');
        
        // Draw tide graphs after content is visible
        requestAnimationFrame(() => {
          updateTidesDisplay();
        });
        
        // Fetch EC marine forecast (non-blocking)
        fetchECMarineForecast().catch(e => console.warn('EC Marine forecast error:', e));
      } catch (e) {
        console.error('Error:', e);
        showError(e.message);
      }
    }

    // Redraw tide graphs on window resize
    window.addEventListener('resize', () => {
      updateTidesDisplay();
    });

    initialize();
    setInterval(initialize, CONFIG.refreshInterval);
    document.getElementById('refreshBtn').addEventListener('click', initialize);
  </script>
</body>
</html>
