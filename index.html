<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Seaforth Environmental Dispatch Dashboard</title>
  <link href="https://fonts.googleapis.com/css2?family=Archivo+Black&family=IBM+Plex+Mono:wght@400;600&family=Source+Serif+4:opsz,wght@8..60,400;8..60,600&display=swap" rel="stylesheet">
  <style>
    :root {
      --deep-navy: #0a1628;
      --ocean-dark: #0d2137;
      --ocean-mid: #143654;
      --teal-accent: #00d4aa;
      --teal-glow: #00ffcc;
      --amber-warning: #ffaa00;
      --coral-alert: #ff6b6b;
      --ice-white: #e8f4f8;
      --mist-gray: #94a3b8;
      --foam-white: #f0f9ff;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'IBM Plex Mono', monospace;
      background: var(--deep-navy);
      color: var(--ice-white);
      min-height: 100vh;
      overflow-x: hidden;
    }

    .ocean-bg {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      background: 
        radial-gradient(ellipse at 30% 20%, rgba(0, 212, 170, 0.08) 0%, transparent 50%),
        radial-gradient(ellipse at 70% 80%, rgba(20, 54, 84, 0.4) 0%, transparent 50%),
        linear-gradient(180deg, var(--deep-navy) 0%, var(--ocean-dark) 50%, var(--deep-navy) 100%);
    }

    .wave-pattern {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 200%;
      height: 200px;
      opacity: 0.03;
      background: repeating-linear-gradient(90deg, transparent, transparent 50px, var(--teal-accent) 50px, var(--teal-accent) 51px);
      animation: waveScroll 30s linear infinite;
    }

    @keyframes waveScroll {
      0% { transform: translateX(0); }
      100% { transform: translateX(-50%); }
    }

    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
      flex-direction: column;
      gap: 1.5rem;
    }

    .loading-spinner {
      width: 60px;
      height: 60px;
      border: 3px solid var(--ocean-mid);
      border-top-color: var(--teal-accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin { to { transform: rotate(360deg); } }

    .loading-text {
      font-size: 0.85rem;
      color: var(--mist-gray);
      letter-spacing: 0.1em;
    }

    .header {
      padding: 2rem 3rem;
      border-bottom: 1px solid rgba(0, 212, 170, 0.2);
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: rgba(10, 22, 40, 0.8);
      backdrop-filter: blur(10px);
      position: sticky;
      top: 0;
      z-index: 100;
    }

    .logo-section {
      display: flex;
      align-items: center;
      gap: 1.5rem;
    }

    .logo-icon {
      width: 56px;
      height: 56px;
      background: linear-gradient(135deg, var(--teal-accent), var(--ocean-mid));
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.8rem;
      box-shadow: 0 4px 20px rgba(0, 212, 170, 0.3);
    }

    .logo-text h1 {
      font-family: 'Archivo Black', sans-serif;
      font-size: 1.6rem;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      background: linear-gradient(90deg, var(--ice-white), var(--teal-accent));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      line-height: 1.1;
    }

    .logo-text h1 span {
      display: block;
      font-size: 0.9rem;
      letter-spacing: 0.15em;
      background: none;
      -webkit-text-fill-color: var(--mist-gray);
      color: var(--mist-gray);
    }

    .header-info { text-align: right; }

    .location {
      font-family: 'Source Serif 4', serif;
      font-size: 1.1rem;
      color: var(--foam-white);
    }

    .coordinates {
      font-size: 0.75rem;
      color: var(--teal-accent);
      margin-top: 0.25rem;
    }

    .last-update {
      font-size: 0.7rem;
      color: var(--mist-gray);
      margin-top: 0.5rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      justify-content: flex-end;
    }

    .live-indicator {
      width: 8px;
      height: 8px;
      background: var(--teal-accent);
      border-radius: 50%;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; box-shadow: 0 0 0 0 rgba(0, 212, 170, 0.5); }
      50% { opacity: 0.7; box-shadow: 0 0 0 6px rgba(0, 212, 170, 0); }
    }

    .main-content {
      padding: 2rem 3rem;
      max-width: 1800px;
      margin: 0 auto;
      display: none;
    }

    .main-content.loaded { display: block; }

    .current-hero {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 1.5rem;
      margin-bottom: 2rem;
    }

    .hero-card {
      background: linear-gradient(135deg, rgba(20, 54, 84, 0.6), rgba(13, 33, 55, 0.8));
      border: 1px solid rgba(0, 212, 170, 0.15);
      border-radius: 16px;
      padding: 2rem;
      position: relative;
      overflow: hidden;
    }

    .hero-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, transparent, var(--teal-accent), transparent);
    }

    .hero-card.temp-card::before { background: linear-gradient(90deg, transparent, var(--amber-warning), transparent); }
    .hero-card.conditions-card::before { background: linear-gradient(90deg, transparent, var(--foam-white), transparent); }

    .card-label {
      font-size: 0.65rem;
      text-transform: uppercase;
      letter-spacing: 0.2em;
      color: var(--mist-gray);
      margin-bottom: 0.5rem;
    }

    .card-value {
      font-family: 'Archivo Black', sans-serif;
      font-size: 3.5rem;
      line-height: 1;
      margin-bottom: 0.5rem;
    }

    .wind-card .card-value { color: var(--teal-accent); }
    .temp-card .card-value { color: var(--amber-warning); }

    .conditions-card .card-value {
      font-size: 1.8rem;
      color: var(--foam-white);
      font-family: 'Source Serif 4', serif;
      font-weight: 600;
    }

    .card-unit {
      font-size: 1.2rem;
      color: var(--mist-gray);
      font-weight: 400;
    }

    .card-detail {
      font-size: 0.8rem;
      color: var(--mist-gray);
      margin-top: 0.5rem;
    }

    .wind-direction {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-top: 0.75rem;
    }

    .compass {
      width: 44px;
      height: 44px;
      border: 2px solid var(--teal-accent);
      border-radius: 50%;
      position: relative;
    }

    .compass-needle {
      width: 4px;
      height: 18px;
      background: linear-gradient(to top, var(--coral-alert), var(--teal-accent));
      border-radius: 2px;
      transform-origin: center bottom;
      position: absolute;
      top: 11px;
      left: 50%;
      margin-left: -2px;
      transition: transform 0.5s ease;
    }

    .compass::after {
      content: 'N';
      position: absolute;
      top: -18px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.55rem;
      color: var(--mist-gray);
    }

    .section-title {
      font-family: 'Archivo Black', sans-serif;
      font-size: 0.9rem;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      color: var(--mist-gray);
      margin-bottom: 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid rgba(0, 212, 170, 0.2);
    }

    .forecast-section { margin-bottom: 2rem; }

    /* Main 3-Column Dashboard Grid */
    .main-dashboard-grid {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 1.5rem;
      margin-bottom: 2.5rem;
    }

    .dashboard-column {
      display: flex;
      flex-direction: column;
    }

    .dashboard-column .section-title {
      margin-bottom: 1rem;
    }

    .forecast-column .marine-forecast-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .narrows-column .narrows-panel {
      flex: 1;
    }

    .narrows-source-link {
      text-align: center;
      margin-top: 0.75rem;
      font-size: 0.65rem;
      color: var(--mist-gray);
    }

    .narrows-source-link a {
      color: var(--teal-accent);
      text-decoration: none;
    }

    .narrows-source-link a:hover {
      text-decoration: underline;
    }

    /* Tablet: 2 columns (forecast full width on top, narrows side by side below) */
    @media (max-width: 1200px) {
      .main-dashboard-grid {
        grid-template-columns: 1fr 1fr;
      }
      
      .forecast-column {
        grid-column: 1 / -1;
      }
    }

    /* Mobile: 1 column */
    @media (max-width: 768px) {
      .main-dashboard-grid {
        grid-template-columns: 1fr;
      }
      
      .forecast-column {
        grid-column: auto;
      }
      
      .forecast-hours-grid {
        grid-template-columns: repeat(6, 1fr);
      }
    }
    
    @media (max-width: 480px) {
      .forecast-hours-grid {
        grid-template-columns: repeat(4, 1fr);
      }
    }

    .marine-alert {
      background: linear-gradient(90deg, rgba(0, 212, 170, 0.1), transparent);
      border-left: 4px solid var(--teal-accent);
      padding: 1rem 1.5rem;
      margin-bottom: 1.5rem;
      border-radius: 0 8px 8px 0;
    }

    .marine-alert a { color: var(--teal-accent); text-decoration: none; }
    .marine-alert a:hover { text-decoration: underline; }

    .alert-title {
      font-weight: 600;
      color: var(--teal-accent);
      font-size: 0.85rem;
      margin-bottom: 0.5rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    .alert-text {
      font-family: 'Source Serif 4', serif;
      font-size: 0.95rem;
      color: var(--foam-white);
      line-height: 1.6;
    }

    /* 3-Day Marine Forecast Styles */
    .marine-forecast-container {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .forecast-day-panel {
      background: rgba(13, 33, 55, 0.5);
      border-radius: 12px;
      border: 1px solid rgba(0, 212, 170, 0.1);
      overflow: hidden;
    }

    .forecast-day-header {
      background: rgba(0, 212, 170, 0.1);
      padding: 0.6rem 0.75rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid rgba(0, 212, 170, 0.1);
    }

    .forecast-day-name {
      font-family: 'Archivo Black', sans-serif;
      font-size: 0.75rem;
      color: var(--foam-white);
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    .forecast-day-summary {
      font-size: 0.6rem;
      color: var(--mist-gray);
    }

    .forecast-hours-grid {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      gap: 0.25rem;
      padding: 0.5rem;
    }

    .forecast-hour-cell {
      background: rgba(20, 54, 84, 0.4);
      border-radius: 6px;
      padding: 0.4rem 0.25rem;
      text-align: center;
      transition: all 0.2s ease;
      border: 1px solid transparent;
    }

    .forecast-hour-cell:hover {
      background: rgba(20, 54, 84, 0.7);
      border-color: rgba(0, 212, 170, 0.3);
    }

    .forecast-hour-cell.current {
      background: rgba(0, 212, 170, 0.15);
      border-color: var(--teal-accent);
    }

    .hour-cell-time {
      font-size: 0.55rem;
      font-weight: 600;
      color: var(--mist-gray);
      margin-bottom: 0.2rem;
    }

    .hour-cell-icon {
      font-size: 1.2rem;
      line-height: 1;
      margin-bottom: 0.15rem;
    }

    .hour-cell-temp {
      font-size: 0.7rem;
      font-weight: 600;
      color: var(--amber-warning);
      margin-bottom: 0.15rem;
    }

    .hour-cell-wind {
      font-size: 0.65rem;
      font-weight: 600;
      margin-bottom: 0.1rem;
    }

    .hour-cell-wind.light { color: #64b5f6; }
    .hour-cell-wind.moderate { color: var(--teal-accent); }
    .hour-cell-wind.fresh { color: var(--amber-warning); }
    .hour-cell-wind.strong { color: var(--coral-alert); }

    .hour-cell-wind-dir {
      font-size: 0.45rem;
      color: var(--mist-gray);
      margin-bottom: 0.15rem;
    }

    .hour-cell-rain {
      font-size: 0.5rem;
      color: #64b5f6;
    }

    .hour-cell-rain.none {
      color: var(--ocean-mid);
    }

    .tide-section { margin-bottom: 2.5rem; }

    .tide-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 1rem;
    }

    .tide-card {
      background: rgba(20, 54, 84, 0.4);
      border-radius: 12px;
      padding: 1.25rem;
      border: 1px solid rgba(0, 212, 170, 0.1);
    }

    .tide-time { font-size: 0.7rem; color: var(--mist-gray); text-transform: uppercase; letter-spacing: 0.1em; }
    .tide-type { font-family: 'Archivo Black', sans-serif; font-size: 1rem; margin: 0.5rem 0; }
    .tide-type.high { color: var(--teal-accent); }
    .tide-type.low { color: var(--coral-alert); }
    .tide-height { font-size: 1.8rem; font-weight: 600; color: var(--foam-white); }

    /* Current Section Styles */
    .narrows-panel {
      background: linear-gradient(135deg, rgba(20, 54, 84, 0.5), rgba(13, 33, 55, 0.7));
      border-radius: 12px;
      padding: 1rem;
      border: 1px solid rgba(0, 212, 170, 0.15);
    }

    .narrows-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.75rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid rgba(0, 212, 170, 0.1);
    }

    .narrows-name {
      font-family: 'Archivo Black', sans-serif;
      font-size: 0.85rem;
      color: var(--foam-white);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .narrows-location {
      font-size: 0.6rem;
      color: var(--mist-gray);
    }

    /* Current Status Display */
    .current-status {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin-bottom: 1rem;
    }

    .current-arrow-container {
      width: 60px;
      height: 60px;
      min-width: 60px;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .current-ring {
      position: absolute;
      width: 100%;
      height: 100%;
      border: 2px solid rgba(0, 212, 170, 0.3);
      border-radius: 50%;
    }

    .current-arrow {
      width: 45px;
      height: 45px;
      transition: transform 0.5s ease;
    }

    .current-arrow.flood { color: var(--teal-accent); }
    .current-arrow.ebb { color: var(--coral-alert); }
    .current-arrow.slack { color: var(--mist-gray); }

    .current-info {
      flex: 1;
      min-width: 0;
    }

    .current-state {
      font-family: 'Archivo Black', sans-serif;
      font-size: 1.1rem;
      margin-bottom: 0.15rem;
    }

    .current-state.flood { color: var(--teal-accent); }
    .current-state.ebb { color: var(--coral-alert); }
    .current-state.slack { color: var(--amber-warning); }

    .current-speed {
      font-size: 1.5rem;
      font-weight: 600;
      color: var(--foam-white);
      line-height: 1;
    }

    .current-speed .unit {
      font-size: 0.8rem;
      color: var(--mist-gray);
      font-weight: 400;
    }

    .current-direction {
      font-size: 0.65rem;
      color: var(--mist-gray);
      margin-top: 0.2rem;
    }

    /* Current Timeline */
    .current-timeline {
      margin-top: 1rem;
    }

    .timeline-label {
      font-size: 0.6rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--mist-gray);
      margin-bottom: 0.5rem;
    }

    .timeline-bar {
      height: 8px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 4px;
      position: relative;
      overflow: hidden;
    }

    .timeline-progress {
      position: absolute;
      height: 100%;
      border-radius: 4px;
      transition: width 0.5s ease;
    }

    .timeline-progress.flood {
      background: linear-gradient(90deg, var(--teal-accent), rgba(0, 212, 170, 0.5));
    }

    .timeline-progress.ebb {
      background: linear-gradient(90deg, var(--coral-alert), rgba(255, 107, 107, 0.5));
    }

    .timeline-marker {
      position: absolute;
      top: -4px;
      width: 2px;
      height: 16px;
      background: var(--foam-white);
      border-radius: 1px;
    }

    /* Current Events List */
    .current-events {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 0.5rem;
      margin-top: 1rem;
    }

    .current-event {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 8px;
      padding: 0.6rem 0.75rem;
      display: flex;
      flex-direction: column;
    }

    .event-time {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--foam-white);
    }

    .event-type {
      font-size: 0.6rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-top: 0.15rem;
    }

    .event-type.slack { color: var(--amber-warning); }
    .event-type.max-flood { color: var(--teal-accent); }
    .event-type.max-ebb { color: var(--coral-alert); }

    .event-speed {
      font-size: 0.75rem;
      color: var(--mist-gray);
      margin-top: 0.1rem;
    }

    /* Slack Window Visual Timeline */
    .slack-windows {
      margin-top: 1rem;
      padding-top: 0.75rem;
      border-top: 1px solid rgba(0, 212, 170, 0.1);
    }

    .slack-windows-title {
      font-size: 0.6rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--mist-gray);
      margin-bottom: 0.5rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .slack-windows-title::before {
      content: '‚óà';
      color: var(--amber-warning);
    }

    .window-card {
      background: rgba(0, 0, 0, 0.25);
      border-radius: 8px;
      padding: 0.6rem;
      margin-bottom: 0.5rem;
      border-left: 3px solid var(--amber-warning);
    }

    .window-card.active {
      background: rgba(255, 170, 0, 0.15);
      border-left-color: var(--teal-glow);
    }

    .window-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.4rem;
      flex-wrap: wrap;
      gap: 0.25rem;
    }

    .window-type {
      font-family: 'Archivo Black', sans-serif;
      font-size: 0.65rem;
      color: var(--amber-warning);
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }

    .window-card.active .window-type {
      color: var(--teal-glow);
    }

    .window-badge {
      font-size: 0.5rem;
      padding: 0.15rem 0.4rem;
      border-radius: 4px;
      background: rgba(0, 212, 170, 0.2);
      color: var(--teal-accent);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .window-card.active .window-badge {
      background: var(--teal-accent);
      color: var(--deep-navy);
      font-weight: 600;
    }

    .window-visual {
      position: relative;
      height: 24px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 4px;
      margin: 0.4rem 0;
      overflow: hidden;
    }

    .window-safe-zone {
      position: absolute;
      height: 100%;
      background: linear-gradient(90deg, 
        rgba(255, 170, 0, 0.1), 
        rgba(255, 170, 0, 0.3), 
        rgba(255, 170, 0, 0.3),
        rgba(255, 170, 0, 0.1)
      );
      border-left: 2px solid var(--amber-warning);
      border-right: 2px solid var(--amber-warning);
    }

    .window-slack-marker {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 2px;
      background: var(--foam-white);
      box-shadow: 0 0 6px rgba(255, 255, 255, 0.5);
    }

    .window-now-marker {
      position: absolute;
      top: -3px;
      bottom: -3px;
      width: 2px;
      background: var(--teal-glow);
      box-shadow: 0 0 8px var(--teal-glow);
      z-index: 10;
    }

    .window-now-marker::before {
      content: 'NOW';
      position: absolute;
      top: -12px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.4rem;
      color: var(--teal-glow);
      font-weight: 600;
      letter-spacing: 0.05em;
    }

    .window-flood-zone {
      position: absolute;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(0, 212, 170, 0.15));
    }

    .window-ebb-zone {
      position: absolute;
      height: 100%;
      background: linear-gradient(90deg, rgba(255, 107, 107, 0.15), transparent);
    }

    .window-times {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      font-size: 0.6rem;
      margin-top: 0.3rem;
    }

    .window-time-block {
      text-align: center;
    }

    .window-time-block.center {
      flex: 1;
    }

    .window-time-label {
      font-size: 0.4rem;
      color: var(--mist-gray);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .window-time-value {
      font-weight: 600;
      color: var(--foam-white);
      font-size: 0.75rem;
    }

    .window-time-value.slack {
      color: var(--amber-warning);
    }

    .window-duration {
      font-size: 0.55rem;
      color: var(--mist-gray);
      text-align: center;
      margin-top: 0.25rem;
    }

    .window-duration strong {
      color: var(--amber-warning);
      font-weight: 600;
    }

    .footer {
      padding: 2rem 3rem;
      border-top: 1px solid rgba(0, 212, 170, 0.1);
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.7rem;
      color: var(--mist-gray);
      flex-wrap: wrap;
      gap: 1rem;
    }

    .data-sources { display: flex; gap: 2rem; flex-wrap: wrap; }
    .data-source { display: flex; align-items: center; gap: 0.5rem; }
    .source-dot { width: 6px; height: 6px; border-radius: 50%; background: var(--teal-accent); animation: pulse 2s infinite; }
    .refresh-info { font-size: 0.65rem; color: var(--mist-gray); cursor: pointer; }
    .refresh-info:hover { color: var(--teal-accent); }

    @media (max-width: 1200px) { .current-hero { grid-template-columns: 1fr 1fr; } }

    @media (max-width: 768px) {
      .header { flex-direction: column; gap: 1rem; padding: 1.5rem; }
      .header-info { text-align: center; }
      .last-update { justify-content: center; }
      .current-hero { grid-template-columns: 1fr; }
      .main-content { padding: 1.5rem; }
      .card-value { font-size: 2.5rem; }
      .forecast-grid { grid-template-columns: repeat(auto-fill, minmax(75px, 1fr)); }
    }

    .error-message {
      background: linear-gradient(90deg, rgba(255, 107, 107, 0.15), transparent);
      border-left: 4px solid var(--coral-alert);
      padding: 1.5rem;
      margin: 2rem 3rem;
      border-radius: 0 8px 8px 0;
      color: var(--foam-white);
    }

    .error-message h3 { color: var(--coral-alert); margin-bottom: 0.5rem; font-family: 'Archivo Black', sans-serif; font-size: 1rem; }
    .error-message a { color: var(--teal-accent); }

    .retry-btn {
      margin-top: 1rem;
      padding: 0.75rem 1.5rem;
      background: var(--teal-accent);
      color: var(--deep-navy);
      border: none;
      border-radius: 8px;
      font-family: 'IBM Plex Mono', monospace;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }

    .retry-btn:hover { background: var(--teal-glow); transform: translateY(-2px); }
  </style>
</head>
<body>
  <div class="ocean-bg"></div>
  <div class="wave-pattern"></div>

  <div class="loading" id="loadingState">
    <div class="loading-spinner"></div>
    <div class="loading-text">ACQUIRING ENVIRONMENTAL DATA...</div>
  </div>

  <div id="errorState" style="display: none;"></div>

  <header class="header">
    <div class="logo-section">
      <div class="logo-icon">‚öì</div>
      <div class="logo-text">
        <h1>Seaforth Environmental<span>Dispatch Dashboard</span></h1>
      </div>
    </div>
    <div class="header-info">
      <div class="location">Vancouver, British Columbia</div>
      <div class="coordinates">49.30¬∞N ¬∑ 123.11¬∞W</div>
      <div class="last-update">
        <span class="live-indicator"></span>
        <span>Last updated: <span id="updateTime">‚Äî</span></span>
      </div>
    </div>
  </header>

  <main class="main-content" id="mainContent">
    <section class="current-hero">
      <div class="hero-card wind-card">
        <div class="card-label">Current Wind</div>
        <div class="card-value"><span id="currentWind">‚Äî</span> <span class="card-unit">kts</span></div>
        <div class="wind-direction">
          <div class="compass"><div class="compass-needle" id="compassNeedle"></div></div>
          <span id="windDirText">‚Äî</span>
        </div>
        <div class="card-detail">Gusts to <span id="currentGust">‚Äî</span> kts</div>
      </div>
      <div class="hero-card temp-card">
        <div class="card-label">Temperature</div>
        <div class="card-value"><span id="currentTemp">‚Äî</span><span class="card-unit">¬∞C</span></div>
        <div class="card-detail">Humidity: <span id="currentHumidity">‚Äî</span>%</div>
        <div class="card-detail">Feels like: <span id="feelsLike">‚Äî</span>¬∞C</div>
      </div>
      <div class="hero-card conditions-card">
        <div class="card-label">Conditions</div>
        <div class="card-value" id="currentConditions">‚Äî</div>
        <div class="card-detail">Cloud Cover: <span id="cloudCover">‚Äî</span>%</div>
        <div class="card-detail">Barometer: <span id="pressure">‚Äî</span> hPa</div>
      </div>
    </section>

    <section class="forecast-section">
      <div class="marine-alert">
        <div class="alert-title">üì° Live Data Feed</div>
        <div class="alert-text">
          Weather data from Open-Meteo (GFS/ICON models), updated hourly. 
          For official marine warnings: <a href="https://weather.gc.ca/marine/forecast_e.html?mapID=02&siteID=14305" target="_blank">Environment Canada Marine Forecasts</a>
        </div>
      </div>
    </section>

    <!-- Main 3-Column Layout: Marine Forecast + Currents -->
    <section class="main-dashboard-grid">
      <!-- Left Column: 3-Day Marine Forecast -->
      <div class="dashboard-column forecast-column">
        <h2 class="section-title">3-Day Marine Forecast</h2>
        <div class="marine-forecast-container" id="marineForecastContainer">
          <!-- Populated by JavaScript -->
        </div>
      </div>

      <!-- Middle Column: First Narrows -->
      <div class="dashboard-column narrows-column">
        <h2 class="section-title">First Narrows</h2>
        <div class="narrows-panel" id="firstNarrowsPanel">
          <div class="narrows-header">
            <div>
              <div class="narrows-name">Lions Gate Bridge</div>
              <div class="narrows-location">Station 07721</div>
            </div>
          </div>
          <div class="current-status">
            <div class="current-arrow-container">
              <div class="current-ring"></div>
              <svg class="current-arrow flood" id="firstNarrowsArrow" viewBox="0 0 24 24" fill="currentColor">
                <path d="M12 2L4 12h5v10h6V12h5L12 2z"/>
              </svg>
            </div>
            <div class="current-info">
              <div class="current-state flood" id="firstNarrowsState">FLOOD</div>
              <div class="current-speed"><span id="firstNarrowsSpeed">2.4</span> <span class="unit">kts</span></div>
              <div class="current-direction" id="firstNarrowsDir">Flowing SE (135¬∞) into harbour</div>
            </div>
          </div>
          <div class="current-timeline">
            <div class="timeline-label">Current Cycle Progress</div>
            <div class="timeline-bar">
              <div class="timeline-progress flood" id="firstNarrowsProgress" style="width: 45%"></div>
              <div class="timeline-marker" id="firstNarrowsMarker" style="left: 45%"></div>
            </div>
          </div>
          <div class="current-events" id="firstNarrowsEvents"></div>
          <div class="slack-windows" id="firstNarrowsWindows"></div>
        </div>
        <div class="narrows-source-link">
          <a href="http://www.dairiki.org/tides/daily.php/fir" target="_blank">XTide Data</a> ¬∑ 
          <a href="https://tides.gc.ca/en/current-predictions-station" target="_blank">CHS Tables</a>
        </div>
      </div>

      <!-- Right Column: Second Narrows -->
      <div class="dashboard-column narrows-column">
        <h2 class="section-title">Second Narrows</h2>
        <div class="narrows-panel" id="secondNarrowsPanel">
          <div class="narrows-header">
            <div>
              <div class="narrows-name">Ironworkers Bridge</div>
              <div class="narrows-location">Station 07745</div>
            </div>
          </div>
          <div class="current-status">
            <div class="current-arrow-container">
              <div class="current-ring"></div>
              <svg class="current-arrow flood" id="secondNarrowsArrow" viewBox="0 0 24 24" fill="currentColor">
                <path d="M12 2L4 12h5v10h6V12h5L12 2z"/>
              </svg>
            </div>
            <div class="current-info">
              <div class="current-state flood" id="secondNarrowsState">FLOOD</div>
              <div class="current-speed"><span id="secondNarrowsSpeed">2.1</span> <span class="unit">kts</span></div>
              <div class="current-direction" id="secondNarrowsDir">Flowing E (090¬∞) into harbour</div>
            </div>
          </div>
          <div class="current-timeline">
            <div class="timeline-label">Current Cycle Progress</div>
            <div class="timeline-bar">
              <div class="timeline-progress flood" id="secondNarrowsProgress" style="width: 45%"></div>
              <div class="timeline-marker" id="secondNarrowsMarker" style="left: 45%"></div>
            </div>
          </div>
          <div class="current-events" id="secondNarrowsEvents"></div>
          <div class="slack-windows" id="secondNarrowsWindows"></div>
        </div>
        <div class="narrows-source-link">
          <a href="http://www.dairiki.org/tides/daily.php/sec" target="_blank">XTide Data</a> ¬∑ 
          <a href="https://tides.gc.ca/en/current-predictions-station" target="_blank">CHS Tables</a>
        </div>
      </div>
    </section>

    <section class="tide-section">
      <h2 class="section-title">Tides ‚Äî Point Atkinson Reference</h2>
      <div class="tide-grid" id="tideGrid"></div>
    </section>
  </main>

  <footer class="footer">
    <div class="data-sources">
      <div class="data-source"><span class="source-dot"></span><span>Open-Meteo API</span></div>
      <div class="data-source"><span class="source-dot"></span><span>GFS / ICON Models</span></div>
      <div class="data-source"><span class="source-dot"></span><span>Harmonic Tide Calc</span></div>
    </div>
    <div>
      <div>Seaforth Environmental Dispatch Dashboard ¬© 2026</div>
      <div class="refresh-info" id="refreshBtn">üîÑ Click to refresh | Auto-refresh: 30 min</div>
    </div>
  </footer>

  <script>
    const CONFIG = { lat: 49.30, lon: -123.11, refreshInterval: 30 * 60 * 1000 };

    const weatherCodes = {
      0: 'Clear Sky', 1: 'Mainly Clear', 2: 'Partly Cloudy', 3: 'Overcast',
      45: 'Foggy', 48: 'Rime Fog', 51: 'Light Drizzle', 53: 'Drizzle', 55: 'Dense Drizzle',
      61: 'Slight Rain', 63: 'Moderate Rain', 65: 'Heavy Rain', 66: 'Freezing Rain', 67: 'Heavy Freezing Rain',
      71: 'Slight Snow', 73: 'Moderate Snow', 75: 'Heavy Snow', 77: 'Snow Grains',
      80: 'Rain Showers', 81: 'Moderate Showers', 82: 'Heavy Showers', 85: 'Snow Showers', 86: 'Heavy Snow Showers',
      95: 'Thunderstorm', 96: 'Thunderstorm + Hail', 99: 'Severe Thunderstorm'
    };

    const weatherIcons = {
      0: '‚òÄÔ∏è', 1: 'üå§Ô∏è', 2: '‚õÖ', 3: '‚òÅÔ∏è', 45: 'üå´Ô∏è', 48: 'üå´Ô∏è',
      51: 'üå¶Ô∏è', 53: 'üå¶Ô∏è', 55: 'üåßÔ∏è', 61: 'üåßÔ∏è', 63: 'üåßÔ∏è', 65: 'üåßÔ∏è', 66: 'üå®Ô∏è', 67: 'üå®Ô∏è',
      71: 'üå®Ô∏è', 73: 'üå®Ô∏è', 75: '‚ùÑÔ∏è', 77: 'üå®Ô∏è', 80: 'üå¶Ô∏è', 81: 'üåßÔ∏è', 82: '‚õàÔ∏è',
      85: 'üå®Ô∏è', 86: 'üå®Ô∏è', 95: '‚õàÔ∏è', 96: '‚õàÔ∏è', 99: '‚õàÔ∏è'
    };

    const msToKnots = ms => Math.round(ms * 1.944);
    const getWindDirection = deg => ['N','NNE','NE','ENE','E','ESE','SE','SSE','S','SSW','SW','WSW','W','WNW','NW','NNW'][Math.round(deg / 22.5) % 16];
    const getWindClass = kts => kts < 5 ? 'light' : kts < 12 ? 'moderate' : kts < 20 ? 'fresh' : 'strong';
    const formatTime = d => d.toLocaleTimeString('en-CA', { hour: '2-digit', minute: '2-digit', hour12: false });
    const formatDay = d => d.toLocaleDateString('en-CA', { weekday: 'short' });
    const formatDateTime = d => d.toLocaleString('en-CA', { day: '2-digit', month: 'short', year: 'numeric', hour: '2-digit', minute: '2-digit', timeZoneName: 'short' });

    function showError(msg) {
      document.getElementById('loadingState').style.display = 'none';
      document.getElementById('mainContent').classList.remove('loaded');
      const err = document.getElementById('errorState');
      err.style.display = 'block';
      err.innerHTML = `
        <div class="error-message">
          <h3>‚ö†Ô∏è Unable to Load Weather Data</h3>
          <p>${msg}</p>
          <p style="margin-top:1rem;font-size:0.85rem">This is often caused by browser security when opening the file directly (file:// protocol).</p>
          <p style="margin-top:0.75rem;font-size:0.85rem"><strong>Quick fixes:</strong></p>
          <ul style="margin:0.5rem 0 0 1.5rem;font-size:0.85rem;line-height:1.8">
            <li>Upload this file to any web hosting (GitHub Pages, Netlify, etc.)</li>
            <li>Run a local server: <code style="background:var(--ocean-mid);padding:2px 6px;border-radius:4px">python -m http.server 8000</code></li>
            <li>Or use these direct links for current data:</li>
          </ul>
          <p style="margin-top:1rem">
            <a href="https://www.windfinder.com/forecast/vancouver_harbour" target="_blank">‚Üí Windfinder Vancouver Harbour</a><br>
            <a href="https://weather.gc.ca/marine/forecast_e.html?mapID=02&siteID=14305" target="_blank">‚Üí Environment Canada Marine</a><br>
            <a href="https://tides.gc.ca/en/stations/7735" target="_blank">‚Üí Canadian Tides - Point Atkinson</a>
          </p>
          <button class="retry-btn" onclick="initialize()">Try Again</button>
        </div>`;
    }

    async function fetchWeatherData() {
      const url = `https://api.open-meteo.com/v1/forecast?latitude=${CONFIG.lat}&longitude=${CONFIG.lon}&current=temperature_2m,relative_humidity_2m,apparent_temperature,weather_code,cloud_cover,pressure_msl,wind_speed_10m,wind_direction_10m,wind_gusts_10m&hourly=temperature_2m,weather_code,wind_speed_10m,wind_direction_10m,wind_gusts_10m,precipitation&daily=weather_code,temperature_2m_max,temperature_2m_min,wind_speed_10m_max,wind_gusts_10m_max,precipitation_sum&timezone=America/Vancouver&forecast_days=7`;
      const res = await fetch(url);
      if (!res.ok) throw new Error(`API returned ${res.status}`);
      return res.json();
    }

    function calculateTides() {
      const tides = [];
      const now = new Date();
      const base = new Date(now); base.setMinutes(0,0,0);
      
      const M2_period = 12.42 * 3600000;
      const meanLevel = 3.1, M2_amp = 1.2, S2_amp = 0.35, K1_amp = 0.9;
      const S2_period = 12 * 3600000, K1_period = 23.93 * 3600000;
      const interval = 15 * 60000, duration = 48 * 3600000;
      
      let prevH = null, prevS = null;
      
      for (let t = 0; t < duration; t += interval) {
        const time = new Date(base.getTime() + t);
        const h = meanLevel + M2_amp * Math.cos(2 * Math.PI * t / M2_period) 
                           + S2_amp * Math.cos(2 * Math.PI * t / S2_period)
                           + K1_amp * Math.cos(2 * Math.PI * t / K1_period);
        
        if (prevH !== null) {
          const s = h - prevH;
          if (prevS !== null) {
            if (prevS > 0 && s <= 0) tides.push({ time: new Date(time.getTime() - interval/2), height: prevH.toFixed(1), type: 'high' });
            else if (prevS < 0 && s >= 0) tides.push({ time: new Date(time.getTime() - interval/2), height: prevH.toFixed(1), type: 'low' });
          }
          prevS = s;
        }
        prevH = h;
      }
      return tides.slice(0, 8);
    }

    // Current calculations for First and Second Narrows
    // Using XTide reference data for accurate predictions
    
    // Reference data from XTide (dairiki.org) for January-February 2026
    // Format: [dayOfMonth, slackTimes[], maxTimes[], maxSpeeds[]] 
    // Negative speed = Ebb, Positive = Flood
    const FIRST_NARROWS_DATA = {
      '2026-01-27': {
        slacks: ['02:12', '11:16', '19:47'],
        maxes: [
          { time: '03:50', speed: -0.5 },
          { time: '08:46', speed: 1.5 },
          { time: '15:46', speed: -4.3 },
          { time: '23:18', speed: 3.3 }
        ]
      },
      '2026-01-28': {
        slacks: ['03:59', '12:04', '20:49'],
        maxes: [
          { time: '05:33', speed: -0.5 },
          { time: '09:59', speed: 1.0 },
          { time: '16:53', speed: -4.5 },
        ]
      },
      '2026-01-29': {
        slacks: ['05:03', '09:13', '13:08', '21:47'],
        maxes: [
          { time: '00:29', speed: 4.0 },
          { time: '06:57', speed: -0.8 },
          { time: '11:21', speed: 0.8 },
          { time: '18:00', speed: -4.8 }
        ]
      },
      '2026-01-30': {
        slacks: ['05:49', '10:36', '14:21', '22:41'],
        maxes: [
          { time: '01:28', speed: 4.6 },
          { time: '07:59', speed: -1.3 },
          { time: '12:36', speed: 0.9 },
          { time: '19:01', speed: -5.0 }
        ]
      },
      '2026-01-31': {
        slacks: ['06:28', '11:35', '15:33', '23:30'],
        maxes: [
          { time: '02:19', speed: 5.0 },
          { time: '08:48', speed: -1.8 },
          { time: '13:40', speed: 1.2 },
          { time: '19:56', speed: -5.2 }
        ]
      }
    };
    
    const SECOND_NARROWS_DATA = {
      '2026-01-27': {
        slacks: ['01:53', '11:24', '19:35'],
        maxes: [
          { time: '03:42', speed: -0.7 },
          { time: '08:49', speed: 1.6 },
          { time: '15:42', speed: -4.0 },
          { time: '23:06', speed: 3.4 }
        ]
      },
      '2026-01-28': {
        slacks: ['03:36', '12:16', '20:38'],
        maxes: [
          { time: '05:21', speed: -0.7 },
          { time: '10:03', speed: 1.2 },
          { time: '16:50', speed: -4.2 },
        ]
      },
      '2026-01-29': {
        slacks: ['04:43', '09:03', '13:23', '21:37'],
        maxes: [
          { time: '00:17', speed: 4.0 },
          { time: '06:44', speed: -1.0 },
          { time: '11:24', speed: 1.0 },
          { time: '17:56', speed: -4.5 }
        ]
      },
      '2026-01-30': {
        slacks: ['05:32', '10:23', '14:34', '22:31'],
        maxes: [
          { time: '01:17', speed: 4.5 },
          { time: '07:46', speed: -1.5 },
          { time: '12:37', speed: 1.2 },
          { time: '18:57', speed: -4.8 }
        ]
      },
      '2026-01-31': {
        slacks: ['06:13', '11:23', '15:43', '23:21'],
        maxes: [
          { time: '02:08', speed: 5.0 },
          { time: '08:37', speed: -2.0 },
          { time: '13:40', speed: 1.5 },
          { time: '19:52', speed: -4.9 }
        ]
      }
    };

    function parseTimeToday(timeStr, baseDate) {
      const [hours, minutes] = timeStr.split(':').map(Number);
      const result = new Date(baseDate);
      result.setHours(hours, minutes, 0, 0);
      return result;
    }

    function getLocalDateString(date) {
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    }

    function calculateCurrents(stationConfig, referenceData) {
      const now = new Date();
      const today = getLocalDateString(now);
      const tomorrow = new Date(now);
      tomorrow.setDate(tomorrow.getDate() + 1);
      const tomorrowStr = getLocalDateString(tomorrow);
      
      const { maxFlood, maxEbb, floodDir, ebbDir } = stationConfig;
      
      // Check if we have reference data for today
      const todayData = referenceData[today];
      const tomorrowData = referenceData[tomorrowStr];
      
      const events = [];
      const slackWindows = [];
      
      if (todayData) {
        // Parse today's data
        const todayBase = new Date(now);
        todayBase.setHours(0, 0, 0, 0);
        
        // Add slack events
        todayData.slacks.forEach(timeStr => {
          const slackTime = parseTimeToday(timeStr, todayBase);
          if (slackTime > now) {
            // Determine if high or low slack based on surrounding max currents
            const maxBefore = todayData.maxes.filter(m => parseTimeToday(m.time, todayBase) < slackTime).pop();
            const isHighSlack = maxBefore && maxBefore.speed > 0;
            events.push({
              time: slackTime,
              type: isHighSlack ? 'high-slack' : 'low-slack',
              speed: 0
            });
          }
        });
        
        // Add max current events
        todayData.maxes.forEach(max => {
          const maxTime = parseTimeToday(max.time, todayBase);
          if (maxTime > now) {
            events.push({
              time: maxTime,
              type: max.speed > 0 ? 'max-flood' : 'max-ebb',
              speed: Math.abs(max.speed).toFixed(1)
            });
          }
        });
        
        // Add tomorrow's early events if available
        if (tomorrowData) {
          const tomorrowBase = new Date(tomorrow);
          tomorrowBase.setHours(0, 0, 0, 0);
          
          tomorrowData.slacks.slice(0, 2).forEach(timeStr => {
            const slackTime = parseTimeToday(timeStr, tomorrowBase);
            const maxBefore = tomorrowData.maxes.filter(m => parseTimeToday(m.time, tomorrowBase) < slackTime).pop();
            const isHighSlack = maxBefore && maxBefore.speed > 0;
            events.push({
              time: slackTime,
              type: isHighSlack ? 'high-slack' : 'low-slack',
              speed: 0
            });
          });
          
          tomorrowData.maxes.slice(0, 2).forEach(max => {
            const maxTime = parseTimeToday(max.time, tomorrowBase);
            events.push({
              time: maxTime,
              type: max.speed > 0 ? 'max-flood' : 'max-ebb',
              speed: Math.abs(max.speed).toFixed(1)
            });
          });
        }
        
        // Sort events by time
        events.sort((a, b) => a.time - b.time);
        
        // Calculate current state based on surrounding events
        const pastMaxes = todayData.maxes
          .map(m => ({ ...m, time: parseTimeToday(m.time, todayBase) }))
          .filter(m => m.time <= now);
        const futureMaxes = todayData.maxes
          .map(m => ({ ...m, time: parseTimeToday(m.time, todayBase) }))
          .filter(m => m.time > now);
        
        let currentSpeed = 0;
        let isFlood = false;
        let isEbb = false;
        let inOneKnotWindow = false;
        
        if (pastMaxes.length > 0 && futureMaxes.length > 0) {
          const lastMax = pastMaxes[pastMaxes.length - 1];
          const nextMax = futureMaxes[0];
          
          // Find surrounding slacks
          const slackTimes = todayData.slacks.map(s => parseTimeToday(s, todayBase));
          const nextSlack = slackTimes.find(s => s > now);
          const prevSlack = slackTimes.filter(s => s <= now).pop();
          
          // Interpolate current speed
          if (prevSlack && nextSlack) {
            // Between two slacks - calculate progress toward max
            const totalTime = nextSlack - prevSlack;
            const elapsed = now - prevSlack;
            const progress = elapsed / totalTime;
            
            // Current follows sinusoidal pattern between slacks
            const peakSpeed = lastMax.speed;
            currentSpeed = peakSpeed * Math.sin(progress * Math.PI);
          } else if (nextSlack) {
            // Before first slack, after last max
            const peakSpeed = lastMax.speed;
            const timeToSlack = nextSlack - now;
            const totalTime = nextSlack - lastMax.time;
            const progress = 1 - (timeToSlack / totalTime);
            currentSpeed = peakSpeed * Math.cos(progress * Math.PI / 2);
          }
          
          isFlood = currentSpeed > 0.1;
          isEbb = currentSpeed < -0.1;
          inOneKnotWindow = Math.abs(currentSpeed) <= 1.0;
        }
        
        // Calculate slack windows (1-knot windows) for today and future days
        // A 1-knot window is roughly when current is within ~15-20 minutes of slack for typical max currents
        
        // Helper function to calculate windows for a given day's data
        const calculateWindowsForDay = (dayData, dayBase) => {
          const daySlacks = dayData.slacks.map(s => parseTimeToday(s, dayBase));
          const dayMaxes = dayData.maxes.map(m => ({ ...m, time: parseTimeToday(m.time, dayBase) }));
          
          daySlacks.forEach((slackTime) => {
            if (slackTime < new Date(now.getTime() - 2 * 3600000)) return; // Skip past slacks
            
            // Find the max before and after this slack
            const maxBefore = dayMaxes.filter(m => m.time < slackTime).pop();
            const maxAfter = dayMaxes.find(m => m.time > slackTime);
            
            if (maxBefore || maxAfter) {
              let windowStart = slackTime;
              let windowEnd = slackTime;
              
              if (maxBefore) {
                const beforePeak = Math.abs(maxBefore.speed);
                const timeFromMaxToSlack = slackTime - maxBefore.time;
                
                if (beforePeak > 1) {
                  const fraction = Math.asin(1 / beforePeak) / (Math.PI / 2);
                  const timeBeforeSlack = timeFromMaxToSlack * fraction;
                  windowStart = new Date(slackTime.getTime() - timeBeforeSlack);
                } else {
                  windowStart = maxBefore.time;
                }
              }
              
              if (maxAfter) {
                const afterPeak = Math.abs(maxAfter.speed);
                const timeFromSlackToMax = maxAfter.time - slackTime;
                
                if (afterPeak > 1) {
                  const fraction = Math.asin(1 / afterPeak) / (Math.PI / 2);
                  const timeAfterSlack = timeFromSlackToMax * fraction;
                  windowEnd = new Date(slackTime.getTime() + timeAfterSlack);
                } else {
                  windowEnd = maxAfter.time;
                }
              }
              
              if (windowEnd > now) {
                slackWindows.push({
                  start: windowStart,
                  slack: slackTime,
                  end: windowEnd,
                  type: maxBefore && maxBefore.speed > 0 ? 'high-slack' : 'low-slack',
                  nextDirection: maxAfter && maxAfter.speed > 0 ? 'flood' : 'ebb'
                });
              }
            }
          });
        };
        
        // Calculate windows for today
        calculateWindowsForDay(todayData, todayBase);
        
        // Calculate windows for tomorrow and beyond
        if (tomorrowData) {
          const tomorrowBase = new Date(tomorrow);
          tomorrowBase.setHours(0, 0, 0, 0);
          calculateWindowsForDay(tomorrowData, tomorrowBase);
        }
        
        // Check for day after tomorrow
        const dayAfterTomorrow = new Date(tomorrow);
        dayAfterTomorrow.setDate(dayAfterTomorrow.getDate() + 1);
        const dayAfterTomorrowStr = getLocalDateString(dayAfterTomorrow);
        const dayAfterTomorrowData = referenceData[dayAfterTomorrowStr];
        
        if (dayAfterTomorrowData) {
          const dayAfterBase = new Date(dayAfterTomorrow);
          dayAfterBase.setHours(0, 0, 0, 0);
          calculateWindowsForDay(dayAfterTomorrowData, dayAfterBase);
        }
        
        // Sort windows by slack time
        slackWindows.sort((a, b) => a.slack - b.slack);
        
        return {
          currentSpeed: Math.abs(currentSpeed).toFixed(1),
          isFlood,
          isEbb,
          isSlack: !isFlood && !isEbb,
          inOneKnotWindow,
          direction: isFlood || (!isFlood && !isEbb && currentSpeed >= 0) ? floodDir : ebbDir,
          directionDeg: isFlood || (!isFlood && !isEbb && currentSpeed >= 0) ? stationConfig.floodDeg : stationConfig.ebbDeg,
          events: events.slice(0, 8),
          slackWindows: slackWindows.filter(w => w.end > now).slice(0, 5),
          progressPercent: 50,
          hasReferenceData: true
        };
      }
      
      // Fallback to harmonic calculation if no reference data
      return calculateCurrentsFallback(stationConfig);
    }
    
    // Fallback harmonic calculation (less accurate)
    function calculateCurrentsFallback(stationConfig) {
      const now = new Date();
      const base = new Date(now);
      base.setHours(0, 0, 0, 0);
      
      const M2_period = 12.42 * 3600000;
      const { maxFlood, maxEbb, floodDir, ebbDir, phaseOffset } = stationConfig;
      
      const nowT = now.getTime() - base.getTime();
      const phase = 2 * Math.PI * (nowT + phaseOffset) / M2_period;
      const rawNow = Math.sin(phase);
      const currentSpeed = rawNow > 0 ? rawNow * maxFlood : rawNow * maxEbb;
      
      return {
        currentSpeed: Math.abs(currentSpeed).toFixed(1),
        isFlood: currentSpeed > 0.1,
        isEbb: currentSpeed < -0.1,
        isSlack: Math.abs(currentSpeed) <= 0.1,
        inOneKnotWindow: Math.abs(currentSpeed) <= 1.0,
        direction: currentSpeed >= 0 ? floodDir : ebbDir,
        directionDeg: currentSpeed >= 0 ? stationConfig.floodDeg : stationConfig.ebbDeg,
        events: [],
        slackWindows: [],
        progressPercent: 50,
        hasReferenceData: false
      };
    }

    // Station configurations
    const FIRST_NARROWS = {
      maxFlood: 3.5,  // knots
      maxEbb: 5.0,    // knots (stronger)
      floodDir: 'SE into harbour',
      ebbDir: 'NW out to Strait',
      floodDeg: 135,
      ebbDeg: 315,
      phaseOffset: 1.5 * 3600000 // Current phase offset from Point Atkinson tide
    };

    const SECOND_NARROWS = {
      maxFlood: 3.0,
      maxEbb: 4.5,
      floodDir: 'E into harbour',
      ebbDir: 'W out to Strait',
      floodDeg: 90,
      ebbDeg: 270,
      phaseOffset: 2.5 * 3600000 // Second Narrows lags First Narrows by ~1 hour
    };

    function updateCurrentsDisplay() {
      // First Narrows
      const first = calculateCurrents(FIRST_NARROWS, FIRST_NARROWS_DATA);
      document.getElementById('firstNarrowsSpeed').textContent = first.currentSpeed;
      
      const firstState = document.getElementById('firstNarrowsState');
      const firstArrow = document.getElementById('firstNarrowsArrow');
      const firstProgress = document.getElementById('firstNarrowsProgress');
      const firstDir = document.getElementById('firstNarrowsDir');
      
      if (first.isSlack) {
        firstState.textContent = 'SLACK';
        firstState.className = 'current-state slack';
        firstArrow.className = 'current-arrow slack';
        firstArrow.style.transform = 'rotate(0deg)';
        firstProgress.className = 'timeline-progress flood';
        firstDir.textContent = 'Minimal current ‚Äî turning';
      } else if (first.isFlood) {
        firstState.textContent = 'FLOOD';
        firstState.className = 'current-state flood';
        firstArrow.className = 'current-arrow flood';
        firstArrow.style.transform = `rotate(${FIRST_NARROWS.floodDeg}deg)`;
        firstProgress.className = 'timeline-progress flood';
        firstDir.textContent = `Flowing ${first.direction} (${first.directionDeg}¬∞)`;
      } else {
        firstState.textContent = 'EBB';
        firstState.className = 'current-state ebb';
        firstArrow.className = 'current-arrow ebb';
        firstArrow.style.transform = `rotate(${FIRST_NARROWS.ebbDeg}deg)`;
        firstProgress.className = 'timeline-progress ebb';
        firstDir.textContent = `Flowing ${first.direction} (${first.directionDeg}¬∞)`;
      }
      
      firstProgress.style.width = `${first.progressPercent}%`;
      document.getElementById('firstNarrowsMarker').style.left = `${first.progressPercent}%`;
      
      // First Narrows Events - only show next max flood and next max ebb
      const firstEventsEl = document.getElementById('firstNarrowsEvents');
      const firstNextFlood = first.events.find(e => e.type === 'max-flood');
      const firstNextEbb = first.events.find(e => e.type === 'max-ebb');
      const firstMaxEvents = [firstNextFlood, firstNextEbb].filter(Boolean);
      firstEventsEl.innerHTML = firstMaxEvents.map(e => `
        <div class="current-event">
          <div class="event-time">${formatTime(e.time)}</div>
          <div class="event-type ${e.type}">${e.type === 'max-flood' ? '‚ñ≤ Max Flood' : '‚ñº Max Ebb'}</div>
          <div class="event-speed">${e.speed} kts</div>
        </div>
      `).join('');
      
      // First Narrows Slack Windows
      renderSlackWindows('firstNarrowsWindows', first.slackWindows, first.inOneKnotWindow);
      
      // Second Narrows
      const second = calculateCurrents(SECOND_NARROWS, SECOND_NARROWS_DATA);
      document.getElementById('secondNarrowsSpeed').textContent = second.currentSpeed;
      
      const secondState = document.getElementById('secondNarrowsState');
      const secondArrow = document.getElementById('secondNarrowsArrow');
      const secondProgress = document.getElementById('secondNarrowsProgress');
      const secondDir = document.getElementById('secondNarrowsDir');
      
      if (second.isSlack) {
        secondState.textContent = 'SLACK';
        secondState.className = 'current-state slack';
        secondArrow.className = 'current-arrow slack';
        secondArrow.style.transform = 'rotate(0deg)';
        secondProgress.className = 'timeline-progress flood';
        secondDir.textContent = 'Minimal current ‚Äî turning';
      } else if (second.isFlood) {
        secondState.textContent = 'FLOOD';
        secondState.className = 'current-state flood';
        secondArrow.className = 'current-arrow flood';
        secondArrow.style.transform = `rotate(${SECOND_NARROWS.floodDeg}deg)`;
        secondProgress.className = 'timeline-progress flood';
        secondDir.textContent = `Flowing ${second.direction} (${second.directionDeg}¬∞)`;
      } else {
        secondState.textContent = 'EBB';
        secondState.className = 'current-state ebb';
        secondArrow.className = 'current-arrow ebb';
        secondArrow.style.transform = `rotate(${SECOND_NARROWS.ebbDeg}deg)`;
        secondProgress.className = 'timeline-progress ebb';
        secondDir.textContent = `Flowing ${second.direction} (${second.directionDeg}¬∞)`;
      }
      
      secondProgress.style.width = `${second.progressPercent}%`;
      document.getElementById('secondNarrowsMarker').style.left = `${second.progressPercent}%`;
      
      // Second Narrows Events - only show next max flood and next max ebb
      const secondEventsEl = document.getElementById('secondNarrowsEvents');
      const secondNextFlood = second.events.find(e => e.type === 'max-flood');
      const secondNextEbb = second.events.find(e => e.type === 'max-ebb');
      const secondMaxEvents = [secondNextFlood, secondNextEbb].filter(Boolean);
      secondEventsEl.innerHTML = secondMaxEvents.map(e => `
        <div class="current-event">
          <div class="event-time">${formatTime(e.time)}</div>
          <div class="event-type ${e.type}">${e.type === 'max-flood' ? '‚ñ≤ Max Flood' : '‚ñº Max Ebb'}</div>
          <div class="event-speed">${e.speed} kts</div>
        </div>
      `).join('');
      
      // Second Narrows Slack Windows
      renderSlackWindows('secondNarrowsWindows', second.slackWindows, second.inOneKnotWindow);
    }
    
    // Render slack windows visual
    function renderSlackWindows(elementId, windows, currentlyInWindow) {
      const container = document.getElementById(elementId);
      const now = new Date();
      const todayStr = getLocalDateString(now);
      
      if (windows.length === 0) {
        container.innerHTML = '<div class="slack-windows-title">1-Knot Safe Passage Windows</div><div style="color: var(--mist-gray); font-size: 0.75rem;">No upcoming windows in reference data</div>';
        return;
      }
      
      let html = '<div class="slack-windows-title">1-Knot Safe Passage Windows</div>';
      
      windows.forEach((w, idx) => {
        const duration = Math.round((w.end - w.start) / 60000); // minutes
        const isActive = now >= w.start && now <= w.end;
        const isPast = now > w.end;
        
        if (isPast) return;
        
        // Check if this is today or a future day
        const windowDateStr = getLocalDateString(w.slack);
        const isToday = windowDateStr === todayStr;
        const dayLabel = isToday ? '' : w.slack.toLocaleDateString('en-CA', { weekday: 'short', month: 'short', day: 'numeric' }) + ' ‚Äî ';
        
        // Calculate positions for the visual bar (as percentage)
        const totalSpan = w.end - w.start;
        const slackPos = ((w.slack - w.start) / totalSpan) * 100;
        const nowPos = isActive ? ((now - w.start) / totalSpan) * 100 : -1;
        
        // Determine what comes before and after slack
        const beforeSlack = w.type === 'high-slack' ? 'flood' : 'ebb';
        const afterSlack = w.nextDirection;
        
        html += `
          <div class="window-card ${isActive ? 'active' : ''}">
            <div class="window-header">
              <div class="window-type">${dayLabel}${w.type === 'high-slack' ? 'High Slack' : 'Low Slack'} Window</div>
              ${isActive ? '<div class="window-badge">‚óè NOW IN WINDOW</div>' : idx === 0 ? '<div class="window-badge">Next</div>' : ''}
            </div>
            <div class="window-visual">
              <div class="window-${beforeSlack}-zone" style="left: 0; width: ${slackPos}%"></div>
              <div class="window-${afterSlack}-zone" style="left: ${slackPos}%; width: ${100 - slackPos}%"></div>
              <div class="window-safe-zone" style="left: 0; width: 100%"></div>
              <div class="window-slack-marker" style="left: ${slackPos}%"></div>
              ${isActive ? `<div class="window-now-marker" style="left: ${nowPos}%"></div>` : ''}
            </div>
            <div class="window-times">
              <div class="window-time-block">
                <div class="window-time-label">Window Opens</div>
                <div class="window-time-value">${formatTime(w.start)}</div>
              </div>
              <div class="window-time-block center">
                <div class="window-time-label">Slack</div>
                <div class="window-time-value slack">${formatTime(w.slack)}</div>
              </div>
              <div class="window-time-block" style="text-align: right">
                <div class="window-time-label">Window Closes</div>
                <div class="window-time-value">${formatTime(w.end)}</div>
              </div>
            </div>
            <div class="window-duration">
              Window duration: <strong>${duration} minutes</strong> 
              ${isActive ? ` ‚Ä¢ ${Math.round((w.end - now) / 60000)} min remaining` : ''}
            </div>
          </div>
        `;
      });
      
      container.innerHTML = html;
    }

    function updateCurrent(d) {
      const c = d.current;
      const wKts = msToKnots(c.wind_speed_10m), gKts = msToKnots(c.wind_gusts_10m), wDir = c.wind_direction_10m;
      
      document.getElementById('currentWind').textContent = wKts;
      document.getElementById('currentGust').textContent = gKts;
      document.getElementById('windDirText').textContent = `${getWindDirection(wDir)} (${Math.round(wDir)}¬∞)`;
      document.getElementById('compassNeedle').style.transform = `rotate(${wDir}deg)`;
      document.getElementById('currentTemp').textContent = Math.round(c.temperature_2m);
      document.getElementById('currentHumidity').textContent = c.relative_humidity_2m;
      document.getElementById('feelsLike').textContent = Math.round(c.apparent_temperature);
      document.getElementById('currentConditions').textContent = weatherCodes[c.weather_code] || 'Unknown';
      document.getElementById('cloudCover').textContent = c.cloud_cover;
      document.getElementById('pressure').textContent = Math.round(c.pressure_msl);
      document.getElementById('updateTime').textContent = formatDateTime(new Date());
    }

    function build3DayForecast(d) {
      const container = document.getElementById('marineForecastContainer');
      container.innerHTML = '';
      const h = d.hourly;
      const now = new Date();
      
      // Group hours by day
      const days = {};
      let start = h.time.findIndex(t => new Date(t) >= now);
      if (start < 0) start = 0;
      
      for (let i = start; i < Math.min(start + 72, h.time.length); i++) {
        const t = new Date(h.time[i]);
        const dayKey = t.toDateString();
        if (!days[dayKey]) {
          days[dayKey] = {
            date: t,
            hours: []
          };
        }
        days[dayKey].hours.push({
          time: t,
          temp: Math.round(h.temperature_2m[i]),
          windSpeed: msToKnots(h.wind_speed_10m[i]),
          windDir: getWindDirection(h.wind_direction_10m[i]),
          windDirDeg: h.wind_direction_10m[i],
          precipitation: h.precipitation[i],
          weatherCode: h.weather_code ? h.weather_code[i] : 0,
          cloudCover: h.cloud_cover ? h.cloud_cover[i] : 0,
          index: i
        });
      }
      
      // Only show 3 days
      const dayKeys = Object.keys(days).slice(0, 3);
      
      dayKeys.forEach((dayKey, dayIndex) => {
        const day = days[dayKey];
        const panel = document.createElement('div');
        panel.className = 'forecast-day-panel';
        
        // Day header
        const dayName = dayIndex === 0 ? 'Today' : 
                       dayIndex === 1 ? 'Tomorrow' : 
                       day.date.toLocaleDateString('en-CA', { weekday: 'long' });
        
        const dateStr = day.date.toLocaleDateString('en-CA', { month: 'short', day: 'numeric' });
        
        // Calculate day summary
        const maxWind = Math.max(...day.hours.map(h => h.windSpeed));
        const totalPrecip = day.hours.reduce((sum, h) => sum + h.precipitation, 0);
        
        let summaryParts = [`Max wind ${maxWind} kts`];
        if (totalPrecip > 0.5) {
          summaryParts.push(`${totalPrecip.toFixed(1)} mm precip`);
        }
        
        panel.innerHTML = `
          <div class="forecast-day-header">
            <div class="forecast-day-name">${dayName} ¬∑ ${dateStr}</div>
            <div class="forecast-day-summary">${summaryParts.join(' ¬∑ ')}</div>
          </div>
          <div class="forecast-hours-grid" id="forecastDay${dayIndex}"></div>
        `;
        
        container.appendChild(panel);
        
        // Add hourly cells in 3 rows of 8
        const grid = document.getElementById(`forecastDay${dayIndex}`);
        day.hours.forEach((hour, hourIndex) => {
          const isCurrent = dayIndex === 0 && hourIndex === 0;
          const cell = document.createElement('div');
          cell.className = `forecast-hour-cell ${isCurrent ? 'current' : ''}`;
          
          // Get weather icon based on weather code
          const icon = weatherIcons[hour.weatherCode] || getSimpleWeatherIcon(hour);
          
          cell.innerHTML = `
            <div class="hour-cell-time">${formatTime(hour.time)}</div>
            <div class="hour-cell-icon">${icon}</div>
            <div class="hour-cell-temp">${hour.temp}¬∞C</div>
            <div class="hour-cell-wind ${getWindClass(hour.windSpeed)}">${hour.windSpeed} kts</div>
            <div class="hour-cell-wind-dir">${hour.windDir}</div>
            <div class="hour-cell-rain ${hour.precipitation < 0.1 ? 'none' : ''}">${hour.precipitation >= 0.1 ? hour.precipitation.toFixed(1) + ' mm' : '‚Äî'}</div>
          `;
          
          grid.appendChild(cell);
        });
      });
    }
    
    // Fallback simple weather icon based on conditions
    function getSimpleWeatherIcon(hour) {
      const isDay = hour.time.getHours() >= 6 && hour.time.getHours() < 20;
      if (hour.precipitation > 1) return 'üåßÔ∏è';
      if (hour.precipitation > 0.1) return 'üå¶Ô∏è';
      if (hour.cloudCover > 80) return '‚òÅÔ∏è';
      if (hour.cloudCover > 40) return isDay ? '‚õÖ' : '‚òÅÔ∏è';
      return isDay ? '‚òÄÔ∏è' : 'üåô';
    }

    function buildTides(tides) {
      const g = document.getElementById('tideGrid'); g.innerHTML = '';
      tides.forEach(t => {
        const c = document.createElement('div'); c.className = 'tide-card';
        c.innerHTML = `<div class="tide-time">${formatDay(t.time)} ${formatTime(t.time)}</div>
          <div class="tide-type ${t.type}">${t.type === 'high' ? '‚ñ≤ High Tide' : '‚ñº Low Tide'}</div>
          <div class="tide-height">${t.height} m</div>`;
        g.appendChild(c);
      });
    }

    async function initialize() {
      document.getElementById('loadingState').style.display = 'flex';
      document.getElementById('errorState').style.display = 'none';
      document.getElementById('mainContent').classList.remove('loaded');
      
      try {
        const weather = await fetchWeatherData();
        const tides = calculateTides();
        updateCurrent(weather);
        build3DayForecast(weather);
        buildTides(tides);
        updateCurrentsDisplay();
        document.getElementById('loadingState').style.display = 'none';
        document.getElementById('mainContent').classList.add('loaded');
      } catch (e) {
        console.error('Error:', e);
        showError(e.message);
      }
    }

    initialize();
    setInterval(initialize, CONFIG.refreshInterval);
    document.getElementById('refreshBtn').addEventListener('click', initialize);
  </script>
</body>
</html>
